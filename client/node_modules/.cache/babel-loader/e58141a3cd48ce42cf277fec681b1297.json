{"ast":null,"code":"/*\n Highcharts JS v6.1.4 (2018-09-25)\n\n (c) 2009-2016 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (T, K) {\n  \"object\" === typeof module && module.exports ? module.exports = T.document ? K(T) : K : \"function\" === typeof define && define.amd ? define(function () {\n    return K(T);\n  }) : T.Highcharts = K(T);\n})(\"undefined\" !== typeof window ? window : this, function (T) {\n  var K = function () {\n    var a = \"undefined\" === typeof T ? window : T,\n        C = a.document,\n        E = a.navigator && a.navigator.userAgent || \"\",\n        F = C && C.createElementNS && !!C.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n        m = /(edge|msie|trident)/i.test(E) && !a.opera,\n        h = -1 !== E.indexOf(\"Firefox\"),\n        e = -1 !== E.indexOf(\"Chrome\"),\n        t = h && 4 > parseInt(E.split(\"Firefox/\")[1], 10);\n    return a.Highcharts ? a.Highcharts.error(16, !0) : {\n      product: \"Highcharts\",\n      version: \"6.1.4\",\n      deg2rad: 2 * Math.PI / 360,\n      doc: C,\n      hasBidiBug: t,\n      hasTouch: C && void 0 !== C.documentElement.ontouchstart,\n      isMS: m,\n      isWebKit: -1 !== E.indexOf(\"AppleWebKit\"),\n      isFirefox: h,\n      isChrome: e,\n      isSafari: !e && -1 !== E.indexOf(\"Safari\"),\n      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(E),\n      SVG_NS: \"http://www.w3.org/2000/svg\",\n      chartCount: 0,\n      seriesTypes: {},\n      symbolSizes: {},\n      svg: F,\n      win: a,\n      marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"],\n      noop: function noop() {},\n      charts: []\n    };\n  }();\n\n  (function (a) {\n    a.timers = [];\n    var C = a.charts,\n        E = a.doc,\n        F = a.win;\n\n    a.error = function (m, h) {\n      m = a.isNumber(m) ? \"Highcharts error #\" + m + \": www.highcharts.com/errors/\" + m : m;\n      if (h) throw Error(m);\n      F.console && console.log(m);\n    };\n\n    a.Fx = function (a, h, e) {\n      this.options = h;\n      this.elem = a;\n      this.prop = e;\n    };\n\n    a.Fx.prototype = {\n      dSetter: function dSetter() {\n        var a = this.paths[0],\n            h = this.paths[1],\n            e = [],\n            t = this.now,\n            x = a.length,\n            p;\n        if (1 === t) e = this.toD;else if (x === h.length && 1 > t) for (; x--;) {\n          p = parseFloat(a[x]), e[x] = isNaN(p) ? h[x] : t * parseFloat(h[x] - p) + p;\n        } else e = h;\n        this.elem.attr(\"d\", e, null, !0);\n      },\n      update: function update() {\n        var a = this.elem,\n            h = this.prop,\n            e = this.now,\n            t = this.options.step;\n        if (this[h + \"Setter\"]) this[h + \"Setter\"]();else a.attr ? a.element && a.attr(h, e, null, !0) : a.style[h] = e + this.unit;\n        t && t.call(a, e, this);\n      },\n      run: function run(m, h, e) {\n        var t = this,\n            x = t.options,\n            p = function p(a) {\n          return p.stopped ? !1 : t.step(a);\n        },\n            u = F.requestAnimationFrame || function (a) {\n          setTimeout(a, 13);\n        },\n            f = function f() {\n          for (var c = 0; c < a.timers.length; c++) {\n            a.timers[c]() || a.timers.splice(c--, 1);\n          }\n\n          a.timers.length && u(f);\n        };\n\n        m !== h || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = m, this.end = h, this.unit = e, this.now = this.start, this.pos = 0, p.elem = this.elem, p.prop = this.prop, p() && 1 === a.timers.push(p) && u(f)) : (delete x.curAnim[this.prop], x.complete && 0 === a.keys(x.curAnim).length && x.complete.call(this.elem));\n      },\n      step: function step(m) {\n        var h = +new Date(),\n            e,\n            t = this.options,\n            x = this.elem,\n            p = t.complete,\n            u = t.duration,\n            f = t.curAnim;\n        x.attr && !x.element ? m = !1 : m || h >= u + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), e = f[this.prop] = !0, a.objectEach(f, function (a) {\n          !0 !== a && (e = !1);\n        }), e && p && p.call(x), m = !1) : (this.pos = t.easing((h - this.startTime) / u), this.now = this.start + (this.end - this.start) * this.pos, this.update(), m = !0);\n        return m;\n      },\n      initPath: function initPath(m, h, e) {\n        function t(a) {\n          var d, l;\n\n          for (b = a.length; b--;) {\n            d = \"M\" === a[b] || \"L\" === a[b], l = /[a-zA-Z]/.test(a[b + 3]), d && l && a.splice(b + 1, 0, a[b + 1], a[b + 2], a[b + 1], a[b + 2]);\n          }\n        }\n\n        function x(a, d) {\n          for (; a.length < l;) {\n            a[0] = d[l - a.length];\n            var c = a.slice(0, r);\n            [].splice.apply(a, [0, 0].concat(c));\n            v && (c = a.slice(a.length - r), [].splice.apply(a, [a.length, 0].concat(c)), b--);\n          }\n\n          a[0] = \"M\";\n        }\n\n        function p(a, b) {\n          for (var c = (l - a.length) / r; 0 < c && c--;) {\n            d = a.slice().splice(a.length / q - r, r * q), d[0] = b[l - r - c * r], k && (d[r - 6] = d[r - 2], d[r - 5] = d[r - 1]), [].splice.apply(a, [a.length / q, 0].concat(d)), v && c--;\n          }\n        }\n\n        h = h || \"\";\n        var u,\n            f = m.startX,\n            c = m.endX,\n            k = -1 < h.indexOf(\"C\"),\n            r = k ? 7 : 3,\n            l,\n            d,\n            b;\n        h = h.split(\" \");\n        e = e.slice();\n        var v = m.isArea,\n            q = v ? 2 : 1,\n            I;\n        k && (t(h), t(e));\n\n        if (f && c) {\n          for (b = 0; b < f.length; b++) {\n            if (f[b] === c[0]) {\n              u = b;\n              break;\n            } else if (f[0] === c[c.length - f.length + b]) {\n              u = b;\n              I = !0;\n              break;\n            }\n          }\n\n          void 0 === u && (h = []);\n        }\n\n        h.length && a.isNumber(u) && (l = e.length + u * q * r, I ? (x(h, e), p(e, h)) : (x(e, h), p(h, e)));\n        return [h, e];\n      },\n      fillSetter: function fillSetter() {\n        a.Fx.prototype.strokeSetter.apply(this, arguments);\n      },\n      strokeSetter: function strokeSetter() {\n        this.elem.attr(this.prop, a.color(this.start).tweenTo(a.color(this.end), this.pos), null, !0);\n      }\n    };\n\n    a.merge = function () {\n      var m,\n          h = arguments,\n          e,\n          t = {},\n          x = function x(e, m) {\n        \"object\" !== typeof e && (e = {});\n        a.objectEach(m, function (f, c) {\n          !a.isObject(f, !0) || a.isClass(f) || a.isDOMElement(f) ? e[c] = m[c] : e[c] = x(e[c] || {}, f);\n        });\n        return e;\n      };\n\n      !0 === h[0] && (t = h[1], h = Array.prototype.slice.call(h, 2));\n      e = h.length;\n\n      for (m = 0; m < e; m++) {\n        t = x(t, h[m]);\n      }\n\n      return t;\n    };\n\n    a.pInt = function (a, h) {\n      return parseInt(a, h || 10);\n    };\n\n    a.isString = function (a) {\n      return \"string\" === typeof a;\n    };\n\n    a.isArray = function (a) {\n      a = Object.prototype.toString.call(a);\n      return \"[object Array]\" === a || \"[object Array Iterator]\" === a;\n    };\n\n    a.isObject = function (m, h) {\n      return !!m && \"object\" === typeof m && (!h || !a.isArray(m));\n    };\n\n    a.isDOMElement = function (m) {\n      return a.isObject(m) && \"number\" === typeof m.nodeType;\n    };\n\n    a.isClass = function (m) {\n      var h = m && m.constructor;\n      return !(!a.isObject(m, !0) || a.isDOMElement(m) || !h || !h.name || \"Object\" === h.name);\n    };\n\n    a.isNumber = function (a) {\n      return \"number\" === typeof a && !isNaN(a) && Infinity > a && -Infinity < a;\n    };\n\n    a.erase = function (a, h) {\n      for (var e = a.length; e--;) {\n        if (a[e] === h) {\n          a.splice(e, 1);\n          break;\n        }\n      }\n    };\n\n    a.defined = function (a) {\n      return void 0 !== a && null !== a;\n    };\n\n    a.attr = function (m, h, e) {\n      var t;\n      a.isString(h) ? a.defined(e) ? m.setAttribute(h, e) : m && m.getAttribute && ((t = m.getAttribute(h)) || \"class\" !== h || (t = m.getAttribute(h + \"Name\"))) : a.defined(h) && a.isObject(h) && a.objectEach(h, function (a, e) {\n        m.setAttribute(e, a);\n      });\n      return t;\n    };\n\n    a.splat = function (m) {\n      return a.isArray(m) ? m : [m];\n    };\n\n    a.syncTimeout = function (a, h, e) {\n      if (h) return setTimeout(a, h, e);\n      a.call(0, e);\n    };\n\n    a.clearTimeout = function (m) {\n      a.defined(m) && clearTimeout(m);\n    };\n\n    a.extend = function (a, h) {\n      var e;\n      a || (a = {});\n\n      for (e in h) {\n        a[e] = h[e];\n      }\n\n      return a;\n    };\n\n    a.pick = function () {\n      var a = arguments,\n          h,\n          e,\n          t = a.length;\n\n      for (h = 0; h < t; h++) {\n        if (e = a[h], void 0 !== e && null !== e) return e;\n      }\n    };\n\n    a.css = function (m, h) {\n      a.isMS && !a.svg && h && void 0 !== h.opacity && (h.filter = \"alpha(opacity\\x3d\" + 100 * h.opacity + \")\");\n      a.extend(m.style, h);\n    };\n\n    a.createElement = function (m, h, e, t, x) {\n      m = E.createElement(m);\n      var p = a.css;\n      h && a.extend(m, h);\n      x && p(m, {\n        padding: 0,\n        border: \"none\",\n        margin: 0\n      });\n      e && p(m, e);\n      t && t.appendChild(m);\n      return m;\n    };\n\n    a.extendClass = function (m, h) {\n      var e = function e() {};\n\n      e.prototype = new m();\n      a.extend(e.prototype, h);\n      return e;\n    };\n\n    a.pad = function (a, h, e) {\n      return Array((h || 2) + 1 - String(a).replace(\"-\", \"\").length).join(e || 0) + a;\n    };\n\n    a.relativeLength = function (a, h, e) {\n      return /%$/.test(a) ? h * parseFloat(a) / 100 + (e || 0) : parseFloat(a);\n    };\n\n    a.wrap = function (a, h, e) {\n      var m = a[h];\n\n      a[h] = function () {\n        var a = Array.prototype.slice.call(arguments),\n            p = arguments,\n            u = this;\n\n        u.proceed = function () {\n          m.apply(u, arguments.length ? arguments : p);\n        };\n\n        a.unshift(m);\n        a = e.apply(this, a);\n        u.proceed = null;\n        return a;\n      };\n    };\n\n    a.formatSingle = function (m, h, e) {\n      var t = /\\.([0-9])/,\n          x = a.defaultOptions.lang;\n      /f$/.test(m) ? (e = (e = m.match(t)) ? e[1] : -1, null !== h && (h = a.numberFormat(h, e, x.decimalPoint, -1 < m.indexOf(\",\") ? x.thousandsSep : \"\"))) : h = (e || a.time).dateFormat(m, h);\n      return h;\n    };\n\n    a.format = function (m, h, e) {\n      for (var t = \"{\", x = !1, p, u, f, c, k = [], r; m;) {\n        t = m.indexOf(t);\n        if (-1 === t) break;\n        p = m.slice(0, t);\n\n        if (x) {\n          p = p.split(\":\");\n          u = p.shift().split(\".\");\n          c = u.length;\n          r = h;\n\n          for (f = 0; f < c; f++) {\n            r && (r = r[u[f]]);\n          }\n\n          p.length && (r = a.formatSingle(p.join(\":\"), r, e));\n          k.push(r);\n        } else k.push(p);\n\n        m = m.slice(t + 1);\n        t = (x = !x) ? \"}\" : \"{\";\n      }\n\n      k.push(m);\n      return k.join(\"\");\n    };\n\n    a.getMagnitude = function (a) {\n      return Math.pow(10, Math.floor(Math.log(a) / Math.LN10));\n    };\n\n    a.normalizeTickInterval = function (m, h, e, t, x) {\n      var p,\n          u = m;\n      e = a.pick(e, 1);\n      p = m / e;\n      h || (h = x ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === t && (1 === e ? h = a.grep(h, function (a) {\n        return 0 === a % 1;\n      }) : .1 >= e && (h = [1 / e])));\n\n      for (t = 0; t < h.length && !(u = h[t], x && u * e >= m || !x && p <= (h[t] + (h[t + 1] || h[t])) / 2); t++) {\n        ;\n      }\n\n      return u = a.correctFloat(u * e, -Math.round(Math.log(.001) / Math.LN10));\n    };\n\n    a.stableSort = function (a, h) {\n      var e = a.length,\n          m,\n          x;\n\n      for (x = 0; x < e; x++) {\n        a[x].safeI = x;\n      }\n\n      a.sort(function (a, e) {\n        m = h(a, e);\n        return 0 === m ? a.safeI - e.safeI : m;\n      });\n\n      for (x = 0; x < e; x++) {\n        delete a[x].safeI;\n      }\n    };\n\n    a.arrayMin = function (a) {\n      for (var h = a.length, e = a[0]; h--;) {\n        a[h] < e && (e = a[h]);\n      }\n\n      return e;\n    };\n\n    a.arrayMax = function (a) {\n      for (var h = a.length, e = a[0]; h--;) {\n        a[h] > e && (e = a[h]);\n      }\n\n      return e;\n    };\n\n    a.destroyObjectProperties = function (m, h) {\n      a.objectEach(m, function (a, t) {\n        a && a !== h && a.destroy && a.destroy();\n        delete m[t];\n      });\n    };\n\n    a.discardElement = function (m) {\n      var h = a.garbageBin;\n      h || (h = a.createElement(\"div\"));\n      m && h.appendChild(m);\n      h.innerHTML = \"\";\n    };\n\n    a.correctFloat = function (a, h) {\n      return parseFloat(a.toPrecision(h || 14));\n    };\n\n    a.setAnimation = function (m, h) {\n      h.renderer.globalAnimation = a.pick(m, h.options.chart.animation, !0);\n    };\n\n    a.animObject = function (m) {\n      return a.isObject(m) ? a.merge(m) : {\n        duration: m ? 500 : 0\n      };\n    };\n\n    a.timeUnits = {\n      millisecond: 1,\n      second: 1E3,\n      minute: 6E4,\n      hour: 36E5,\n      day: 864E5,\n      week: 6048E5,\n      month: 24192E5,\n      year: 314496E5\n    };\n\n    a.numberFormat = function (m, h, e, t) {\n      m = +m || 0;\n      h = +h;\n      var x = a.defaultOptions.lang,\n          p = (m.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          u,\n          f,\n          c = m.toString().split(\"e\");\n      -1 === h ? h = Math.min(p, 20) : a.isNumber(h) ? h && c[1] && 0 > c[1] && (u = h + +c[1], 0 <= u ? (c[0] = (+c[0]).toExponential(u).split(\"e\")[0], h = u) : (c[0] = c[0].split(\".\")[0] || 0, m = 20 > h ? (c[0] * Math.pow(10, c[1])).toFixed(h) : 0, c[1] = 0)) : h = 2;\n      f = (Math.abs(c[1] ? c[0] : m) + Math.pow(10, -Math.max(h, p) - 1)).toFixed(h);\n      p = String(a.pInt(f));\n      u = 3 < p.length ? p.length % 3 : 0;\n      e = a.pick(e, x.decimalPoint);\n      t = a.pick(t, x.thousandsSep);\n      m = (0 > m ? \"-\" : \"\") + (u ? p.substr(0, u) + t : \"\");\n      m += p.substr(u).replace(/(\\d{3})(?=\\d)/g, \"$1\" + t);\n      h && (m += e + f.slice(-h));\n      c[1] && 0 !== +m && (m += \"e\" + c[1]);\n      return m;\n    };\n\n    Math.easeInOutSine = function (a) {\n      return -.5 * (Math.cos(Math.PI * a) - 1);\n    };\n\n    a.getStyle = function (m, h, e) {\n      if (\"width\" === h) return Math.max(0, Math.min(m.offsetWidth, m.scrollWidth) - a.getStyle(m, \"padding-left\") - a.getStyle(m, \"padding-right\"));\n      if (\"height\" === h) return Math.max(0, Math.min(m.offsetHeight, m.scrollHeight) - a.getStyle(m, \"padding-top\") - a.getStyle(m, \"padding-bottom\"));\n      F.getComputedStyle || a.error(27, !0);\n      if (m = F.getComputedStyle(m, void 0)) m = m.getPropertyValue(h), a.pick(e, \"opacity\" !== h) && (m = a.pInt(m));\n      return m;\n    };\n\n    a.inArray = function (m, h, e) {\n      return (a.indexOfPolyfill || Array.prototype.indexOf).call(h, m, e);\n    };\n\n    a.grep = function (m, h) {\n      return (a.filterPolyfill || Array.prototype.filter).call(m, h);\n    };\n\n    a.find = Array.prototype.find ? function (a, h) {\n      return a.find(h);\n    } : function (a, h) {\n      var e,\n          t = a.length;\n\n      for (e = 0; e < t; e++) {\n        if (h(a[e], e)) return a[e];\n      }\n    };\n\n    a.some = function (m, h, e) {\n      return (a.somePolyfill || Array.prototype.some).call(m, h, e);\n    };\n\n    a.map = function (a, h) {\n      for (var e = [], t = 0, x = a.length; t < x; t++) {\n        e[t] = h.call(a[t], a[t], t, a);\n      }\n\n      return e;\n    };\n\n    a.keys = function (m) {\n      return (a.keysPolyfill || Object.keys).call(void 0, m);\n    };\n\n    a.reduce = function (m, h, e) {\n      return (a.reducePolyfill || Array.prototype.reduce).apply(m, 2 < arguments.length ? [h, e] : [h]);\n    };\n\n    a.offset = function (a) {\n      var h = E.documentElement;\n      a = a.parentElement || a.parentNode ? a.getBoundingClientRect() : {\n        top: 0,\n        left: 0\n      };\n      return {\n        top: a.top + (F.pageYOffset || h.scrollTop) - (h.clientTop || 0),\n        left: a.left + (F.pageXOffset || h.scrollLeft) - (h.clientLeft || 0)\n      };\n    };\n\n    a.stop = function (m, h) {\n      for (var e = a.timers.length; e--;) {\n        a.timers[e].elem !== m || h && h !== a.timers[e].prop || (a.timers[e].stopped = !0);\n      }\n    };\n\n    a.each = function (m, h, e) {\n      return (a.forEachPolyfill || Array.prototype.forEach).call(m, h, e);\n    };\n\n    a.objectEach = function (a, h, e) {\n      for (var t in a) {\n        a.hasOwnProperty(t) && h.call(e || a[t], a[t], t, a);\n      }\n    };\n\n    a.addEvent = function (m, h, e, t) {\n      var x,\n          p = m.addEventListener || a.addEventListenerPolyfill;\n      x = \"function\" === typeof m && m.prototype ? m.prototype.protoEvents = m.prototype.protoEvents || {} : m.hcEvents = m.hcEvents || {};\n      a.Point && m instanceof a.Point && m.series && m.series.chart && (m.series.chart.runTrackerClick = !0);\n      p && p.call(m, h, e, !1);\n      x[h] || (x[h] = []);\n      x[h].push(e);\n      t && a.isNumber(t.order) && (e.order = t.order, x[h].sort(function (a, f) {\n        return a.order - f.order;\n      }));\n      return function () {\n        a.removeEvent(m, h, e);\n      };\n    };\n\n    a.removeEvent = function (m, h, e) {\n      function t(f, c) {\n        var k = m.removeEventListener || a.removeEventListenerPolyfill;\n        k && k.call(m, f, c, !1);\n      }\n\n      function x(f) {\n        var c, k;\n        m.nodeName && (h ? (c = {}, c[h] = !0) : c = f, a.objectEach(c, function (a, c) {\n          if (f[c]) for (k = f[c].length; k--;) {\n            t(c, f[c][k]);\n          }\n        }));\n      }\n\n      var p, u;\n      a.each([\"protoEvents\", \"hcEvents\"], function (f) {\n        var c = m[f];\n        c && (h ? (p = c[h] || [], e ? (u = a.inArray(e, p), -1 < u && (p.splice(u, 1), c[h] = p), t(h, e)) : (x(c), c[h] = [])) : (x(c), m[f] = {}));\n      });\n    };\n\n    a.fireEvent = function (m, h, e, t) {\n      var x, p, u, f, c;\n      e = e || {};\n      E.createEvent && (m.dispatchEvent || m.fireEvent) ? (x = E.createEvent(\"Events\"), x.initEvent(h, !0, !0), a.extend(x, e), m.dispatchEvent ? m.dispatchEvent(x) : m.fireEvent(h, x)) : a.each([\"protoEvents\", \"hcEvents\"], function (k) {\n        if (m[k]) for (p = m[k][h] || [], u = p.length, e.target || a.extend(e, {\n          preventDefault: function preventDefault() {\n            e.defaultPrevented = !0;\n          },\n          target: m,\n          type: h\n        }), f = 0; f < u; f++) {\n          (c = p[f]) && !1 === c.call(m, e) && e.preventDefault();\n        }\n      });\n      t && !e.defaultPrevented && t.call(m, e);\n    };\n\n    a.animate = function (m, h, e) {\n      var t,\n          x = \"\",\n          p,\n          u,\n          f;\n      a.isObject(e) || (f = arguments, e = {\n        duration: f[2],\n        easing: f[3],\n        complete: f[4]\n      });\n      a.isNumber(e.duration) || (e.duration = 400);\n      e.easing = \"function\" === typeof e.easing ? e.easing : Math[e.easing] || Math.easeInOutSine;\n      e.curAnim = a.merge(h);\n      a.objectEach(h, function (c, f) {\n        a.stop(m, f);\n        u = new a.Fx(m, e, f);\n        p = null;\n        \"d\" === f ? (u.paths = u.initPath(m, m.d, h.d), u.toD = h.d, t = 0, p = 1) : m.attr ? t = m.attr(f) : (t = parseFloat(a.getStyle(m, f)) || 0, \"opacity\" !== f && (x = \"px\"));\n        p || (p = c);\n        p && p.match && p.match(\"px\") && (p = p.replace(/px/g, \"\"));\n        u.run(t, p, x);\n      });\n    };\n\n    a.seriesType = function (m, h, e, t, x) {\n      var p = a.getOptions(),\n          u = a.seriesTypes;\n      p.plotOptions[m] = a.merge(p.plotOptions[h], e);\n      u[m] = a.extendClass(u[h] || function () {}, t);\n      u[m].prototype.type = m;\n      x && (u[m].prototype.pointClass = a.extendClass(a.Point, x));\n      return u[m];\n    };\n\n    a.uniqueKey = function () {\n      var a = Math.random().toString(36).substring(2, 9),\n          h = 0;\n      return function () {\n        return \"highcharts-\" + a + \"-\" + h++;\n      };\n    }();\n\n    F.jQuery && (F.jQuery.fn.highcharts = function () {\n      var m = [].slice.call(arguments);\n      if (this[0]) return m[0] ? (new a[a.isString(m[0]) ? m.shift() : \"Chart\"](this[0], m[0], m[1]), this) : C[a.attr(this[0], \"data-highcharts-chart\")];\n    });\n  })(K);\n\n  (function (a) {\n    var C = a.each,\n        E = a.isNumber,\n        F = a.map,\n        m = a.merge,\n        h = a.pInt;\n\n    a.Color = function (e) {\n      if (!(this instanceof a.Color)) return new a.Color(e);\n      this.init(e);\n    };\n\n    a.Color.prototype = {\n      parsers: [{\n        regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n        parse: function parse(a) {\n          return [h(a[1]), h(a[2]), h(a[3]), parseFloat(a[4], 10)];\n        }\n      }, {\n        regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n        parse: function parse(a) {\n          return [h(a[1]), h(a[2]), h(a[3]), 1];\n        }\n      }],\n      names: {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      },\n      init: function init(e) {\n        var h, x, p, u;\n        if ((this.input = e = this.names[e && e.toLowerCase ? e.toLowerCase() : \"\"] || e) && e.stops) this.stops = F(e.stops, function (f) {\n          return new a.Color(f[1]);\n        });else if (e && e.charAt && \"#\" === e.charAt() && (h = e.length, e = parseInt(e.substr(1), 16), 7 === h ? x = [(e & 16711680) >> 16, (e & 65280) >> 8, e & 255, 1] : 4 === h && (x = [(e & 3840) >> 4 | (e & 3840) >> 8, (e & 240) >> 4 | e & 240, (e & 15) << 4 | e & 15, 1])), !x) for (p = this.parsers.length; p-- && !x;) {\n          u = this.parsers[p], (h = u.regex.exec(e)) && (x = u.parse(h));\n        }\n        this.rgba = x || [];\n      },\n      get: function get(a) {\n        var e = this.input,\n            h = this.rgba,\n            p;\n        this.stops ? (p = m(e), p.stops = [].concat(p.stops), C(this.stops, function (e, f) {\n          p.stops[f] = [p.stops[f][0], e.get(a)];\n        })) : p = h && E(h[0]) ? \"rgb\" === a || !a && 1 === h[3] ? \"rgb(\" + h[0] + \",\" + h[1] + \",\" + h[2] + \")\" : \"a\" === a ? h[3] : \"rgba(\" + h.join(\",\") + \")\" : e;\n        return p;\n      },\n      brighten: function brighten(a) {\n        var e,\n            x = this.rgba;\n        if (this.stops) C(this.stops, function (e) {\n          e.brighten(a);\n        });else if (E(a) && 0 !== a) for (e = 0; 3 > e; e++) {\n          x[e] += h(255 * a), 0 > x[e] && (x[e] = 0), 255 < x[e] && (x[e] = 255);\n        }\n        return this;\n      },\n      setOpacity: function setOpacity(a) {\n        this.rgba[3] = a;\n        return this;\n      },\n      tweenTo: function tweenTo(a, h) {\n        var e = this.rgba,\n            p = a.rgba;\n        p.length && e && e.length ? (a = 1 !== p[3] || 1 !== e[3], h = (a ? \"rgba(\" : \"rgb(\") + Math.round(p[0] + (e[0] - p[0]) * (1 - h)) + \",\" + Math.round(p[1] + (e[1] - p[1]) * (1 - h)) + \",\" + Math.round(p[2] + (e[2] - p[2]) * (1 - h)) + (a ? \",\" + (p[3] + (e[3] - p[3]) * (1 - h)) : \"\") + \")\") : h = a.input || \"none\";\n        return h;\n      }\n    };\n\n    a.color = function (e) {\n      return new a.Color(e);\n    };\n  })(K);\n\n  (function (a) {\n    var C,\n        E,\n        F = a.addEvent,\n        m = a.animate,\n        h = a.attr,\n        e = a.charts,\n        t = a.color,\n        x = a.css,\n        p = a.createElement,\n        u = a.defined,\n        f = a.deg2rad,\n        c = a.destroyObjectProperties,\n        k = a.doc,\n        r = a.each,\n        l = a.extend,\n        d = a.erase,\n        b = a.grep,\n        v = a.hasTouch,\n        q = a.inArray,\n        I = a.isArray,\n        w = a.isFirefox,\n        L = a.isMS,\n        B = a.isObject,\n        H = a.isString,\n        n = a.isWebKit,\n        D = a.merge,\n        A = a.noop,\n        M = a.objectEach,\n        G = a.pick,\n        g = a.pInt,\n        y = a.removeEvent,\n        Q = a.stop,\n        N = a.svg,\n        J = a.SVG_NS,\n        P = a.symbolSizes,\n        O = a.win;\n\n    C = a.SVGElement = function () {\n      return this;\n    };\n\n    l(C.prototype, {\n      opacity: 1,\n      SVG_NS: J,\n      textProps: \"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor\".split(\" \"),\n      init: function init(a, g) {\n        this.element = \"span\" === g ? p(g) : k.createElementNS(this.SVG_NS, g);\n        this.renderer = a;\n      },\n      animate: function animate(z, g, b) {\n        g = a.animObject(G(g, this.renderer.globalAnimation, !0));\n        0 !== g.duration ? (b && (g.complete = b), m(this, z, g)) : (this.attr(z, null, b), g.step && g.step.call(this));\n        return this;\n      },\n      complexColor: function complexColor(z, g, b) {\n        var y = this.renderer,\n            d,\n            c,\n            l,\n            n,\n            f,\n            J,\n            A,\n            k,\n            R,\n            v,\n            q,\n            w = [],\n            N;\n        a.fireEvent(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          z.radialGradient ? c = \"radialGradient\" : z.linearGradient && (c = \"linearGradient\");\n          c && (l = z[c], f = y.gradients, A = z.stops, v = b.radialReference, I(l) && (z[c] = l = {\n            x1: l[0],\n            y1: l[1],\n            x2: l[2],\n            y2: l[3],\n            gradientUnits: \"userSpaceOnUse\"\n          }), \"radialGradient\" === c && v && !u(l.gradientUnits) && (n = l, l = D(l, y.getRadialAttr(v, n), {\n            gradientUnits: \"userSpaceOnUse\"\n          })), M(l, function (a, z) {\n            \"id\" !== z && w.push(z, a);\n          }), M(A, function (a) {\n            w.push(a);\n          }), w = w.join(\",\"), f[w] ? q = f[w].attr(\"id\") : (l.id = q = a.uniqueKey(), f[w] = J = y.createElement(c).attr(l).add(y.defs), J.radAttr = n, J.stops = [], r(A, function (z) {\n            0 === z[1].indexOf(\"rgba\") ? (d = a.color(z[1]), k = d.get(\"rgb\"), R = d.get(\"a\")) : (k = z[1], R = 1);\n            z = y.createElement(\"stop\").attr({\n              offset: z[0],\n              \"stop-color\": k,\n              \"stop-opacity\": R\n            }).add(J);\n            J.stops.push(z);\n          })), N = \"url(\" + y.url + \"#\" + q + \")\", b.setAttribute(g, N), b.gradient = w, z.toString = function () {\n            return N;\n          });\n        });\n      },\n      applyTextOutline: function applyTextOutline(z) {\n        var g = this.element,\n            b,\n            y,\n            c,\n            l,\n            n;\n        -1 !== z.indexOf(\"contrast\") && (z = z.replace(/contrast/g, this.renderer.getContrast(g.style.fill)));\n        z = z.split(\" \");\n        y = z[z.length - 1];\n\n        if ((c = z[0]) && \"none\" !== c && a.svg) {\n          this.fakeTS = !0;\n          z = [].slice.call(g.getElementsByTagName(\"tspan\"));\n          this.ySetter = this.xSetter;\n          c = c.replace(/(^[\\d\\.]+)(.*?)$/g, function (a, z, g) {\n            return 2 * z + g;\n          });\n\n          for (n = z.length; n--;) {\n            b = z[n], \"highcharts-text-outline\" === b.getAttribute(\"class\") && d(z, g.removeChild(b));\n          }\n\n          l = g.firstChild;\n          r(z, function (a, z) {\n            0 === z && (a.setAttribute(\"x\", g.getAttribute(\"x\")), z = g.getAttribute(\"y\"), a.setAttribute(\"y\", z || 0), null === z && g.setAttribute(\"y\", 0));\n            a = a.cloneNode(1);\n            h(a, {\n              \"class\": \"highcharts-text-outline\",\n              fill: y,\n              stroke: y,\n              \"stroke-width\": c,\n              \"stroke-linejoin\": \"round\"\n            });\n            g.insertBefore(a, l);\n          });\n        }\n      },\n      attr: function attr(a, g, b, y) {\n        var z,\n            d = this.element,\n            c,\n            l = this,\n            n,\n            f;\n        \"string\" === typeof a && void 0 !== g && (z = a, a = {}, a[z] = g);\n        \"string\" === typeof a ? l = (this[a + \"Getter\"] || this._defaultGetter).call(this, a, d) : (M(a, function (z, g) {\n          n = !1;\n          y || Q(this, g);\n          this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(g) && (c || (this.symbolAttr(a), c = !0), n = !0);\n          !this.rotation || \"x\" !== g && \"y\" !== g || (this.doTransform = !0);\n          n || (f = this[g + \"Setter\"] || this._defaultSetter, f.call(this, z, g, d), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(g) && this.updateShadows(g, z, f));\n        }, this), this.afterSetters());\n        b && b.call(this);\n        return l;\n      },\n      afterSetters: function afterSetters() {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      },\n      updateShadows: function updateShadows(a, g, b) {\n        for (var z = this.shadows, y = z.length; y--;) {\n          b.call(z[y], \"height\" === a ? Math.max(g - (z[y].cutHeight || 0), 0) : \"d\" === a ? this.d : g, a, z[y]);\n        }\n      },\n      addClass: function addClass(a, g) {\n        var z = this.attr(\"class\") || \"\";\n        -1 === z.indexOf(a) && (g || (a = (z + (z ? \" \" : \"\") + a).replace(\"  \", \" \")), this.attr(\"class\", a));\n        return this;\n      },\n      hasClass: function hasClass(a) {\n        return -1 !== q(a, (this.attr(\"class\") || \"\").split(\" \"));\n      },\n      removeClass: function removeClass(a) {\n        return this.attr(\"class\", (this.attr(\"class\") || \"\").replace(a, \"\"));\n      },\n      symbolAttr: function symbolAttr(a) {\n        var z = this;\n        r(\"x y r start end width height innerR anchorX anchorY\".split(\" \"), function (g) {\n          z[g] = G(a[g], z[g]);\n        });\n        z.attr({\n          d: z.renderer.symbols[z.symbolName](z.x, z.y, z.width, z.height, z)\n        });\n      },\n      clip: function clip(a) {\n        return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\" : \"none\");\n      },\n      crisp: function crisp(a, g) {\n        var z;\n        g = g || a.strokeWidth || 0;\n        z = Math.round(g) % 2 / 2;\n        a.x = Math.floor(a.x || this.x || 0) + z;\n        a.y = Math.floor(a.y || this.y || 0) + z;\n        a.width = Math.floor((a.width || this.width || 0) - 2 * z);\n        a.height = Math.floor((a.height || this.height || 0) - 2 * z);\n        u(a.strokeWidth) && (a.strokeWidth = g);\n        return a;\n      },\n      css: function css(a) {\n        var z = this.styles,\n            b = {},\n            y = this.element,\n            d,\n            c = \"\",\n            n,\n            f = !z,\n            J = [\"textOutline\", \"textOverflow\", \"width\"];\n        a && a.color && (a.fill = a.color);\n        z && M(a, function (a, g) {\n          a !== z[g] && (b[g] = a, f = !0);\n        });\n        f && (z && (a = l(z, b)), a && (null === a.width || \"auto\" === a.width ? delete this.textWidth : \"text\" === y.nodeName.toLowerCase() && a.width && (d = this.textWidth = g(a.width))), this.styles = a, d && !N && this.renderer.forExport && delete a.width, y.namespaceURI === this.SVG_NS ? (n = function n(a, z) {\n          return \"-\" + z.toLowerCase();\n        }, M(a, function (a, z) {\n          -1 === q(z, J) && (c += z.replace(/([A-Z])/g, n) + \":\" + a + \";\");\n        }), c && h(y, \"style\", c)) : x(y, a), this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline)));\n        return this;\n      },\n      strokeWidth: function strokeWidth() {\n        return this[\"stroke-width\"] || 0;\n      },\n      on: function on(a, g) {\n        var z = this,\n            b = z.element;\n        v && \"click\" === a ? (b.ontouchstart = function (a) {\n          z.touchEventFired = Date.now();\n          a.preventDefault();\n          g.call(b, a);\n        }, b.onclick = function (a) {\n          (-1 === O.navigator.userAgent.indexOf(\"Android\") || 1100 < Date.now() - (z.touchEventFired || 0)) && g.call(b, a);\n        }) : b[\"on\" + a] = g;\n        return this;\n      },\n      setRadialReference: function setRadialReference(a) {\n        var z = this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = a;\n        z && z.radAttr && z.animate(this.renderer.getRadialAttr(a, z.radAttr));\n        return this;\n      },\n      translate: function translate(a, g) {\n        return this.attr({\n          translateX: a,\n          translateY: g\n        });\n      },\n      invert: function invert(a) {\n        this.inverted = a;\n        this.updateTransform();\n        return this;\n      },\n      updateTransform: function updateTransform() {\n        var a = this.translateX || 0,\n            g = this.translateY || 0,\n            b = this.scaleX,\n            y = this.scaleY,\n            d = this.inverted,\n            c = this.rotation,\n            l = this.matrix,\n            n = this.element;\n        d && (a += this.width, g += this.height);\n        a = [\"translate(\" + a + \",\" + g + \")\"];\n        u(l) && a.push(\"matrix(\" + l.join(\",\") + \")\");\n        d ? a.push(\"rotate(90) scale(-1,1)\") : c && a.push(\"rotate(\" + c + \" \" + G(this.rotationOriginX, n.getAttribute(\"x\"), 0) + \" \" + G(this.rotationOriginY, n.getAttribute(\"y\") || 0) + \")\");\n        (u(b) || u(y)) && a.push(\"scale(\" + G(b, 1) + \" \" + G(y, 1) + \")\");\n        a.length && n.setAttribute(\"transform\", a.join(\" \"));\n      },\n      toFront: function toFront() {\n        var a = this.element;\n        a.parentNode.appendChild(a);\n        return this;\n      },\n      align: function align(a, g, b) {\n        var z,\n            y,\n            c,\n            l,\n            n = {};\n        y = this.renderer;\n        c = y.alignedObjects;\n        var f, J;\n\n        if (a) {\n          if (this.alignOptions = a, this.alignByTranslate = g, !b || H(b)) this.alignTo = z = b || \"renderer\", d(c, this), c.push(this), b = null;\n        } else a = this.alignOptions, g = this.alignByTranslate, z = this.alignTo;\n\n        b = G(b, y[z], y);\n        z = a.align;\n        y = a.verticalAlign;\n        c = (b.x || 0) + (a.x || 0);\n        l = (b.y || 0) + (a.y || 0);\n        \"right\" === z ? f = 1 : \"center\" === z && (f = 2);\n        f && (c += (b.width - (a.width || 0)) / f);\n        n[g ? \"translateX\" : \"x\"] = Math.round(c);\n        \"bottom\" === y ? J = 1 : \"middle\" === y && (J = 2);\n        J && (l += (b.height - (a.height || 0)) / J);\n        n[g ? \"translateY\" : \"y\"] = Math.round(l);\n        this[this.placed ? \"animate\" : \"attr\"](n);\n        this.placed = !0;\n        this.alignAttr = n;\n        return this;\n      },\n      getBBox: function getBBox(a, g) {\n        var z,\n            b = this.renderer,\n            y,\n            d = this.element,\n            c = this.styles,\n            n,\n            J = this.textStr,\n            A,\n            k = b.cache,\n            v = b.cacheKeys,\n            q;\n        g = G(g, this.rotation);\n        y = g * f;\n        n = c && c.fontSize;\n        u(J) && (q = J.toString(), -1 === q.indexOf(\"\\x3c\") && (q = q.replace(/[0-9]/g, \"0\")), q += [\"\", g || 0, n, this.textWidth, c && c.textOverflow].join());\n        q && !a && (z = k[q]);\n\n        if (!z) {\n          if (d.namespaceURI === this.SVG_NS || b.forExport) {\n            try {\n              (A = this.fakeTS && function (a) {\n                r(d.querySelectorAll(\".highcharts-text-outline\"), function (z) {\n                  z.style.display = a;\n                });\n              }) && A(\"none\"), z = d.getBBox ? l({}, d.getBBox()) : {\n                width: d.offsetWidth,\n                height: d.offsetHeight\n              }, A && A(\"\");\n            } catch (W) {}\n\n            if (!z || 0 > z.width) z = {\n              width: 0,\n              height: 0\n            };\n          } else z = this.htmlGetBBox();\n\n          b.isSVG && (a = z.width, b = z.height, c && \"11px\" === c.fontSize && 17 === Math.round(b) && (z.height = b = 14), g && (z.width = Math.abs(b * Math.sin(y)) + Math.abs(a * Math.cos(y)), z.height = Math.abs(b * Math.cos(y)) + Math.abs(a * Math.sin(y))));\n\n          if (q && 0 < z.height) {\n            for (; 250 < v.length;) {\n              delete k[v.shift()];\n            }\n\n            k[q] || v.push(q);\n            k[q] = z;\n          }\n        }\n\n        return z;\n      },\n      show: function show(a) {\n        return this.attr({\n          visibility: a ? \"inherit\" : \"visible\"\n        });\n      },\n      hide: function hide() {\n        return this.attr({\n          visibility: \"hidden\"\n        });\n      },\n      fadeOut: function fadeOut(a) {\n        var z = this;\n        z.animate({\n          opacity: 0\n        }, {\n          duration: a || 150,\n          complete: function complete() {\n            z.attr({\n              y: -9999\n            });\n          }\n        });\n      },\n      add: function add(a) {\n        var z = this.renderer,\n            g = this.element,\n            b;\n        a && (this.parentGroup = a);\n        this.parentInverted = a && a.inverted;\n        void 0 !== this.textStr && z.buildText(this);\n        this.added = !0;\n        if (!a || a.handleZ || this.zIndex) b = this.zIndexSetter();\n        b || (a ? a.element : z.box).appendChild(g);\n        if (this.onAdd) this.onAdd();\n        return this;\n      },\n      safeRemoveChild: function safeRemoveChild(a) {\n        var z = a.parentNode;\n        z && z.removeChild(a);\n      },\n      destroy: function destroy() {\n        var a = this,\n            g = a.element || {},\n            b = a.renderer.isSVG && \"SPAN\" === g.nodeName && a.parentGroup,\n            y = g.ownerSVGElement,\n            c = a.clipPath;\n        g.onclick = g.onmouseout = g.onmouseover = g.onmousemove = g.point = null;\n        Q(a);\n        c && y && (r(y.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (a) {\n          var g = a.getAttribute(\"clip-path\"),\n              z = c.element.id;\n          (-1 < g.indexOf(\"(#\" + z + \")\") || -1 < g.indexOf('(\"#' + z + '\")')) && a.removeAttribute(\"clip-path\");\n        }), a.clipPath = c.destroy());\n\n        if (a.stops) {\n          for (y = 0; y < a.stops.length; y++) {\n            a.stops[y] = a.stops[y].destroy();\n          }\n\n          a.stops = null;\n        }\n\n        a.safeRemoveChild(g);\n\n        for (a.destroyShadows(); b && b.div && 0 === b.div.childNodes.length;) {\n          g = b.parentGroup, a.safeRemoveChild(b.div), delete b.div, b = g;\n        }\n\n        a.alignTo && d(a.renderer.alignedObjects, a);\n        M(a, function (g, z) {\n          delete a[z];\n        });\n        return null;\n      },\n      shadow: function shadow(a, g, b) {\n        var z = [],\n            y,\n            d,\n            c = this.element,\n            l,\n            n,\n            f,\n            J;\n        if (!a) this.destroyShadows();else if (!this.shadows) {\n          n = G(a.width, 3);\n          f = (a.opacity || .15) / n;\n          J = this.parentInverted ? \"(-1,-1)\" : \"(\" + G(a.offsetX, 1) + \", \" + G(a.offsetY, 1) + \")\";\n\n          for (y = 1; y <= n; y++) {\n            d = c.cloneNode(0), l = 2 * n + 1 - 2 * y, h(d, {\n              stroke: a.color || \"#000000\",\n              \"stroke-opacity\": f * y,\n              \"stroke-width\": l,\n              transform: \"translate\" + J,\n              fill: \"none\"\n            }), d.setAttribute(\"class\", (d.getAttribute(\"class\") || \"\") + \" highcharts-shadow\"), b && (h(d, \"height\", Math.max(h(d, \"height\") - l, 0)), d.cutHeight = l), g ? g.element.appendChild(d) : c.parentNode && c.parentNode.insertBefore(d, c), z.push(d);\n          }\n\n          this.shadows = z;\n        }\n        return this;\n      },\n      destroyShadows: function destroyShadows() {\n        r(this.shadows || [], function (a) {\n          this.safeRemoveChild(a);\n        }, this);\n        this.shadows = void 0;\n      },\n      xGetter: function xGetter(a) {\n        \"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\" : \"y\" === a && (a = \"cy\"));\n        return this._defaultGetter(a);\n      },\n      _defaultGetter: function _defaultGetter(a) {\n        a = G(this[a + \"Value\"], this[a], this.element ? this.element.getAttribute(a) : null, 0);\n        /^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));\n        return a;\n      },\n      dSetter: function dSetter(a, g, b) {\n        a && a.join && (a = a.join(\" \"));\n        /(NaN| {2}|^$)/.test(a) && (a = \"M 0 0\");\n        this[g] !== a && (b.setAttribute(g, a), this[g] = a);\n      },\n      dashstyleSetter: function dashstyleSetter(a) {\n        var b,\n            z = this[\"stroke-width\"];\n        \"inherit\" === z && (z = 1);\n\n        if (a = a && a.toLowerCase()) {\n          a = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (b = a.length; b--;) {\n            a[b] = g(a[b]) * z;\n          }\n\n          a = a.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", a);\n        }\n      },\n      alignSetter: function alignSetter(a) {\n        this.alignValue = a;\n        this.element.setAttribute(\"text-anchor\", {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        }[a]);\n      },\n      opacitySetter: function opacitySetter(a, g, b) {\n        this[g] = a;\n        b.setAttribute(g, a);\n      },\n      titleSetter: function titleSetter(a) {\n        var g = this.element.getElementsByTagName(\"title\")[0];\n        g || (g = k.createElementNS(this.SVG_NS, \"title\"), this.element.appendChild(g));\n        g.firstChild && g.removeChild(g.firstChild);\n        g.appendChild(k.createTextNode(String(G(a), \"\").replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"\\x3c\").replace(/&gt;/g, \"\\x3e\")));\n      },\n      textSetter: function textSetter(a) {\n        a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this));\n      },\n      fillSetter: function fillSetter(a, g, b) {\n        \"string\" === typeof a ? b.setAttribute(g, a) : a && this.complexColor(a, g, b);\n      },\n      visibilitySetter: function visibilitySetter(a, g, b) {\n        \"inherit\" === a ? b.removeAttribute(g) : this[g] !== a && b.setAttribute(g, a);\n        this[g] = a;\n      },\n      zIndexSetter: function zIndexSetter(a, b) {\n        var y = this.renderer,\n            z = this.parentGroup,\n            d = (z || y).element || y.box,\n            c,\n            l = this.element,\n            n,\n            f,\n            y = d === y.box;\n        c = this.added;\n        var J;\n        u(a) ? (l.setAttribute(\"data-z-index\", a), a = +a, this[b] === a && (c = !1)) : u(this[b]) && l.removeAttribute(\"data-z-index\");\n        this[b] = a;\n\n        if (c) {\n          (a = this.zIndex) && z && (z.handleZ = !0);\n          b = d.childNodes;\n\n          for (J = b.length - 1; 0 <= J && !n; J--) {\n            if (z = b[J], c = z.getAttribute(\"data-z-index\"), f = !u(c), z !== l) if (0 > a && f && !y && !J) d.insertBefore(l, b[J]), n = !0;else if (g(c) <= a || f && (!u(a) || 0 <= a)) d.insertBefore(l, b[J + 1] || null), n = !0;\n          }\n\n          n || (d.insertBefore(l, b[y ? 3 : 0] || null), n = !0);\n        }\n\n        return n;\n      },\n      _defaultSetter: function _defaultSetter(a, g, b) {\n        b.setAttribute(g, a);\n      }\n    });\n    C.prototype.yGetter = C.prototype.xGetter;\n\n    C.prototype.translateXSetter = C.prototype.translateYSetter = C.prototype.rotationSetter = C.prototype.verticalAlignSetter = C.prototype.rotationOriginXSetter = C.prototype.rotationOriginYSetter = C.prototype.scaleXSetter = C.prototype.scaleYSetter = C.prototype.matrixSetter = function (a, g) {\n      this[g] = a;\n      this.doTransform = !0;\n    };\n\n    C.prototype[\"stroke-widthSetter\"] = C.prototype.strokeSetter = function (a, g, b) {\n      this[g] = a;\n      this.stroke && this[\"stroke-width\"] ? (C.prototype.fillSetter.call(this, this.stroke, \"stroke\", b), b.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === g && 0 === a && this.hasStroke && (b.removeAttribute(\"stroke\"), this.hasStroke = !1);\n    };\n\n    E = a.SVGRenderer = function () {\n      this.init.apply(this, arguments);\n    };\n\n    l(E.prototype, {\n      Element: C,\n      SVG_NS: J,\n      init: function init(a, g, b, y, d, c) {\n        var z;\n        y = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        }).css(this.getStyle(y));\n        z = y.element;\n        a.appendChild(z);\n        h(a, \"dir\", \"ltr\");\n        -1 === a.innerHTML.indexOf(\"xmlns\") && h(z, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = z;\n        this.boxWrapper = y;\n        this.alignedObjects = [];\n        this.url = (w || n) && k.getElementsByTagName(\"base\").length ? O.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\") : \"\";\n        this.createElement(\"desc\").add().element.appendChild(k.createTextNode(\"Created with Highcharts 6.1.4\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = c;\n        this.forExport = d;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(g, b, !1);\n        var l;\n        w && a.getBoundingClientRect && (g = function g() {\n          x(a, {\n            left: 0,\n            top: 0\n          });\n          l = a.getBoundingClientRect();\n          x(a, {\n            left: Math.ceil(l.left) - l.left + \"px\",\n            top: Math.ceil(l.top) - l.top + \"px\"\n          });\n        }, g(), this.unSubPixelFix = F(O, \"resize\", g));\n      },\n      getStyle: function getStyle(a) {\n        return this.style = l({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, a);\n      },\n      setStyle: function setStyle(a) {\n        this.boxWrapper.css(this.getStyle(a));\n      },\n      isHidden: function isHidden() {\n        return !this.boxWrapper.getBBox().width;\n      },\n      destroy: function destroy() {\n        var a = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        c(this.gradients || {});\n        this.gradients = null;\n        a && (this.defs = a.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      },\n      createElement: function createElement(a) {\n        var g = new this.Element();\n        g.init(this, a);\n        return g;\n      },\n      draw: A,\n      getRadialAttr: function getRadialAttr(a, g) {\n        return {\n          cx: a[0] - a[2] / 2 + g.cx * a[2],\n          cy: a[1] - a[2] / 2 + g.cy * a[2],\n          r: g.r * a[2]\n        };\n      },\n      truncate: function truncate(a, g, b, y, d, c, l) {\n        var z = this,\n            n = a.rotation,\n            f,\n            J = y ? 1 : 0,\n            A = (b || y).length,\n            v = A,\n            q = [],\n            r = function r(a) {\n          g.firstChild && g.removeChild(g.firstChild);\n          a && g.appendChild(k.createTextNode(a));\n        },\n            w = function w(c, n) {\n          n = n || c;\n          if (void 0 === q[n]) if (g.getSubStringLength) try {\n            q[n] = d + g.getSubStringLength(0, y ? n + 1 : n);\n          } catch (X) {} else r(l(b || y, c)), q[n] = d + z.getSpanWidth(a, g);\n          return q[n];\n        },\n            D,\n            N;\n\n        a.rotation = 0;\n        D = w(g.textContent.length);\n\n        if (N = d + D > c) {\n          for (; J <= A;) {\n            v = Math.ceil((J + A) / 2), y && (f = l(y, v)), D = w(v, f && f.length - 1), J === A ? J = A + 1 : D > c ? A = v - 1 : J = v;\n          }\n\n          0 === A ? r(\"\") : b && A === b.length - 1 || r(f || l(b || y, v));\n        }\n\n        y && y.splice(0, v);\n        a.actualWidth = D;\n        a.rotation = n;\n        return N;\n      },\n      escapes: {\n        \"\\x26\": \"\\x26amp;\",\n        \"\\x3c\": \"\\x26lt;\",\n        \"\\x3e\": \"\\x26gt;\",\n        \"'\": \"\\x26#39;\",\n        '\"': \"\\x26quot;\"\n      },\n      buildText: function buildText(a) {\n        var y = a.element,\n            d = this,\n            c = d.forExport,\n            l = G(a.textStr, \"\").toString(),\n            n = -1 !== l.indexOf(\"\\x3c\"),\n            z = y.childNodes,\n            f,\n            A = h(y, \"x\"),\n            v = a.styles,\n            w = a.textWidth,\n            D = v && v.lineHeight,\n            e = v && v.textOutline,\n            B = v && \"ellipsis\" === v.textOverflow,\n            Q = v && \"nowrap\" === v.whiteSpace,\n            P = v && v.fontSize,\n            u,\n            p,\n            I = z.length,\n            v = w && !a.added && this.box,\n            H = function H(a) {\n          var b;\n          b = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : P || d.style.fontSize || 12;\n          return D ? g(D) : d.fontMetrics(b, a.getAttribute(\"style\") ? a : y).h;\n        },\n            O = function O(a, g) {\n          M(d.escapes, function (b, y) {\n            g && -1 !== q(b, g) || (a = a.toString().replace(new RegExp(b, \"g\"), y));\n          });\n          return a;\n        },\n            m = function m(a, g) {\n          var b;\n          b = a.indexOf(\"\\x3c\");\n          a = a.substring(b, a.indexOf(\"\\x3e\") - b);\n          b = a.indexOf(g + \"\\x3d\");\n          if (-1 !== b && (b = b + g.length + 1, g = a.charAt(b), '\"' === g || \"'\" === g)) return a = a.substring(b + 1), a.substring(0, a.indexOf(g));\n        };\n\n        u = [l, B, Q, D, e, P, w].join();\n\n        if (u !== a.textCache) {\n          for (a.textCache = u; I--;) {\n            y.removeChild(z[I]);\n          }\n\n          n || e || B || w || -1 !== l.indexOf(\" \") ? (v && v.appendChild(y), l = n ? l.replace(/<(b|strong)>/g, '\\x3cspan style\\x3d\"font-weight:bold\"\\x3e').replace(/<(i|em)>/g, '\\x3cspan style\\x3d\"font-style:italic\"\\x3e').replace(/<a/g, \"\\x3cspan\").replace(/<\\/(b|strong|i|em|a)>/g, \"\\x3c/span\\x3e\").split(/<br.*?>/g) : [l], l = b(l, function (a) {\n            return \"\" !== a;\n          }), r(l, function (g, b) {\n            var l,\n                n = 0,\n                z = 0;\n            g = g.replace(/^\\s+|\\s+$/g, \"\").replace(/<span/g, \"|||\\x3cspan\").replace(/<\\/span>/g, \"\\x3c/span\\x3e|||\");\n            l = g.split(\"|||\");\n            r(l, function (g) {\n              if (\"\" !== g || 1 === l.length) {\n                var v = {},\n                    q = k.createElementNS(d.SVG_NS, \"tspan\"),\n                    r,\n                    D;\n                (r = m(g, \"class\")) && h(q, \"class\", r);\n                if (r = m(g, \"style\")) r = r.replace(/(;| |^)color([ :])/, \"$1fill$2\"), h(q, \"style\", r);\n                (D = m(g, \"href\")) && !c && (h(q, \"onclick\", 'location.href\\x3d\"' + D + '\"'), h(q, \"class\", \"highcharts-anchor\"), x(q, {\n                  cursor: \"pointer\"\n                }));\n                g = O(g.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, \"\") || \" \");\n\n                if (\" \" !== g) {\n                  q.appendChild(k.createTextNode(g));\n                  n ? v.dx = 0 : b && null !== A && (v.x = A);\n                  h(q, v);\n                  y.appendChild(q);\n                  !n && p && (!N && c && x(q, {\n                    display: \"block\"\n                  }), h(q, \"dy\", H(q)));\n\n                  if (w) {\n                    var e = g.replace(/([^\\^])-/g, \"$1- \").split(\" \"),\n                        v = !Q && (1 < l.length || b || 1 < e.length);\n                    D = 0;\n                    var u = H(q);\n                    if (B) f = d.truncate(a, q, g, void 0, 0, Math.max(0, w - parseInt(P || 12, 10)), function (a, g) {\n                      return a.substring(0, g) + \"\\u2026\";\n                    });else if (v) for (; e.length;) {\n                      e.length && !Q && 0 < D && (q = k.createElementNS(J, \"tspan\"), h(q, {\n                        dy: u,\n                        x: A\n                      }), r && h(q, \"style\", r), q.appendChild(k.createTextNode(e.join(\" \").replace(/- /g, \"-\"))), y.appendChild(q)), d.truncate(a, q, null, e, 0 === D ? z : 0, w, function (a, g) {\n                        return e.slice(0, g).join(\" \").replace(/- /g, \"-\");\n                      }), z = a.actualWidth, D++;\n                    }\n                  }\n\n                  n++;\n                }\n              }\n            });\n            p = p || y.childNodes.length;\n          }), B && f && a.attr(\"title\", O(a.textStr, [\"\\x26lt;\", \"\\x26gt;\"])), v && v.removeChild(y), e && a.applyTextOutline && a.applyTextOutline(e)) : y.appendChild(k.createTextNode(O(l)));\n        }\n      },\n      getContrast: function getContrast(a) {\n        a = t(a).rgba;\n        a[0] *= 1;\n        a[1] *= 1.2;\n        a[2] *= .5;\n        return 459 < a[0] + a[1] + a[2] ? \"#000000\" : \"#FFFFFF\";\n      },\n      button: function button(a, g, b, y, d, c, n, f, J) {\n        var z = this.label(a, g, b, J, null, null, null, null, \"button\"),\n            A = 0;\n        z.attr(D({\n          padding: 8,\n          r: 2\n        }, d));\n        var v, q, k, r;\n        d = D({\n          fill: \"#f7f7f7\",\n          stroke: \"#cccccc\",\n          \"stroke-width\": 1,\n          style: {\n            color: \"#333333\",\n            cursor: \"pointer\",\n            fontWeight: \"normal\"\n          }\n        }, d);\n        v = d.style;\n        delete d.style;\n        c = D(d, {\n          fill: \"#e6e6e6\"\n        }, c);\n        q = c.style;\n        delete c.style;\n        n = D(d, {\n          fill: \"#e6ebf5\",\n          style: {\n            color: \"#000000\",\n            fontWeight: \"bold\"\n          }\n        }, n);\n        k = n.style;\n        delete n.style;\n        f = D(d, {\n          style: {\n            color: \"#cccccc\"\n          }\n        }, f);\n        r = f.style;\n        delete f.style;\n        F(z.element, L ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== A && z.setState(1);\n        });\n        F(z.element, L ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== A && z.setState(A);\n        });\n\n        z.setState = function (a) {\n          1 !== a && (z.state = A = a);\n          z.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][a || 0]);\n          z.attr([d, c, n, f][a || 0]).css([v, q, k, r][a || 0]);\n        };\n\n        z.attr(d).css(l({\n          cursor: \"default\"\n        }, v));\n        return z.on(\"click\", function (a) {\n          3 !== A && y.call(z, a);\n        });\n      },\n      crispLine: function crispLine(a, g) {\n        a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - g % 2 / 2);\n        a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + g % 2 / 2);\n        return a;\n      },\n      path: function path(a) {\n        var g = {\n          fill: \"none\"\n        };\n        I(a) ? g.d = a : B(a) && l(g, a);\n        return this.createElement(\"path\").attr(g);\n      },\n      circle: function circle(a, g, b) {\n        a = B(a) ? a : {\n          x: a,\n          y: g,\n          r: b\n        };\n        g = this.createElement(\"circle\");\n\n        g.xSetter = g.ySetter = function (a, g, b) {\n          b.setAttribute(\"c\" + g, a);\n        };\n\n        return g.attr(a);\n      },\n      arc: function arc(a, g, b, y, d, c) {\n        B(a) ? (y = a, g = y.y, b = y.r, a = y.x) : y = {\n          innerR: y,\n          start: d,\n          end: c\n        };\n        a = this.symbol(\"arc\", a, g, b, b, y);\n        a.r = b;\n        return a;\n      },\n      rect: function rect(a, g, b, y, d, c) {\n        d = B(a) ? a.r : d;\n        var l = this.createElement(\"rect\");\n        a = B(a) ? a : void 0 === a ? {} : {\n          x: a,\n          y: g,\n          width: Math.max(b, 0),\n          height: Math.max(y, 0)\n        };\n        void 0 !== c && (a.strokeWidth = c, a = l.crisp(a));\n        a.fill = \"none\";\n        d && (a.r = d);\n\n        l.rSetter = function (a, g, b) {\n          h(b, {\n            rx: a,\n            ry: a\n          });\n        };\n\n        return l.attr(a);\n      },\n      setSize: function setSize(a, g, b) {\n        var y = this.alignedObjects,\n            d = y.length;\n        this.width = a;\n        this.height = g;\n\n        for (this.boxWrapper.animate({\n          width: a,\n          height: g\n        }, {\n          step: function step() {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: G(b, !0) ? void 0 : 0\n        }); d--;) {\n          y[d].align();\n        }\n      },\n      g: function g(a) {\n        var g = this.createElement(\"g\");\n        return a ? g.attr({\n          \"class\": \"highcharts-\" + a\n        }) : g;\n      },\n      image: function image(a, g, b, y, d, c) {\n        var n = {\n          preserveAspectRatio: \"none\"\n        },\n            f,\n            J = function J(a, g) {\n          a.setAttributeNS ? a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", g) : a.setAttribute(\"hc-svg-href\", g);\n        },\n            z = function z(g) {\n          J(f.element, a);\n          c.call(f, g);\n        };\n\n        1 < arguments.length && l(n, {\n          x: g,\n          y: b,\n          width: y,\n          height: d\n        });\n        f = this.createElement(\"image\").attr(n);\n        c ? (J(f.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw\\x3d\\x3d\"), n = new O.Image(), F(n, \"load\", z), n.src = a, n.complete && z({})) : J(f.element, a);\n        return f;\n      },\n      symbol: function symbol(a, g, b, y, d, c) {\n        var n = this,\n            f,\n            J = /^url\\((.*?)\\)$/,\n            z = J.test(a),\n            A = !z && (this.symbols[a] ? a : \"circle\"),\n            v = A && this.symbols[A],\n            q = u(g) && v && v.call(this.symbols, Math.round(g), Math.round(b), y, d, c),\n            D,\n            w;\n        v ? (f = this.path(q), f.attr(\"fill\", \"none\"), l(f, {\n          symbolName: A,\n          x: g,\n          y: b,\n          width: y,\n          height: d\n        }), c && l(f, c)) : z && (D = a.match(J)[1], f = this.image(D), f.imgwidth = G(P[D] && P[D].width, c && c.width), f.imgheight = G(P[D] && P[D].height, c && c.height), w = function w() {\n          f.attr({\n            width: f.width,\n            height: f.height\n          });\n        }, r([\"width\", \"height\"], function (a) {\n          f[a + \"Setter\"] = function (a, g) {\n            var b = {},\n                y = this[\"img\" + g],\n                d = \"width\" === g ? \"translateX\" : \"translateY\";\n            this[g] = a;\n            u(y) && (this.element && this.element.setAttribute(g, y), this.alignByTranslate || (b[d] = ((this[g] || 0) - y) / 2, this.attr(b)));\n          };\n        }), u(g) && f.attr({\n          x: g,\n          y: b\n        }), f.isImg = !0, u(f.imgwidth) && u(f.imgheight) ? w() : (f.attr({\n          width: 0,\n          height: 0\n        }), p(\"img\", {\n          onload: function onload() {\n            var a = e[n.chartIndex];\n            0 === this.width && (x(this, {\n              position: \"absolute\",\n              top: \"-999em\"\n            }), k.body.appendChild(this));\n            P[D] = {\n              width: this.width,\n              height: this.height\n            };\n            f.imgwidth = this.width;\n            f.imgheight = this.height;\n            f.element && w();\n            this.parentNode && this.parentNode.removeChild(this);\n            n.imgCount--;\n            if (!n.imgCount && a && a.onload) a.onload();\n          },\n          src: D\n        }), this.imgCount++));\n        return f;\n      },\n      symbols: {\n        circle: function circle(a, g, b, y) {\n          return this.arc(a + b / 2, g + y / 2, b / 2, y / 2, {\n            start: 0,\n            end: 2 * Math.PI,\n            open: !1\n          });\n        },\n        square: function square(a, g, b, y) {\n          return [\"M\", a, g, \"L\", a + b, g, a + b, g + y, a, g + y, \"Z\"];\n        },\n        triangle: function triangle(a, g, b, y) {\n          return [\"M\", a + b / 2, g, \"L\", a + b, g + y, a, g + y, \"Z\"];\n        },\n        \"triangle-down\": function triangleDown(a, g, b, y) {\n          return [\"M\", a, g, \"L\", a + b, g, a + b / 2, g + y, \"Z\"];\n        },\n        diamond: function diamond(a, g, b, y) {\n          return [\"M\", a + b / 2, g, \"L\", a + b, g + y / 2, a + b / 2, g + y, a, g + y / 2, \"Z\"];\n        },\n        arc: function arc(a, g, b, y, d) {\n          var c = d.start,\n              l = d.r || b,\n              n = d.r || y || b,\n              f = d.end - .001;\n          b = d.innerR;\n          y = G(d.open, .001 > Math.abs(d.end - d.start - 2 * Math.PI));\n          var J = Math.cos(c),\n              A = Math.sin(c),\n              v = Math.cos(f),\n              f = Math.sin(f);\n          d = .001 > d.end - c - Math.PI ? 0 : 1;\n          l = [\"M\", a + l * J, g + n * A, \"A\", l, n, 0, d, 1, a + l * v, g + n * f];\n          u(b) && l.push(y ? \"M\" : \"L\", a + b * v, g + b * f, \"A\", b, b, 0, d, 0, a + b * J, g + b * A);\n          l.push(y ? \"\" : \"Z\");\n          return l;\n        },\n        callout: function callout(a, g, b, y, d) {\n          var c = Math.min(d && d.r || 0, b, y),\n              l = c + 6,\n              n = d && d.anchorX;\n          d = d && d.anchorY;\n          var f;\n          f = [\"M\", a + c, g, \"L\", a + b - c, g, \"C\", a + b, g, a + b, g, a + b, g + c, \"L\", a + b, g + y - c, \"C\", a + b, g + y, a + b, g + y, a + b - c, g + y, \"L\", a + c, g + y, \"C\", a, g + y, a, g + y, a, g + y - c, \"L\", a, g + c, \"C\", a, g, a, g, a + c, g];\n          n && n > b ? d > g + l && d < g + y - l ? f.splice(13, 3, \"L\", a + b, d - 6, a + b + 6, d, a + b, d + 6, a + b, g + y - c) : f.splice(13, 3, \"L\", a + b, y / 2, n, d, a + b, y / 2, a + b, g + y - c) : n && 0 > n ? d > g + l && d < g + y - l ? f.splice(33, 3, \"L\", a, d + 6, a - 6, d, a, d - 6, a, g + c) : f.splice(33, 3, \"L\", a, y / 2, n, d, a, y / 2, a, g + c) : d && d > y && n > a + l && n < a + b - l ? f.splice(23, 3, \"L\", n + 6, g + y, n, g + y + 6, n - 6, g + y, a + c, g + y) : d && 0 > d && n > a + l && n < a + b - l && f.splice(3, 3, \"L\", n - 6, g, n, g - 6, n + 6, g, b - c, g);\n          return f;\n        }\n      },\n      clipRect: function clipRect(g, b, y, d) {\n        var c = a.uniqueKey(),\n            n = this.createElement(\"clipPath\").attr({\n          id: c\n        }).add(this.defs);\n        g = this.rect(g, b, y, d, 0).add(n);\n        g.id = c;\n        g.clipPath = n;\n        g.count = 0;\n        return g;\n      },\n      text: function text(a, g, b, y) {\n        var d = {};\n        if (y && (this.allowHTML || !this.forExport)) return this.html(a, g, b);\n        d.x = Math.round(g || 0);\n        b && (d.y = Math.round(b));\n        if (a || 0 === a) d.text = a;\n        a = this.createElement(\"text\").attr(d);\n        y || (a.xSetter = function (a, g, b) {\n          var y = b.getElementsByTagName(\"tspan\"),\n              d,\n              c = b.getAttribute(g),\n              n;\n\n          for (n = 0; n < y.length; n++) {\n            d = y[n], d.getAttribute(g) === c && d.setAttribute(g, a);\n          }\n\n          b.setAttribute(g, a);\n        });\n        return a;\n      },\n      fontMetrics: function fontMetrics(a, b) {\n        a = a || b && b.style && b.style.fontSize || this.style && this.style.fontSize;\n        a = /px/.test(a) ? g(a) : /em/.test(a) ? parseFloat(a) * (b ? this.fontMetrics(null, b.parentNode).f : 16) : 12;\n        b = 24 > a ? a + 3 : Math.round(1.2 * a);\n        return {\n          h: b,\n          b: Math.round(.8 * b),\n          f: a\n        };\n      },\n      rotCorr: function rotCorr(a, g, b) {\n        var y = a;\n        g && b && (y = Math.max(y * Math.cos(g * f), 4));\n        return {\n          x: -a / 3 * Math.sin(g * f),\n          y: y\n        };\n      },\n      label: function label(g, b, d, c, n, f, J, A, v) {\n        var q = this,\n            k = q.g(\"button\" !== v && \"label\"),\n            w = k.text = q.text(\"\", 0, 0, J).attr({\n          zIndex: 1\n        }),\n            z,\n            N,\n            e = 0,\n            B = 3,\n            Q = 0,\n            h,\n            P,\n            p,\n            G,\n            I,\n            H = {},\n            O,\n            M,\n            x = /^url\\((.*?)\\)$/.test(c),\n            m = x,\n            t,\n            L,\n            R,\n            U;\n        v && k.addClass(\"highcharts-\" + v);\n        m = x;\n\n        t = function t() {\n          return (O || 0) % 2 / 2;\n        };\n\n        L = function L() {\n          var a = w.element.style,\n              g = {};\n          N = (void 0 === h || void 0 === P || I) && u(w.textStr) && w.getBBox();\n          k.width = (h || N.width || 0) + 2 * B + Q;\n          k.height = (P || N.height || 0) + 2 * B;\n          M = B + q.fontMetrics(a && a.fontSize, w).b;\n          m && (z || (k.box = z = q.symbols[c] || x ? q.symbol(c) : q.rect(), z.addClass((\"button\" === v ? \"\" : \"highcharts-label-box\") + (v ? \" highcharts-\" + v + \"-box\" : \"\")), z.add(k), a = t(), g.x = a, g.y = (A ? -M : 0) + a), g.width = Math.round(k.width), g.height = Math.round(k.height), z.attr(l(g, H)), H = {});\n        };\n\n        R = function R() {\n          var a = Q + B,\n              g;\n          g = A ? 0 : M;\n          u(h) && N && (\"center\" === I || \"right\" === I) && (a += {\n            center: .5,\n            right: 1\n          }[I] * (h - N.width));\n          if (a !== w.x || g !== w.y) w.attr(\"x\", a), w.hasBoxWidthChanged && (N = w.getBBox(!0), L()), void 0 !== g && w.attr(\"y\", g);\n          w.x = a;\n          w.y = g;\n        };\n\n        U = function U(a, g) {\n          z ? z.attr(a, g) : H[a] = g;\n        };\n\n        k.onAdd = function () {\n          w.add(k);\n          k.attr({\n            text: g || 0 === g ? g : \"\",\n            x: b,\n            y: d\n          });\n          z && u(n) && k.attr({\n            anchorX: n,\n            anchorY: f\n          });\n        };\n\n        k.widthSetter = function (g) {\n          h = a.isNumber(g) ? g : null;\n        };\n\n        k.heightSetter = function (a) {\n          P = a;\n        };\n\n        k[\"text-alignSetter\"] = function (a) {\n          I = a;\n        };\n\n        k.paddingSetter = function (a) {\n          u(a) && a !== B && (B = k.padding = a, R());\n        };\n\n        k.paddingLeftSetter = function (a) {\n          u(a) && a !== Q && (Q = a, R());\n        };\n\n        k.alignSetter = function (a) {\n          a = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[a];\n          a !== e && (e = a, N && k.attr({\n            x: p\n          }));\n        };\n\n        k.textSetter = function (a) {\n          void 0 !== a && w.textSetter(a);\n          L();\n          R();\n        };\n\n        k[\"stroke-widthSetter\"] = function (a, g) {\n          a && (m = !0);\n          O = this[\"stroke-width\"] = a;\n          U(g, a);\n        };\n\n        k.strokeSetter = k.fillSetter = k.rSetter = function (a, g) {\n          \"r\" !== g && (\"fill\" === g && a && (m = !0), k[g] = a);\n          U(g, a);\n        };\n\n        k.anchorXSetter = function (a, g) {\n          n = k.anchorX = a;\n          U(g, Math.round(a) - t() - p);\n        };\n\n        k.anchorYSetter = function (a, g) {\n          f = k.anchorY = a;\n          U(g, a - G);\n        };\n\n        k.xSetter = function (a) {\n          k.x = a;\n          e && (a -= e * ((h || N.width) + 2 * B), k[\"forceAnimate:x\"] = !0);\n          p = Math.round(a);\n          k.attr(\"translateX\", p);\n        };\n\n        k.ySetter = function (a) {\n          G = k.y = Math.round(a);\n          k.attr(\"translateY\", G);\n        };\n\n        var S = k.css;\n        return l(k, {\n          css: function css(a) {\n            if (a) {\n              var g = {};\n              a = D(a);\n              r(k.textProps, function (b) {\n                void 0 !== a[b] && (g[b] = a[b], delete a[b]);\n              });\n              w.css(g);\n              \"width\" in g && L();\n            }\n\n            return S.call(k, a);\n          },\n          getBBox: function getBBox() {\n            return {\n              width: N.width + 2 * B,\n              height: N.height + 2 * B,\n              x: N.x - B,\n              y: N.y - B\n            };\n          },\n          shadow: function shadow(a) {\n            a && (L(), z && z.shadow(a));\n            return k;\n          },\n          destroy: function destroy() {\n            y(k.element, \"mouseenter\");\n            y(k.element, \"mouseleave\");\n            w && (w = w.destroy());\n            z && (z = z.destroy());\n            C.prototype.destroy.call(k);\n            k = q = L = R = U = null;\n          }\n        });\n      }\n    });\n    a.Renderer = E;\n  })(K);\n\n  (function (a) {\n    var C = a.attr,\n        E = a.createElement,\n        F = a.css,\n        m = a.defined,\n        h = a.each,\n        e = a.extend,\n        t = a.isFirefox,\n        x = a.isMS,\n        p = a.isWebKit,\n        u = a.pick,\n        f = a.pInt,\n        c = a.SVGRenderer,\n        k = a.win,\n        r = a.wrap;\n    e(a.SVGElement.prototype, {\n      htmlCss: function htmlCss(a) {\n        var d = \"SPAN\" === this.element.tagName && a && \"width\" in a,\n            b = u(d && a.width, void 0);\n        d && (delete a.width, this.textWidth = b, this.htmlUpdateTransform());\n        a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");\n        this.styles = e(this.styles, a);\n        F(this.element, a);\n        return this;\n      },\n      htmlGetBBox: function htmlGetBBox() {\n        var a = this.element;\n        return {\n          x: a.offsetLeft,\n          y: a.offsetTop,\n          width: a.offsetWidth,\n          height: a.offsetHeight\n        };\n      },\n      htmlUpdateTransform: function htmlUpdateTransform() {\n        if (this.added) {\n          var a = this.renderer,\n              d = this.element,\n              b = this.translateX || 0,\n              c = this.translateY || 0,\n              k = this.x || 0,\n              r = this.y || 0,\n              w = this.textAlign || \"left\",\n              e = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[w],\n              B = this.styles,\n              u = B && B.whiteSpace;\n          F(d, {\n            marginLeft: b,\n            marginTop: c\n          });\n          this.shadows && h(this.shadows, function (a) {\n            F(a, {\n              marginLeft: b + 1,\n              marginTop: c + 1\n            });\n          });\n          this.inverted && h(d.childNodes, function (b) {\n            a.invertChild(b, d);\n          });\n\n          if (\"SPAN\" === d.tagName) {\n            var B = this.rotation,\n                n = this.textWidth && f(this.textWidth),\n                D = [B, w, d.innerHTML, this.textWidth, this.textAlign].join(),\n                A;\n            (A = n !== this.oldTextWidth) && !(A = n > this.oldTextWidth) && ((A = this.textPxLength) || (F(d, {\n              width: \"\",\n              whiteSpace: u || \"nowrap\"\n            }), A = d.offsetWidth), A = A > n);\n            A && /[ \\-]/.test(d.textContent || d.innerText) ? (F(d, {\n              width: n + \"px\",\n              display: \"block\",\n              whiteSpace: u || \"normal\"\n            }), this.oldTextWidth = n, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;\n            D !== this.cTT && (u = a.fontMetrics(d.style.fontSize).b, !m(B) || B === (this.oldRotation || 0) && w === this.oldAlign || this.setSpanRotation(B, e, u), this.getSpanCorrection(!m(B) && this.textPxLength || d.offsetWidth, u, e, B, w));\n            F(d, {\n              left: k + (this.xCorr || 0) + \"px\",\n              top: r + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = D;\n            this.oldRotation = B;\n            this.oldAlign = w;\n          }\n        } else this.alignOnAdd = !0;\n      },\n      setSpanRotation: function setSpanRotation(a, d, b) {\n        var c = {},\n            l = this.renderer.getTransformKey();\n        c[l] = c.transform = \"rotate(\" + a + \"deg)\";\n        c[l + (t ? \"Origin\" : \"-origin\")] = c.transformOrigin = 100 * d + \"% \" + b + \"px\";\n        F(this.element, c);\n      },\n      getSpanCorrection: function getSpanCorrection(a, d, b) {\n        this.xCorr = -a * b;\n        this.yCorr = -d;\n      }\n    });\n    e(c.prototype, {\n      getTransformKey: function getTransformKey() {\n        return x && !/Edge/.test(k.navigator.userAgent) ? \"-ms-transform\" : p ? \"-webkit-transform\" : t ? \"MozTransform\" : k.opera ? \"-o-transform\" : \"\";\n      },\n      html: function html(a, d, b) {\n        var c = this.createElement(\"span\"),\n            l = c.element,\n            f = c.renderer,\n            k = f.isSVG,\n            p = function p(a, b) {\n          h([\"opacity\", \"visibility\"], function (d) {\n            r(a, d + \"Setter\", function (a, d, c, n) {\n              a.call(this, d, c, n);\n              b[c] = d;\n            });\n          });\n          a.addedSetters = !0;\n        };\n\n        c.textSetter = function (a) {\n          a !== l.innerHTML && delete this.bBox;\n          this.textStr = a;\n          l.innerHTML = u(a, \"\");\n          c.doTransform = !0;\n        };\n\n        k && p(c, c.element.style);\n\n        c.xSetter = c.ySetter = c.alignSetter = c.rotationSetter = function (a, b) {\n          \"align\" === b && (b = \"textAlign\");\n          c[b] = a;\n          c.doTransform = !0;\n        };\n\n        c.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        c.attr({\n          text: a,\n          x: Math.round(d),\n          y: Math.round(b)\n        }).css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize,\n          position: \"absolute\"\n        });\n        l.style.whiteSpace = \"nowrap\";\n        c.css = c.htmlCss;\n        k && (c.add = function (a) {\n          var b,\n              d = f.box.parentNode,\n              k = [];\n\n          if (this.parentGroup = a) {\n            if (b = a.div, !b) {\n              for (; a;) {\n                k.push(a), a = a.parentGroup;\n              }\n\n              h(k.reverse(), function (a) {\n                function n(g, b) {\n                  a[b] = g;\n                  \"translateX\" === b ? l.left = g + \"px\" : l.top = g + \"px\";\n                  a.doTransform = !0;\n                }\n\n                var l,\n                    g = C(a.element, \"class\");\n                g && (g = {\n                  className: g\n                });\n                b = a.div = a.div || E(\"div\", g, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  pointerEvents: a.styles && a.styles.pointerEvents\n                }, b || d);\n                l = b.style;\n                e(a, {\n                  classSetter: function (a) {\n                    return function (g) {\n                      this.element.setAttribute(\"class\", g);\n                      a.className = g;\n                    };\n                  }(b),\n                  on: function on() {\n                    k[0].div && c.on.apply({\n                      element: k[0].div\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: n,\n                  translateYSetter: n\n                });\n                a.addedSetters || p(a, l);\n              });\n            }\n          } else b = d;\n\n          b.appendChild(l);\n          c.added = !0;\n          c.alignOnAdd && c.htmlUpdateTransform();\n          return c;\n        });\n        return c;\n      }\n    });\n  })(K);\n\n  (function (a) {\n    var C = a.defined,\n        E = a.each,\n        F = a.extend,\n        m = a.merge,\n        h = a.pick,\n        e = a.timeUnits,\n        t = a.win;\n\n    a.Time = function (a) {\n      this.update(a, !1);\n    };\n\n    a.Time.prototype = {\n      defaultOptions: {},\n      update: function update(a) {\n        var e = h(a && a.useUTC, !0),\n            u = this;\n        this.options = a = m(!0, this.options || {}, a);\n        this.Date = a.Date || t.Date;\n        this.timezoneOffset = (this.useUTC = e) && a.timezoneOffset;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        (this.variableTimezone = !(e && !a.getTimezoneOffset && !a.timezone)) || this.timezoneOffset ? (this.get = function (a, c) {\n          var f = c.getTime(),\n              r = f - u.getTimezoneOffset(c);\n          c.setTime(r);\n          a = c[\"getUTC\" + a]();\n          c.setTime(f);\n          return a;\n        }, this.set = function (a, c, k) {\n          var f;\n          if (\"Milliseconds\" === a || \"Seconds\" === a || \"Minutes\" === a && 0 === c.getTimezoneOffset() % 60) c[\"set\" + a](k);else f = u.getTimezoneOffset(c), f = c.getTime() - f, c.setTime(f), c[\"setUTC\" + a](k), a = u.getTimezoneOffset(c), f = c.getTime() + a, c.setTime(f);\n        }) : e ? (this.get = function (a, c) {\n          return c[\"getUTC\" + a]();\n        }, this.set = function (a, c, k) {\n          return c[\"setUTC\" + a](k);\n        }) : (this.get = function (a, c) {\n          return c[\"get\" + a]();\n        }, this.set = function (a, c, k) {\n          return c[\"set\" + a](k);\n        });\n      },\n      makeTime: function makeTime(e, p, u, f, c, k) {\n        var r, l, d;\n        this.useUTC ? (r = this.Date.UTC.apply(0, arguments), l = this.getTimezoneOffset(r), r += l, d = this.getTimezoneOffset(r), l !== d ? r += d - l : l - 36E5 !== this.getTimezoneOffset(r - 36E5) || a.isSafari || (r -= 36E5)) : r = new this.Date(e, p, h(u, 1), h(f, 0), h(c, 0), h(k, 0)).getTime();\n        return r;\n      },\n      timezoneOffsetFunction: function timezoneOffsetFunction() {\n        var e = this,\n            h = this.options,\n            u = t.moment;\n        if (!this.useUTC) return function (a) {\n          return 6E4 * new Date(a).getTimezoneOffset();\n        };\n\n        if (h.timezone) {\n          if (u) return function (a) {\n            return 6E4 * -u.tz(a, h.timezone).utcOffset();\n          };\n          a.error(25);\n        }\n\n        return this.useUTC && h.getTimezoneOffset ? function (a) {\n          return 6E4 * h.getTimezoneOffset(a);\n        } : function () {\n          return 6E4 * (e.timezoneOffset || 0);\n        };\n      },\n      dateFormat: function dateFormat(e, h, u) {\n        if (!a.defined(h) || isNaN(h)) return a.defaultOptions.lang.invalidDate || \"\";\n        e = a.pick(e, \"%Y-%m-%d %H:%M:%S\");\n        var f = this,\n            c = new this.Date(h),\n            k = this.get(\"Hours\", c),\n            r = this.get(\"Day\", c),\n            l = this.get(\"Date\", c),\n            d = this.get(\"Month\", c),\n            b = this.get(\"FullYear\", c),\n            v = a.defaultOptions.lang,\n            q = v.weekdays,\n            I = v.shortWeekdays,\n            w = a.pad,\n            c = a.extend({\n          a: I ? I[r] : q[r].substr(0, 3),\n          A: q[r],\n          d: w(l),\n          e: w(l, 2, \" \"),\n          w: r,\n          b: v.shortMonths[d],\n          B: v.months[d],\n          m: w(d + 1),\n          o: d + 1,\n          y: b.toString().substr(2, 2),\n          Y: b,\n          H: w(k),\n          k: k,\n          I: w(k % 12 || 12),\n          l: k % 12 || 12,\n          M: w(f.get(\"Minutes\", c)),\n          p: 12 > k ? \"AM\" : \"PM\",\n          P: 12 > k ? \"am\" : \"pm\",\n          S: w(c.getSeconds()),\n          L: w(Math.floor(h % 1E3), 3)\n        }, a.dateFormats);\n        a.objectEach(c, function (a, b) {\n          for (; -1 !== e.indexOf(\"%\" + b);) {\n            e = e.replace(\"%\" + b, \"function\" === typeof a ? a.call(f, h) : a);\n          }\n        });\n        return u ? e.substr(0, 1).toUpperCase() + e.substr(1) : e;\n      },\n      getTimeTicks: function getTimeTicks(a, p, u, f) {\n        var c = this,\n            k = [],\n            r,\n            l = {},\n            d;\n        r = new c.Date(p);\n        var b = a.unitRange,\n            v = a.count || 1,\n            q;\n        f = h(f, 1);\n\n        if (C(p)) {\n          c.set(\"Milliseconds\", r, b >= e.second ? 0 : v * Math.floor(c.get(\"Milliseconds\", r) / v));\n          b >= e.second && c.set(\"Seconds\", r, b >= e.minute ? 0 : v * Math.floor(c.get(\"Seconds\", r) / v));\n          b >= e.minute && c.set(\"Minutes\", r, b >= e.hour ? 0 : v * Math.floor(c.get(\"Minutes\", r) / v));\n          b >= e.hour && c.set(\"Hours\", r, b >= e.day ? 0 : v * Math.floor(c.get(\"Hours\", r) / v));\n          b >= e.day && c.set(\"Date\", r, b >= e.month ? 1 : v * Math.floor(c.get(\"Date\", r) / v));\n          b >= e.month && (c.set(\"Month\", r, b >= e.year ? 0 : v * Math.floor(c.get(\"Month\", r) / v)), d = c.get(\"FullYear\", r));\n          b >= e.year && c.set(\"FullYear\", r, d - d % v);\n          b === e.week && (d = c.get(\"Day\", r), c.set(\"Date\", r, c.get(\"Date\", r) - d + f + (d < f ? -7 : 0)));\n          d = c.get(\"FullYear\", r);\n          f = c.get(\"Month\", r);\n          var I = c.get(\"Date\", r),\n              w = c.get(\"Hours\", r);\n          p = r.getTime();\n          c.variableTimezone && (q = u - p > 4 * e.month || c.getTimezoneOffset(p) !== c.getTimezoneOffset(u));\n          p = r.getTime();\n\n          for (r = 1; p < u;) {\n            k.push(p), p = b === e.year ? c.makeTime(d + r * v, 0) : b === e.month ? c.makeTime(d, f + r * v) : !q || b !== e.day && b !== e.week ? q && b === e.hour && 1 < v ? c.makeTime(d, f, I, w + r * v) : p + b * v : c.makeTime(d, f, I + r * v * (b === e.day ? 1 : 7)), r++;\n          }\n\n          k.push(p);\n          b <= e.hour && 1E4 > k.length && E(k, function (a) {\n            0 === a % 18E5 && \"000000000\" === c.dateFormat(\"%H%M%S%L\", a) && (l[a] = \"day\");\n          });\n        }\n\n        k.info = F(a, {\n          higherRanks: l,\n          totalRange: b * v\n        });\n        return k;\n      }\n    };\n  })(K);\n\n  (function (a) {\n    var C = a.color,\n        E = a.merge;\n    a.defaultOptions = {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: a.Time.prototype.defaultOptions,\n      chart: {\n        borderRadius: 0,\n        defaultSeriesType: \"line\",\n        ignoreHiddenSeries: !0,\n        spacing: [10, 10, 15, 10],\n        resetZoomButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        width: null,\n        height: null,\n        borderColor: \"#335cad\",\n        backgroundColor: \"#ffffff\",\n        plotBorderColor: \"#cccccc\"\n      },\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        layout: \"horizontal\",\n        labelFormatter: function labelFormatter() {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: a.svg,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        padding: 8,\n        snap: a.isTouchDevice ? 25 : 10,\n        backgroundColor: C(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        headerFormat: '\\x3cspan style\\x3d\"font-size: 10px\"\\x3e{point.key}\\x3c/span\\x3e\\x3cbr/\\x3e',\n        pointFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> {series.name}: <b>{point.y}</b><br/>\",\n        shadow: !0,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          pointerEvents: \"none\",\n          whiteSpace: \"nowrap\"\n        }\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n\n    a.setOptions = function (C) {\n      a.defaultOptions = E(!0, a.defaultOptions, C);\n      a.time.update(E(a.defaultOptions.global, a.defaultOptions.time), !1);\n      return a.defaultOptions;\n    };\n\n    a.getOptions = function () {\n      return a.defaultOptions;\n    };\n\n    a.defaultPlotOptions = a.defaultOptions.plotOptions;\n    a.time = new a.Time(E(a.defaultOptions.global, a.defaultOptions.time));\n\n    a.dateFormat = function (C, m, h) {\n      return a.time.dateFormat(C, m, h);\n    };\n  })(K);\n\n  (function (a) {\n    var C = a.correctFloat,\n        E = a.defined,\n        F = a.destroyObjectProperties,\n        m = a.fireEvent,\n        h = a.isNumber,\n        e = a.merge,\n        t = a.pick,\n        x = a.deg2rad;\n\n    a.Tick = function (a, e, f, c) {\n      this.axis = a;\n      this.pos = e;\n      this.type = f || \"\";\n      this.isNewLabel = this.isNew = !0;\n      f || c || this.addLabel();\n    };\n\n    a.Tick.prototype = {\n      addLabel: function addLabel() {\n        var a = this.axis,\n            h = a.options,\n            f = a.chart,\n            c = a.categories,\n            k = a.names,\n            r = this.pos,\n            l = h.labels,\n            d = a.tickPositions,\n            b = r === d[0],\n            v = r === d[d.length - 1],\n            k = c ? t(c[r], k[r], r) : r,\n            c = this.label,\n            d = d.info,\n            q;\n        a.isDatetimeAxis && d && (q = h.dateTimeLabelFormats[d.higherRanks[r] || d.unitName]);\n        this.isFirst = b;\n        this.isLast = v;\n        h = {\n          axis: a,\n          chart: f,\n          isFirst: b,\n          isLast: v,\n          dateTimeLabelFormat: q,\n          value: a.isLog ? C(a.lin2log(k)) : k,\n          pos: r\n        };\n        h = a.labelFormatter.call(h, h);\n        if (E(c)) c && c.textStr !== h && (!c.textWidth || l.style && l.style.width || c.styles.width || c.css({\n          width: null\n        }), c.attr({\n          text: h\n        }));else {\n          if (this.label = c = E(h) && l.enabled ? f.renderer.text(h, 0, 0, l.useHTML).css(e(l.style)).add(a.labelGroup) : null) c.textPxLength = c.getBBox().width;\n          this.rotation = 0;\n        }\n      },\n      getLabelSize: function getLabelSize() {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      },\n      handleOverflow: function handleOverflow(a) {\n        var e = this.axis,\n            f = e.options.labels,\n            c = a.x,\n            k = e.chart.chartWidth,\n            r = e.chart.spacing,\n            l = t(e.labelLeft, Math.min(e.pos, r[3])),\n            r = t(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, k - r[1])),\n            d = this.label,\n            b = this.rotation,\n            v = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[e.labelAlign || d.attr(\"align\")],\n            q = d.getBBox().width,\n            h = e.getSlotWidth(this),\n            w = h,\n            p = 1,\n            B,\n            H = {};\n        if (b || \"justify\" !== t(f.overflow, \"justify\")) 0 > b && c - v * q < l ? B = Math.round(c / Math.cos(b * x) - l) : 0 < b && c + v * q > r && (B = Math.round((k - c) / Math.cos(b * x)));else if (k = c + (1 - v) * q, c - v * q < l ? w = a.x + w * (1 - v) - l : k > r && (w = r - a.x + w * v, p = -1), w = Math.min(h, w), w < h && \"center\" === e.labelAlign && (a.x += p * (h - w - v * (h - Math.min(q, w)))), q > w || e.autoRotation && (d.styles || {}).width) B = w;\n        B && (H.width = B, (f.style || {}).textOverflow || (H.textOverflow = \"ellipsis\"), d.css(H));\n      },\n      getPosition: function getPosition(e, h, f, c) {\n        var k = this.axis,\n            r = k.chart,\n            l = c && r.oldChartHeight || r.chartHeight;\n        e = {\n          x: e ? a.correctFloat(k.translate(h + f, null, null, c) + k.transB) : k.left + k.offset + (k.opposite ? (c && r.oldChartWidth || r.chartWidth) - k.right - k.left : 0),\n          y: e ? l - k.bottom + k.offset - (k.opposite ? k.height : 0) : a.correctFloat(l - k.translate(h + f, null, null, c) - k.transB)\n        };\n        m(this, \"afterGetPosition\", {\n          pos: e\n        });\n        return e;\n      },\n      getLabelPosition: function getLabelPosition(a, e, f, c, k, r, l, d) {\n        var b = this.axis,\n            v = b.transA,\n            q = b.reversed,\n            h = b.staggerLines,\n            w = b.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            u = k.y,\n            B = c || b.reserveSpaceDefault ? 0 : -b.labelOffset * (\"center\" === b.labelAlign ? .5 : 1),\n            H = {};\n        E(u) || (u = 0 === b.side ? f.rotation ? -8 : -f.getBBox().height : 2 === b.side ? w.y + 8 : Math.cos(f.rotation * x) * (w.y - f.getBBox(!1, 0).height / 2));\n        a = a + k.x + B + w.x - (r && c ? r * v * (q ? -1 : 1) : 0);\n        e = e + u - (r && !c ? r * v * (q ? 1 : -1) : 0);\n        h && (f = l / (d || 1) % h, b.opposite && (f = h - f - 1), e += b.labelOffset / h * f);\n        H.x = a;\n        H.y = Math.round(e);\n        m(this, \"afterGetLabelPosition\", {\n          pos: H\n        });\n        return H;\n      },\n      getMarkPath: function getMarkPath(a, e, f, c, k, r) {\n        return r.crispLine([\"M\", a, e, \"L\", a + (k ? 0 : -f), e + (k ? f : 0)], c);\n      },\n      renderGridLine: function renderGridLine(a, e, f) {\n        var c = this.axis,\n            k = c.options,\n            r = this.gridLine,\n            l = {},\n            d = this.pos,\n            b = this.type,\n            v = c.tickmarkOffset,\n            q = c.chart.renderer,\n            h = b ? b + \"Grid\" : \"grid\",\n            w = k[h + \"LineWidth\"],\n            u = k[h + \"LineColor\"],\n            k = k[h + \"LineDashStyle\"];\n        r || (l.stroke = u, l[\"stroke-width\"] = w, k && (l.dashstyle = k), b || (l.zIndex = 1), a && (l.opacity = 0), this.gridLine = r = q.path().attr(l).addClass(\"highcharts-\" + (b ? b + \"-\" : \"\") + \"grid-line\").add(c.gridGroup));\n        if (!a && r && (a = c.getPlotLinePath(d + v, r.strokeWidth() * f, a, !0))) r[this.isNew ? \"attr\" : \"animate\"]({\n          d: a,\n          opacity: e\n        });\n      },\n      renderMark: function renderMark(a, e, f) {\n        var c = this.axis,\n            k = c.options,\n            r = c.chart.renderer,\n            l = this.type,\n            d = l ? l + \"Tick\" : \"tick\",\n            b = c.tickSize(d),\n            v = this.mark,\n            q = !v,\n            h = a.x;\n        a = a.y;\n        var w = t(k[d + \"Width\"], !l && c.isXAxis ? 1 : 0),\n            k = k[d + \"Color\"];\n        b && (c.opposite && (b[0] = -b[0]), q && (this.mark = v = r.path().addClass(\"highcharts-\" + (l ? l + \"-\" : \"\") + \"tick\").add(c.axisGroup), v.attr({\n          stroke: k,\n          \"stroke-width\": w\n        })), v[q ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(h, a, b[0], v.strokeWidth() * f, c.horiz, r),\n          opacity: e\n        }));\n      },\n      renderLabel: function renderLabel(a, e, f, c) {\n        var k = this.axis,\n            r = k.horiz,\n            l = k.options,\n            d = this.label,\n            b = l.labels,\n            v = b.step,\n            k = k.tickmarkOffset,\n            q = !0,\n            I = a.x;\n        a = a.y;\n        d && h(I) && (d.xy = a = this.getLabelPosition(I, a, d, r, b, k, c, v), this.isFirst && !this.isLast && !t(l.showFirstLabel, 1) || this.isLast && !this.isFirst && !t(l.showLastLabel, 1) ? q = !1 : !r || b.step || b.rotation || e || 0 === f || this.handleOverflow(a), v && c % v && (q = !1), q && h(a.y) ? (a.opacity = f, d[this.isNewLabel ? \"attr\" : \"animate\"](a), this.isNewLabel = !1) : (d.attr(\"y\", -9999), this.isNewLabel = !0));\n      },\n      render: function render(e, h, f) {\n        var c = this.axis,\n            k = c.horiz,\n            r = this.getPosition(k, this.pos, c.tickmarkOffset, h),\n            l = r.x,\n            d = r.y,\n            c = k && l === c.pos + c.len || !k && d === c.pos ? -1 : 1;\n        f = t(f, 1);\n        this.isActive = !0;\n        this.renderGridLine(h, f, c);\n        this.renderMark(r, f, c);\n        this.renderLabel(r, h, f, e);\n        this.isNew = !1;\n        a.fireEvent(this, \"afterRender\");\n      },\n      destroy: function destroy() {\n        F(this, this.axis);\n      }\n    };\n  })(K);\n\n  var V = function (a) {\n    var C = a.addEvent,\n        E = a.animObject,\n        F = a.arrayMax,\n        m = a.arrayMin,\n        h = a.color,\n        e = a.correctFloat,\n        t = a.defaultOptions,\n        x = a.defined,\n        p = a.deg2rad,\n        u = a.destroyObjectProperties,\n        f = a.each,\n        c = a.extend,\n        k = a.fireEvent,\n        r = a.format,\n        l = a.getMagnitude,\n        d = a.grep,\n        b = a.inArray,\n        v = a.isArray,\n        q = a.isNumber,\n        I = a.isString,\n        w = a.merge,\n        L = a.normalizeTickInterval,\n        B = a.objectEach,\n        H = a.pick,\n        n = a.removeEvent,\n        D = a.splat,\n        A = a.syncTimeout,\n        M = a.Tick,\n        G = function G() {\n      this.init.apply(this, arguments);\n    };\n\n    a.extend(G.prototype, {\n      defaultOptions: {\n        dateTimeLabelFormats: {\n          millisecond: \"%H:%M:%S.%L\",\n          second: \"%H:%M:%S\",\n          minute: \"%H:%M\",\n          hour: \"%H:%M\",\n          day: \"%e. %b\",\n          week: \"%e. %b\",\n          month: \"%b '%y\",\n          year: \"%Y\"\n        },\n        endOnTick: !1,\n        labels: {\n          enabled: !0,\n          x: 0,\n          style: {\n            color: \"#666666\",\n            cursor: \"default\",\n            fontSize: \"11px\"\n          }\n        },\n        maxPadding: .01,\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minPadding: .01,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          style: {\n            color: \"#666666\"\n          }\n        },\n        type: \"linear\",\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#ccd6eb\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        tickColor: \"#ccd6eb\"\n      },\n      defaultYAxisOptions: {\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: -8\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          allowOverlap: !1,\n          enabled: !1,\n          formatter: function formatter() {\n            return a.numberFormat(this.total, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"11px\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      },\n      defaultLeftAxisOptions: {\n        labels: {\n          x: -15\n        },\n        title: {\n          rotation: 270\n        }\n      },\n      defaultRightAxisOptions: {\n        labels: {\n          x: 15\n        },\n        title: {\n          rotation: 90\n        }\n      },\n      defaultBottomAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        title: {\n          rotation: 0\n        }\n      },\n      defaultTopAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        title: {\n          rotation: 0\n        }\n      },\n      init: function init(a, y) {\n        var g = y.isX,\n            d = this;\n        d.chart = a;\n        d.horiz = a.inverted && !d.isZAxis ? !g : g;\n        d.isXAxis = g;\n        d.coll = d.coll || (g ? \"xAxis\" : \"yAxis\");\n        k(this, \"init\", {\n          userOptions: y\n        });\n        d.opposite = y.opposite;\n        d.side = y.side || (d.horiz ? d.opposite ? 0 : 2 : d.opposite ? 1 : 3);\n        d.setOptions(y);\n        var c = this.options,\n            n = c.type;\n        d.labelFormatter = c.labels.formatter || d.defaultLabelFormatter;\n        d.userOptions = y;\n        d.minPixelPadding = 0;\n        d.reversed = c.reversed;\n        d.visible = !1 !== c.visible;\n        d.zoomEnabled = !1 !== c.zoomEnabled;\n        d.hasNames = \"category\" === n || !0 === c.categories;\n        d.categories = c.categories || d.hasNames;\n        d.names || (d.names = [], d.names.keys = {});\n        d.plotLinesAndBandsGroups = {};\n        d.isLog = \"logarithmic\" === n;\n        d.isDatetimeAxis = \"datetime\" === n;\n        d.positiveValuesOnly = d.isLog && !d.allowNegativeLog;\n        d.isLinked = x(c.linkedTo);\n        d.ticks = {};\n        d.labelEdge = [];\n        d.minorTicks = {};\n        d.plotLinesAndBands = [];\n        d.alternateBands = {};\n        d.len = 0;\n        d.minRange = d.userMinRange = c.minRange || c.maxZoom;\n        d.range = c.range;\n        d.offset = c.offset || 0;\n        d.stacks = {};\n        d.oldStacks = {};\n        d.stacksTouched = 0;\n        d.max = null;\n        d.min = null;\n        d.crosshair = H(c.crosshair, D(a.options.tooltip.crosshairs)[g ? 0 : 1], !1);\n        y = d.options.events;\n        -1 === b(d, a.axes) && (g ? a.axes.splice(a.xAxis.length, 0, d) : a.axes.push(d), a[d.coll].push(d));\n        d.series = d.series || [];\n        a.inverted && !d.isZAxis && g && void 0 === d.reversed && (d.reversed = !0);\n        B(y, function (a, g) {\n          C(d, g, a);\n        });\n        d.lin2log = c.linearToLogConverter || d.lin2log;\n        d.isLog && (d.val2lin = d.log2lin, d.lin2val = d.lin2log);\n        k(this, \"afterInit\");\n      },\n      setOptions: function setOptions(a) {\n        this.options = w(this.defaultOptions, \"yAxis\" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], w(t[this.coll], a));\n        k(this, \"afterSetOptions\", {\n          userOptions: a\n        });\n      },\n      defaultLabelFormatter: function defaultLabelFormatter() {\n        var g = this.axis,\n            b = this.value,\n            d = g.chart.time,\n            c = g.categories,\n            n = this.dateTimeLabelFormat,\n            l = t.lang,\n            f = l.numericSymbols,\n            l = l.numericSymbolMagnitude || 1E3,\n            k = f && f.length,\n            A,\n            q = g.options.labels.format,\n            g = g.isLog ? Math.abs(b) : g.tickInterval;\n        if (q) A = r(q, this, d);else if (c) A = b;else if (n) A = d.dateFormat(n, b);else if (k && 1E3 <= g) for (; k-- && void 0 === A;) {\n          d = Math.pow(l, k + 1), g >= d && 0 === 10 * b % d && null !== f[k] && 0 !== b && (A = a.numberFormat(b / d, -1) + f[k]);\n        }\n        void 0 === A && (A = 1E4 <= Math.abs(b) ? a.numberFormat(b, -1) : a.numberFormat(b, -1, void 0, \"\"));\n        return A;\n      },\n      getSeriesExtremes: function getSeriesExtremes() {\n        var a = this,\n            b = a.chart;\n        k(this, \"getSeriesExtremes\", null, function () {\n          a.hasVisibleSeries = !1;\n          a.dataMin = a.dataMax = a.threshold = null;\n          a.softThreshold = !a.isXAxis;\n          a.buildStacks && a.buildStacks();\n          f(a.series, function (g) {\n            if (g.visible || !b.options.chart.ignoreHiddenSeries) {\n              var y = g.options,\n                  c = y.threshold,\n                  n;\n              a.hasVisibleSeries = !0;\n              a.positiveValuesOnly && 0 >= c && (c = null);\n              if (a.isXAxis) y = g.xData, y.length && (g = m(y), n = F(y), q(g) || g instanceof Date || (y = d(y, q), g = m(y), n = F(y)), y.length && (a.dataMin = Math.min(H(a.dataMin, y[0], g), g), a.dataMax = Math.max(H(a.dataMax, y[0], n), n)));else if (g.getExtremes(), n = g.dataMax, g = g.dataMin, x(g) && x(n) && (a.dataMin = Math.min(H(a.dataMin, g), g), a.dataMax = Math.max(H(a.dataMax, n), n)), x(c) && (a.threshold = c), !y.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;\n            }\n          });\n        });\n        k(this, \"afterGetSeriesExtremes\");\n      },\n      translate: function translate(a, b, d, c, n, l) {\n        var g = this.linkedParent || this,\n            y = 1,\n            f = 0,\n            k = c ? g.oldTransA : g.transA;\n        c = c ? g.oldMin : g.min;\n        var J = g.minPixelPadding;\n        n = (g.isOrdinal || g.isBroken || g.isLog && n) && g.lin2val;\n        k || (k = g.transA);\n        d && (y *= -1, f = g.len);\n        g.reversed && (y *= -1, f -= y * (g.sector || g.len));\n        b ? (a = (a * y + f - J) / k + c, n && (a = g.lin2val(a))) : (n && (a = g.val2lin(a)), a = q(c) ? y * (a - c) * k + f + y * J + (q(l) ? k * l : 0) : void 0);\n        return a;\n      },\n      toPixels: function toPixels(a, b) {\n        return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);\n      },\n      toValue: function toValue(a, b) {\n        return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);\n      },\n      getPlotLinePath: function getPlotLinePath(a, b, d, c, n) {\n        var g = this.chart,\n            y = this.left,\n            l = this.top,\n            f,\n            k,\n            J = d && g.oldChartHeight || g.chartHeight,\n            A = d && g.oldChartWidth || g.chartWidth,\n            v;\n        f = this.transB;\n\n        var e = function e(a, g, b) {\n          if (a < g || a > b) c ? a = Math.min(Math.max(g, a), b) : v = !0;\n          return a;\n        };\n\n        n = H(n, this.translate(a, null, null, d));\n        n = Math.min(Math.max(-1E5, n), 1E5);\n        a = d = Math.round(n + f);\n        f = k = Math.round(J - n - f);\n        q(n) ? this.horiz ? (f = l, k = J - this.bottom, a = d = e(a, y, y + this.width)) : (a = y, d = A - this.right, f = k = e(f, l, l + this.height)) : (v = !0, c = !1);\n        return v && !c ? null : g.renderer.crispLine([\"M\", a, f, \"L\", d, k], b || 1);\n      },\n      getLinearTickPositions: function getLinearTickPositions(a, b, d) {\n        var g,\n            c = e(Math.floor(b / a) * a);\n        d = e(Math.ceil(d / a) * a);\n        var y = [],\n            n;\n        e(c + a) === c && (n = 20);\n        if (this.single) return [b];\n\n        for (b = c; b <= d;) {\n          y.push(b);\n          b = e(b + a, n);\n          if (b === g) break;\n          g = b;\n        }\n\n        return y;\n      },\n      getMinorTickInterval: function getMinorTickInterval() {\n        var a = this.options;\n        return !0 === a.minorTicks ? H(a.minorTickInterval, \"auto\") : !1 === a.minorTicks ? null : a.minorTickInterval;\n      },\n      getMinorTickPositions: function getMinorTickPositions() {\n        var a = this,\n            b = a.options,\n            d = a.tickPositions,\n            c = a.minorTickInterval,\n            n = [],\n            l = a.pointRangePadding || 0,\n            k = a.min - l,\n            l = a.max + l,\n            A = l - k;\n        if (A && A / c < a.len / 3) if (a.isLog) f(this.paddedTicks, function (g, b, d) {\n          b && n.push.apply(n, a.getLogTickPositions(c, d[b - 1], d[b], !0));\n        });else if (a.isDatetimeAxis && \"auto\" === this.getMinorTickInterval()) n = n.concat(a.getTimeTicks(a.normalizeTimeTickInterval(c), k, l, b.startOfWeek));else for (b = k + (d[0] - k) % c; b <= l && b !== n[0]; b += c) {\n          n.push(b);\n        }\n        0 !== n.length && a.trimTicks(n);\n        return n;\n      },\n      adjustForMinRange: function adjustForMinRange() {\n        var a = this.options,\n            b = this.min,\n            d = this.max,\n            c,\n            n,\n            l,\n            k,\n            A,\n            q,\n            v,\n            e;\n        this.isXAxis && void 0 === this.minRange && !this.isLog && (x(a.min) || x(a.max) ? this.minRange = null : (f(this.series, function (a) {\n          q = a.xData;\n\n          for (k = v = a.xIncrement ? 1 : q.length - 1; 0 < k; k--) {\n            if (A = q[k] - q[k - 1], void 0 === l || A < l) l = A;\n          }\n        }), this.minRange = Math.min(5 * l, this.dataMax - this.dataMin)));\n        d - b < this.minRange && (n = this.dataMax - this.dataMin >= this.minRange, e = this.minRange, c = (e - d + b) / 2, c = [b - c, H(a.min, b - c)], n && (c[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), b = F(c), d = [b + e, H(a.max, b + e)], n && (d[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), d = m(d), d - b < e && (c[0] = d - e, c[1] = H(a.min, d - e), b = F(c)));\n        this.min = b;\n        this.max = d;\n      },\n      getClosest: function getClosest() {\n        var a;\n        this.categories ? a = 1 : f(this.series, function (g) {\n          var b = g.closestPointRange,\n              d = g.visible || !g.chart.options.chart.ignoreHiddenSeries;\n          !g.noSharedTooltip && x(b) && d && (a = x(a) ? Math.min(a, b) : b);\n        });\n        return a;\n      },\n      nameToX: function nameToX(a) {\n        var g = v(this.categories),\n            d = g ? this.categories : this.names,\n            c = a.options.x,\n            n;\n        a.series.requireSorting = !1;\n        x(c) || (c = !1 === this.options.uniqueNames ? a.series.autoIncrement() : g ? b(a.name, d) : H(d.keys[a.name], -1));\n        -1 === c ? g || (n = d.length) : n = c;\n        void 0 !== n && (this.names[n] = a.name, this.names.keys[a.name] = n);\n        return n;\n      },\n      updateNames: function updateNames() {\n        var g = this,\n            b = this.names;\n        0 < b.length && (f(a.keys(b.keys), function (a) {\n          delete b.keys[a];\n        }), b.length = 0, this.minRange = this.userMinRange, f(this.series || [], function (a) {\n          a.xIncrement = null;\n          if (!a.points || a.isDirtyData) a.processData(), a.generatePoints();\n          f(a.points, function (b, d) {\n            var c;\n            b.options && (c = g.nameToX(b), void 0 !== c && c !== b.x && (b.x = c, a.xData[d] = c));\n          });\n        }));\n      },\n      setAxisTranslation: function setAxisTranslation(a) {\n        var b = this,\n            g = b.max - b.min,\n            d = b.axisPointRange || 0,\n            c,\n            n = 0,\n            l = 0,\n            A = b.linkedParent,\n            q = !!b.categories,\n            v = b.transA,\n            e = b.isXAxis;\n        if (e || q || d) c = b.getClosest(), A ? (n = A.minPointOffset, l = A.pointRangePadding) : f(b.series, function (a) {\n          var g = q ? 1 : e ? H(a.options.pointRange, c, 0) : b.axisPointRange || 0;\n          a = a.options.pointPlacement;\n          d = Math.max(d, g);\n          b.single || (n = Math.max(n, I(a) ? 0 : g / 2), l = Math.max(l, \"on\" === a ? 0 : g));\n        }), A = b.ordinalSlope && c ? b.ordinalSlope / c : 1, b.minPointOffset = n *= A, b.pointRangePadding = l *= A, b.pointRange = Math.min(d, g), e && (b.closestPointRange = c);\n        a && (b.oldTransA = v);\n        b.translationSlope = b.transA = v = b.options.staticScale || b.len / (g + l || 1);\n        b.transB = b.horiz ? b.left : b.bottom;\n        b.minPixelPadding = v * n;\n        k(this, \"afterSetAxisTranslation\");\n      },\n      minFromRange: function minFromRange() {\n        return this.max - this.range;\n      },\n      setTickInterval: function setTickInterval(b) {\n        var g = this,\n            d = g.chart,\n            c = g.options,\n            n = g.isLog,\n            A = g.isDatetimeAxis,\n            v = g.isXAxis,\n            w = g.isLinked,\n            r = c.maxPadding,\n            D = c.minPadding,\n            h = c.tickInterval,\n            B = c.tickPixelInterval,\n            G = g.categories,\n            I = q(g.threshold) ? g.threshold : null,\n            u = g.softThreshold,\n            M,\n            m,\n            p,\n            t;\n        A || G || w || this.getTickAmount();\n        p = H(g.userMin, c.min);\n        t = H(g.userMax, c.max);\n        w ? (g.linkedParent = d[g.coll][c.linkedTo], d = g.linkedParent.getExtremes(), g.min = H(d.min, d.dataMin), g.max = H(d.max, d.dataMax), c.type !== g.linkedParent.options.type && a.error(11, 1)) : (!u && x(I) && (g.dataMin >= I ? (M = I, D = 0) : g.dataMax <= I && (m = I, r = 0)), g.min = H(p, M, g.dataMin), g.max = H(t, m, g.dataMax));\n        n && (g.positiveValuesOnly && !b && 0 >= Math.min(g.min, H(g.dataMin, g.min)) && a.error(10, 1), g.min = e(g.log2lin(g.min), 15), g.max = e(g.log2lin(g.max), 15));\n        g.range && x(g.max) && (g.userMin = g.min = p = Math.max(g.dataMin, g.minFromRange()), g.userMax = t = g.max, g.range = null);\n        k(g, \"foundExtremes\");\n        g.beforePadding && g.beforePadding();\n        g.adjustForMinRange();\n        !(G || g.axisPointRange || g.usePercentage || w) && x(g.min) && x(g.max) && (d = g.max - g.min) && (!x(p) && D && (g.min -= d * D), !x(t) && r && (g.max += d * r));\n        q(c.softMin) && !q(g.userMin) && (g.min = Math.min(g.min, c.softMin));\n        q(c.softMax) && !q(g.userMax) && (g.max = Math.max(g.max, c.softMax));\n        q(c.floor) && (g.min = Math.max(g.min, c.floor));\n        q(c.ceiling) && (g.max = Math.min(g.max, c.ceiling));\n        u && x(g.dataMin) && (I = I || 0, !x(p) && g.min < I && g.dataMin >= I ? g.min = I : !x(t) && g.max > I && g.dataMax <= I && (g.max = I));\n        g.tickInterval = g.min === g.max || void 0 === g.min || void 0 === g.max ? 1 : w && !h && B === g.linkedParent.options.tickPixelInterval ? h = g.linkedParent.tickInterval : H(h, this.tickAmount ? (g.max - g.min) / Math.max(this.tickAmount - 1, 1) : void 0, G ? 1 : (g.max - g.min) * B / Math.max(g.len, B));\n        v && !b && f(g.series, function (a) {\n          a.processData(g.min !== g.oldMin || g.max !== g.oldMax);\n        });\n        g.setAxisTranslation(!0);\n        g.beforeSetTickPositions && g.beforeSetTickPositions();\n        g.postProcessTickInterval && (g.tickInterval = g.postProcessTickInterval(g.tickInterval));\n        g.pointRange && !h && (g.tickInterval = Math.max(g.pointRange, g.tickInterval));\n        b = H(c.minTickInterval, g.isDatetimeAxis && g.closestPointRange);\n        !h && g.tickInterval < b && (g.tickInterval = b);\n        A || n || h || (g.tickInterval = L(g.tickInterval, null, l(g.tickInterval), H(c.allowDecimals, !(.5 < g.tickInterval && 5 > g.tickInterval && 1E3 < g.max && 9999 > g.max)), !!this.tickAmount));\n        this.tickAmount || (g.tickInterval = g.unsquish());\n        this.setTickPositions();\n      },\n      setTickPositions: function setTickPositions() {\n        var g = this.options,\n            b,\n            d = g.tickPositions;\n        b = this.getMinorTickInterval();\n        var c = g.tickPositioner,\n            n = g.startOnTick,\n            l = g.endOnTick;\n        this.tickmarkOffset = this.categories && \"between\" === g.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === b && this.tickInterval ? this.tickInterval / 5 : b;\n        this.single = this.min === this.max && x(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== g.allowDecimals);\n        this.tickPositions = b = d && d.slice();\n        !b && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (b = [this.min, this.max], a.error(19)) : b = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, g.units), this.min, this.max, g.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), b.length > this.len && (b = [b[0], b.pop()], b[0] === b[1] && (b.length = 1)), this.tickPositions = b, c && (c = c.apply(this, [this.min, this.max]))) && (this.tickPositions = b = c);\n        this.paddedTicks = b.slice(0);\n        this.trimTicks(b, n, l);\n        this.isLinked || (this.single && 2 > b.length && (this.min -= .5, this.max += .5), d || c || this.adjustTickAmount());\n        k(this, \"afterSetTickPositions\");\n      },\n      trimTicks: function trimTicks(a, b, d) {\n        var g = a[0],\n            c = a[a.length - 1],\n            n = this.minPointOffset || 0;\n\n        if (!this.isLinked) {\n          if (b && -Infinity !== g) this.min = g;else for (; this.min - n > a[0];) {\n            a.shift();\n          }\n          if (d) this.max = c;else for (; this.max + n < a[a.length - 1];) {\n            a.pop();\n          }\n          0 === a.length && x(g) && !this.options.tickPositions && a.push((c + g) / 2);\n        }\n      },\n      alignToOthers: function alignToOthers() {\n        var a = {},\n            b,\n            d = this.options;\n        !1 === this.chart.options.chart.alignTicks || !1 === d.alignTicks || !1 === d.startOnTick || !1 === d.endOnTick || this.isLog || f(this.chart[this.coll], function (g) {\n          var d = g.options,\n              d = [g.horiz ? d.left : d.top, d.width, d.height, d.pane].join();\n          g.series.length && (a[d] ? b = !0 : a[d] = 1);\n        });\n        return b;\n      },\n      getTickAmount: function getTickAmount() {\n        var a = this.options,\n            b = a.tickAmount,\n            d = a.tickPixelInterval;\n        !x(a.tickInterval) && this.len < d && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);\n        !b && this.alignToOthers() && (b = Math.ceil(this.len / d) + 1);\n        4 > b && (this.finalTickAmt = b, b = 5);\n        this.tickAmount = b;\n      },\n      adjustTickAmount: function adjustTickAmount() {\n        var a = this.tickInterval,\n            b = this.tickPositions,\n            d = this.tickAmount,\n            c = this.finalTickAmt,\n            n = b && b.length,\n            l = H(this.threshold, this.softThreshold ? 0 : null);\n\n        if (this.hasData()) {\n          if (n < d) {\n            for (; b.length < d;) {\n              b.length % 2 || this.min === l ? b.push(e(b[b.length - 1] + a)) : b.unshift(e(b[0] - a));\n            }\n\n            this.transA *= (n - 1) / (d - 1);\n            this.min = b[0];\n            this.max = b[b.length - 1];\n          } else n > d && (this.tickInterval *= 2, this.setTickPositions());\n\n          if (x(c)) {\n            for (a = d = b.length; a--;) {\n              (3 === c && 1 === a % 2 || 2 >= c && 0 < a && a < d - 1) && b.splice(a, 1);\n            }\n\n            this.finalTickAmt = void 0;\n          }\n        }\n      },\n      setScale: function setScale() {\n        var a, b;\n        this.oldMin = this.min;\n        this.oldMax = this.max;\n        this.oldAxisLength = this.len;\n        this.setAxisSize();\n        b = this.len !== this.oldAxisLength;\n        f(this.series, function (b) {\n          if (b.isDirtyData || b.isDirty || b.xAxis.isDirty) a = !0;\n        });\n        b || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();\n        k(this, \"afterSetScale\");\n      },\n      setExtremes: function setExtremes(a, b, d, n, l) {\n        var g = this,\n            A = g.chart;\n        d = H(d, !0);\n        f(g.series, function (a) {\n          delete a.kdTree;\n        });\n        l = c(l, {\n          min: a,\n          max: b\n        });\n        k(g, \"setExtremes\", l, function () {\n          g.userMin = a;\n          g.userMax = b;\n          g.eventArgs = l;\n          d && A.redraw(n);\n        });\n      },\n      zoom: function zoom(a, b) {\n        var g = this.dataMin,\n            d = this.dataMax,\n            c = this.options,\n            n = Math.min(g, H(c.min, g)),\n            c = Math.max(d, H(c.max, d));\n        if (a !== this.min || b !== this.max) this.allowZoomOutside || (x(g) && (a < n && (a = n), a > c && (a = c)), x(d) && (b < n && (b = n), b > c && (b = c))), this.displayBtn = void 0 !== a || void 0 !== b, this.setExtremes(a, b, !1, void 0, {\n          trigger: \"zoom\"\n        });\n        return !0;\n      },\n      setAxisSize: function setAxisSize() {\n        var b = this.chart,\n            d = this.options,\n            c = d.offsets || [0, 0, 0, 0],\n            n = this.horiz,\n            l = this.width = Math.round(a.relativeLength(H(d.width, b.plotWidth - c[3] + c[1]), b.plotWidth)),\n            f = this.height = Math.round(a.relativeLength(H(d.height, b.plotHeight - c[0] + c[2]), b.plotHeight)),\n            k = this.top = Math.round(a.relativeLength(H(d.top, b.plotTop + c[0]), b.plotHeight, b.plotTop)),\n            d = this.left = Math.round(a.relativeLength(H(d.left, b.plotLeft + c[3]), b.plotWidth, b.plotLeft));\n        this.bottom = b.chartHeight - f - k;\n        this.right = b.chartWidth - l - d;\n        this.len = Math.max(n ? l : f, 0);\n        this.pos = n ? d : k;\n      },\n      getExtremes: function getExtremes() {\n        var a = this.isLog;\n        return {\n          min: a ? e(this.lin2log(this.min)) : this.min,\n          max: a ? e(this.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      },\n      getThreshold: function getThreshold(a) {\n        var b = this.isLog,\n            g = b ? this.lin2log(this.min) : this.min,\n            b = b ? this.lin2log(this.max) : this.max;\n        null === a || -Infinity === a ? a = g : Infinity === a ? a = b : g > a ? a = g : b < a && (a = b);\n        return this.translate(a, 0, 1, 0, 1);\n      },\n      autoLabelAlign: function autoLabelAlign(a) {\n        a = (H(a, 0) - 90 * this.side + 720) % 360;\n        return 15 < a && 165 > a ? \"right\" : 195 < a && 345 > a ? \"left\" : \"center\";\n      },\n      tickSize: function tickSize(a) {\n        var b = this.options,\n            g = b[a + \"Length\"],\n            d = H(b[a + \"Width\"], \"tick\" === a && this.isXAxis ? 1 : 0);\n        if (d && g) return \"inside\" === b[a + \"Position\"] && (g = -g), [g, d];\n      },\n      labelMetrics: function labelMetrics() {\n        var a = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);\n      },\n      unsquish: function unsquish() {\n        var a = this.options.labels,\n            b = this.horiz,\n            d = this.tickInterval,\n            c = d,\n            n = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / d),\n            l,\n            k = a.rotation,\n            A = this.labelMetrics(),\n            q,\n            v = Number.MAX_VALUE,\n            w,\n            r = function r(a) {\n          a /= n || 1;\n          a = 1 < a ? Math.ceil(a) : 1;\n          return e(a * d);\n        };\n\n        b ? (w = !a.staggerLines && !a.step && (x(k) ? [k] : n < H(a.autoRotationLimit, 80) && a.autoRotation)) && f(w, function (a) {\n          var b;\n          if (a === k || a && -90 <= a && 90 >= a) q = r(Math.abs(A.h / Math.sin(p * a))), b = q + Math.abs(a / 360), b < v && (v = b, l = a, c = q);\n        }) : a.step || (c = r(A.h));\n        this.autoRotation = w;\n        this.labelRotation = H(l, k);\n        return c;\n      },\n      getSlotWidth: function getSlotWidth() {\n        var a = this.chart,\n            b = this.horiz,\n            d = this.options.labels,\n            c = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            n = a.margin[3];\n        return b && 2 > (d.step || 0) && !d.rotation && (this.staggerLines || 1) * this.len / c || !b && (d.style && parseInt(d.style.width, 10) || n && n - a.spacing[3] || .33 * a.chartWidth);\n      },\n      renderUnsquish: function renderUnsquish() {\n        var a = this.chart,\n            b = a.renderer,\n            d = this.tickPositions,\n            c = this.ticks,\n            n = this.options.labels,\n            l = n && n.style || {},\n            k = this.horiz,\n            A = this.getSlotWidth(),\n            q = Math.max(1, Math.round(A - 2 * (n.padding || 5))),\n            v = {},\n            e = this.labelMetrics(),\n            w = n.style && n.style.textOverflow,\n            r,\n            D,\n            h = 0,\n            B;\n        I(n.rotation) || (v.rotation = n.rotation || 0);\n        f(d, function (a) {\n          (a = c[a]) && a.label && a.label.textPxLength > h && (h = a.label.textPxLength);\n        });\n        this.maxLabelLength = h;\n        if (this.autoRotation) h > q && h > e.h ? v.rotation = this.labelRotation : this.labelRotation = 0;else if (A && (r = q, !w)) for (D = \"clip\", q = d.length; !k && q--;) {\n          if (B = d[q], B = c[B].label) B.styles && \"ellipsis\" === B.styles.textOverflow ? B.css({\n            textOverflow: \"clip\"\n          }) : B.textPxLength > A && B.css({\n            width: A + \"px\"\n          }), B.getBBox().height > this.len / d.length - (e.h - e.f) && (B.specificTextOverflow = \"ellipsis\");\n        }\n        v.rotation && (r = h > .5 * a.chartHeight ? .33 * a.chartHeight : h, w || (D = \"ellipsis\"));\n        if (this.labelAlign = n.align || this.autoLabelAlign(this.labelRotation)) v.align = this.labelAlign;\n        f(d, function (a) {\n          var b = (a = c[a]) && a.label,\n              g = l.width,\n              d = {};\n          b && (b.attr(v), r && !g && \"nowrap\" !== l.whiteSpace && (r < b.textPxLength || \"SPAN\" === b.element.tagName) ? (d.width = r, w || (d.textOverflow = b.specificTextOverflow || D), b.css(d)) : b.styles && b.styles.width && !d.width && !g && b.css({\n            width: null\n          }), delete b.specificTextOverflow, a.rotation = v.rotation);\n        });\n        this.tickRotCorr = b.rotCorr(e.b, this.labelRotation || 0, 0 !== this.side);\n      },\n      hasData: function hasData() {\n        return this.hasVisibleSeries || x(this.min) && x(this.max) && this.tickPositions && 0 < this.tickPositions.length;\n      },\n      addTitle: function addTitle(a) {\n        var b = this.chart.renderer,\n            g = this.horiz,\n            d = this.opposite,\n            c = this.options.title,\n            n;\n        this.axisTitle || ((n = c.textAlign) || (n = (g ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: d ? \"right\" : \"left\",\n          middle: \"center\",\n          high: d ? \"left\" : \"right\"\n        })[c.align]), this.axisTitle = b.text(c.text, 0, 0, c.useHTML).attr({\n          zIndex: 7,\n          rotation: c.rotation || 0,\n          align: n\n        }).addClass(\"highcharts-axis-title\").css(w(c.style)).add(this.axisGroup), this.axisTitle.isNew = !0);\n        c.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len\n        });\n        this.axisTitle[a ? \"show\" : \"hide\"](!0);\n      },\n      generateTick: function generateTick(a) {\n        var b = this.ticks;\n        b[a] ? b[a].addLabel() : b[a] = new M(this, a);\n      },\n      getOffset: function getOffset() {\n        var a = this,\n            b = a.chart,\n            d = b.renderer,\n            c = a.options,\n            n = a.tickPositions,\n            l = a.ticks,\n            A = a.horiz,\n            q = a.side,\n            v = b.inverted && !a.isZAxis ? [1, 0, 3, 2][q] : q,\n            e,\n            w,\n            r = 0,\n            h,\n            D = 0,\n            G = c.title,\n            I = c.labels,\n            u = 0,\n            M = b.axisOffset,\n            b = b.clipOffset,\n            p = [-1, 1, 1, -1][q],\n            m = c.className,\n            t = a.axisParent,\n            L = this.tickSize(\"tick\");\n        e = a.hasData();\n        a.showAxis = w = e || H(c.showEmpty, !0);\n        a.staggerLines = a.horiz && I.staggerLines;\n        a.axisGroup || (a.gridGroup = d.g(\"grid\").attr({\n          zIndex: c.gridZIndex || 1\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \"-grid \" + (m || \"\")).add(t), a.axisGroup = d.g(\"axis\").attr({\n          zIndex: c.zIndex || 2\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \" \" + (m || \"\")).add(t), a.labelGroup = d.g(\"axis-labels\").attr({\n          zIndex: I.zIndex || 7\n        }).addClass(\"highcharts-\" + a.coll.toLowerCase() + \"-labels \" + (m || \"\")).add(t));\n        e || a.isLinked ? (f(n, function (b, d) {\n          a.generateTick(b, d);\n        }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === q || 2 === q || {\n          1: \"left\",\n          3: \"right\"\n        }[q] === a.labelAlign, H(I.reserveSpace, \"center\" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && f(n, function (a) {\n          u = Math.max(l[a].getLabelSize(), u);\n        }), a.staggerLines && (u *= a.staggerLines), a.labelOffset = u * (a.opposite ? -1 : 1)) : B(l, function (a, b) {\n          a.destroy();\n          delete l[b];\n        });\n        G && G.text && !1 !== G.enabled && (a.addTitle(w), w && !1 !== G.reserveSpace && (a.titleOffset = r = a.axisTitle.getBBox()[A ? \"height\" : \"width\"], h = G.offset, D = x(h) ? 0 : H(G.margin, A ? 5 : 10)));\n        a.renderLine();\n        a.offset = p * H(c.offset, M[q]);\n        a.tickRotCorr = a.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        d = 0 === q ? -a.labelMetrics().h : 2 === q ? a.tickRotCorr.y : 0;\n        D = Math.abs(u) + D;\n        u && (D = D - d + p * (A ? H(I.y, a.tickRotCorr.y + 8 * p) : I.x));\n        a.axisTitleMargin = H(h, D);\n        M[q] = Math.max(M[q], a.axisTitleMargin + r + p * a.offset, D, e && n.length && L ? L[0] + p * a.offset : 0);\n        c = c.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);\n        b[v] = Math.max(b[v], c);\n        k(this, \"afterGetOffset\");\n      },\n      getLinePath: function getLinePath(a) {\n        var b = this.chart,\n            d = this.opposite,\n            g = this.offset,\n            c = this.horiz,\n            n = this.left + (d ? this.width : 0) + g,\n            g = b.chartHeight - this.bottom - (d ? this.height : 0) + g;\n        d && (a *= -1);\n        return b.renderer.crispLine([\"M\", c ? this.left : n, c ? g : this.top, \"L\", c ? b.chartWidth - this.right : n, c ? g : b.chartHeight - this.bottom], a);\n      },\n      renderLine: function renderLine() {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      },\n      getTitlePosition: function getTitlePosition() {\n        var a = this.horiz,\n            b = this.left,\n            d = this.top,\n            c = this.len,\n            n = this.options.title,\n            l = a ? b : d,\n            f = this.opposite,\n            k = this.offset,\n            A = n.x || 0,\n            q = n.y || 0,\n            v = this.axisTitle,\n            e = this.chart.renderer.fontMetrics(n.style && n.style.fontSize, v),\n            v = Math.max(v.getBBox(null, 0).height - e.h - 1, 0),\n            c = {\n          low: l + (a ? 0 : c),\n          middle: l + c / 2,\n          high: l + (a ? c : 0)\n        }[n.align],\n            b = (a ? d + this.height : b) + (a ? 1 : -1) * (f ? -1 : 1) * this.axisTitleMargin + [-v, v, e.f, -v][this.side];\n        return {\n          x: a ? c + A : b + (f ? this.width : 0) + k + A,\n          y: a ? b + q - (f ? this.height : 0) + k : c + q\n        };\n      },\n      renderMinorTick: function renderMinorTick(a) {\n        var b = this.chart.hasRendered && q(this.oldMin),\n            d = this.minorTicks;\n        d[a] || (d[a] = new M(this, a, \"minor\"));\n        b && d[a].isNew && d[a].render(null, !0);\n        d[a].render(null, !1, 1);\n      },\n      renderTick: function renderTick(a, b) {\n        var d = this.isLinked,\n            g = this.ticks,\n            c = this.chart.hasRendered && q(this.oldMin);\n        if (!d || a >= this.min && a <= this.max) g[a] || (g[a] = new M(this, a)), c && g[a].isNew && g[a].render(b, !0, .1), g[a].render(b);\n      },\n      render: function render() {\n        var b = this,\n            d = b.chart,\n            c = b.options,\n            n = b.isLog,\n            l = b.isLinked,\n            v = b.tickPositions,\n            e = b.axisTitle,\n            w = b.ticks,\n            r = b.minorTicks,\n            D = b.alternateBands,\n            h = c.stackLabels,\n            G = c.alternateGridColor,\n            I = b.tickmarkOffset,\n            u = b.axisLine,\n            H = b.showAxis,\n            p = E(d.renderer.globalAnimation),\n            m,\n            t;\n        b.labelEdge.length = 0;\n        b.overlap = !1;\n        f([w, r, D], function (a) {\n          B(a, function (a) {\n            a.isActive = !1;\n          });\n        });\n        if (b.hasData() || l) b.minorTickInterval && !b.categories && f(b.getMinorTickPositions(), function (a) {\n          b.renderMinorTick(a);\n        }), v.length && (f(v, function (a, d) {\n          b.renderTick(a, d);\n        }), I && (0 === b.min || b.single) && (w[-1] || (w[-1] = new M(b, -1, null, !0)), w[-1].render(-1))), G && f(v, function (c, g) {\n          t = void 0 !== v[g + 1] ? v[g + 1] + I : b.max - I;\n          0 === g % 2 && c < b.max && t <= b.max + (d.polar ? -I : I) && (D[c] || (D[c] = new a.PlotLineOrBand(b)), m = c + I, D[c].options = {\n            from: n ? b.lin2log(m) : m,\n            to: n ? b.lin2log(t) : t,\n            color: G\n          }, D[c].render(), D[c].isActive = !0);\n        }), b._addedPlotLB || (f((c.plotLines || []).concat(c.plotBands || []), function (a) {\n          b.addPlotBandOrLine(a);\n        }), b._addedPlotLB = !0);\n        f([w, r, D], function (a) {\n          var b,\n              c = [],\n              g = p.duration;\n          B(a, function (a, b) {\n            a.isActive || (a.render(b, !1, 0), a.isActive = !1, c.push(b));\n          });\n          A(function () {\n            for (b = c.length; b--;) {\n              a[c[b]] && !a[c[b]].isActive && (a[c[b]].destroy(), delete a[c[b]]);\n            }\n          }, a !== D && d.hasRendered && g ? g : 0);\n        });\n        u && (u[u.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(u.strokeWidth())\n        }), u.isPlaced = !0, u[H ? \"show\" : \"hide\"](!0));\n        e && H && (c = b.getTitlePosition(), q(c.y) ? (e[e.isNew ? \"attr\" : \"animate\"](c), e.isNew = !1) : (e.attr(\"y\", -9999), e.isNew = !0));\n        h && h.enabled && b.renderStackTotals();\n        b.isDirty = !1;\n        k(this, \"afterRender\");\n      },\n      redraw: function redraw() {\n        this.visible && (this.render(), f(this.plotLinesAndBands, function (a) {\n          a.render();\n        }));\n        f(this.series, function (a) {\n          a.isDirty = !0;\n        });\n      },\n      keepProps: \"extKey hcEvents names series userMax userMin\".split(\" \"),\n      destroy: function destroy(a) {\n        var d = this,\n            c = d.stacks,\n            g = d.plotLinesAndBands,\n            l;\n        k(this, \"destroy\", {\n          keepEvents: a\n        });\n        a || n(d);\n        B(c, function (a, b) {\n          u(a);\n          c[b] = null;\n        });\n        f([d.ticks, d.minorTicks, d.alternateBands], function (a) {\n          u(a);\n        });\n        if (g) for (a = g.length; a--;) {\n          g[a].destroy();\n        }\n        f(\"stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \"), function (a) {\n          d[a] && (d[a] = d[a].destroy());\n        });\n\n        for (l in d.plotLinesAndBandsGroups) {\n          d.plotLinesAndBandsGroups[l] = d.plotLinesAndBandsGroups[l].destroy();\n        }\n\n        B(d, function (a, c) {\n          -1 === b(c, d.keepProps) && delete d[c];\n        });\n      },\n      drawCrosshair: function drawCrosshair(a, b) {\n        var d,\n            c = this.crosshair,\n            g = H(c.snap, !0),\n            n,\n            l = this.cross;\n        k(this, \"drawCrosshair\", {\n          e: a,\n          point: b\n        });\n        a || (a = this.cross && this.cross.e);\n\n        if (this.crosshair && !1 !== (x(b) || !g)) {\n          g ? x(b) && (n = H(b.crosshairPos, this.isXAxis ? b.plotX : this.len - b.plotY)) : n = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);\n          x(n) && (d = this.getPlotLinePath(b && (this.isXAxis ? b.x : H(b.stackY, b.y)), null, null, null, n) || null);\n\n          if (!x(d)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          g = this.categories && !this.isRadial;\n          l || (this.cross = l = this.chart.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (g ? \"category \" : \"thin \") + c.className).attr({\n            zIndex: H(c.zIndex, 2)\n          }).add(), l.attr({\n            stroke: c.color || (g ? h(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": H(c.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), c.dashStyle && l.attr({\n            dashstyle: c.dashStyle\n          }));\n          l.show().attr({\n            d: d\n          });\n          g && !c.width && l.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = a;\n        } else this.hideCrosshair();\n\n        k(this, \"afterDrawCrosshair\", {\n          e: a,\n          point: b\n        });\n      },\n      hideCrosshair: function hideCrosshair() {\n        this.cross && this.cross.hide();\n      }\n    });\n    return a.Axis = G;\n  }(K);\n\n  (function (a) {\n    var C = a.Axis,\n        E = a.getMagnitude,\n        F = a.normalizeTickInterval,\n        m = a.timeUnits;\n\n    C.prototype.getTimeTicks = function () {\n      return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n    };\n\n    C.prototype.normalizeTimeTickInterval = function (a, e) {\n      var h = e || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n      e = h[h.length - 1];\n      var x = m[e[0]],\n          p = e[1],\n          u;\n\n      for (u = 0; u < h.length && !(e = h[u], x = m[e[0]], p = e[1], h[u + 1] && a <= (x * p[p.length - 1] + m[h[u + 1][0]]) / 2); u++) {\n        ;\n      }\n\n      x === m.year && a < 5 * x && (p = [1, 2, 5]);\n      a = F(a / x, p, \"year\" === e[0] ? Math.max(E(a / x), 1) : 1);\n      return {\n        unitRange: x,\n        count: a,\n        unitName: e[0]\n      };\n    };\n  })(K);\n\n  (function (a) {\n    var C = a.Axis,\n        E = a.getMagnitude,\n        F = a.map,\n        m = a.normalizeTickInterval,\n        h = a.pick;\n\n    C.prototype.getLogTickPositions = function (a, t, x, p) {\n      var e = this.options,\n          f = this.len,\n          c = [];\n      p || (this._minorAutoInterval = null);\n      if (.5 <= a) a = Math.round(a), c = this.getLinearTickPositions(a, t, x);else if (.08 <= a) for (var f = Math.floor(t), k, r, l, d, b, e = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; f < x + 1 && !b; f++) {\n        for (r = e.length, k = 0; k < r && !b; k++) {\n          l = this.log2lin(this.lin2log(f) * e[k]), l > t && (!p || d <= x) && void 0 !== d && c.push(d), d > x && (b = !0), d = l;\n        }\n      } else t = this.lin2log(t), x = this.lin2log(x), a = p ? this.getMinorTickInterval() : e.tickInterval, a = h(\"auto\" === a ? null : a, this._minorAutoInterval, e.tickPixelInterval / (p ? 5 : 1) * (x - t) / ((p ? f / this.tickPositions.length : f) || 1)), a = m(a, null, E(a)), c = F(this.getLinearTickPositions(a, t, x), this.log2lin), p || (this._minorAutoInterval = a / 5);\n      p || (this.tickInterval = a);\n      return c;\n    };\n\n    C.prototype.log2lin = function (a) {\n      return Math.log(a) / Math.LN10;\n    };\n\n    C.prototype.lin2log = function (a) {\n      return Math.pow(10, a);\n    };\n  })(K);\n\n  (function (a, C) {\n    var E = a.arrayMax,\n        F = a.arrayMin,\n        m = a.defined,\n        h = a.destroyObjectProperties,\n        e = a.each,\n        t = a.erase,\n        x = a.merge,\n        p = a.pick;\n\n    a.PlotLineOrBand = function (a, f) {\n      this.axis = a;\n      f && (this.options = f, this.id = f.id);\n    };\n\n    a.PlotLineOrBand.prototype = {\n      render: function render() {\n        var e = this,\n            f = e.axis,\n            c = f.horiz,\n            k = e.options,\n            r = k.label,\n            l = e.label,\n            d = k.to,\n            b = k.from,\n            v = k.value,\n            q = m(b) && m(d),\n            h = m(v),\n            w = e.svgElem,\n            t = !w,\n            B = [],\n            H = k.color,\n            n = p(k.zIndex, 0),\n            D = k.events,\n            B = {\n          \"class\": \"highcharts-plot-\" + (q ? \"band \" : \"line \") + (k.className || \"\")\n        },\n            A = {},\n            M = f.chart.renderer,\n            G = q ? \"bands\" : \"lines\";\n        f.isLog && (b = f.log2lin(b), d = f.log2lin(d), v = f.log2lin(v));\n        h ? (B.stroke = H, B[\"stroke-width\"] = k.width, k.dashStyle && (B.dashstyle = k.dashStyle)) : q && (H && (B.fill = H), k.borderWidth && (B.stroke = k.borderColor, B[\"stroke-width\"] = k.borderWidth));\n        A.zIndex = n;\n        G += \"-\" + n;\n        (H = f.plotLinesAndBandsGroups[G]) || (f.plotLinesAndBandsGroups[G] = H = M.g(\"plot-\" + G).attr(A).add());\n        t && (e.svgElem = w = M.path().attr(B).add(H));\n        if (h) B = f.getPlotLinePath(v, w.strokeWidth());else if (q) B = f.getPlotBandPath(b, d, k);else return;\n        t && B && B.length ? (w.attr({\n          d: B\n        }), D && a.objectEach(D, function (a, b) {\n          w.on(b, function (a) {\n            D[b].apply(e, [a]);\n          });\n        })) : w && (B ? (w.show(), w.animate({\n          d: B\n        })) : (w.hide(), l && (e.label = l = l.destroy())));\n        r && m(r.text) && B && B.length && 0 < f.width && 0 < f.height && !B.isFlat ? (r = x({\n          align: c && q && \"center\",\n          x: c ? !q && 4 : 10,\n          verticalAlign: !c && q && \"middle\",\n          y: c ? q ? 16 : 10 : q ? 6 : -4,\n          rotation: c && !q && 90\n        }, r), this.renderLabel(r, B, q, n)) : l && l.hide();\n        return e;\n      },\n      renderLabel: function renderLabel(a, f, c, k) {\n        var e = this.label,\n            l = this.axis.chart.renderer;\n        e || (e = {\n          align: a.textAlign || a.align,\n          rotation: a.rotation,\n          \"class\": \"highcharts-plot-\" + (c ? \"band\" : \"line\") + \"-label \" + (a.className || \"\")\n        }, e.zIndex = k, this.label = e = l.text(a.text, 0, 0, a.useHTML).attr(e).add(), e.css(a.style));\n        k = f.xBounds || [f[1], f[4], c ? f[6] : f[1]];\n        f = f.yBounds || [f[2], f[5], c ? f[7] : f[2]];\n        c = F(k);\n        l = F(f);\n        e.align(a, !1, {\n          x: c,\n          y: l,\n          width: E(k) - c,\n          height: E(f) - l\n        });\n        e.show();\n      },\n      destroy: function destroy() {\n        t(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        h(this);\n      }\n    };\n    a.extend(C.prototype, {\n      getPlotBandPath: function getPlotBandPath(a, f) {\n        var c = this.getPlotLinePath(f, null, null, !0),\n            k = this.getPlotLinePath(a, null, null, !0),\n            e = [],\n            l = this.horiz,\n            d = 1,\n            b;\n        a = a < this.min && f < this.min || a > this.max && f > this.max;\n        if (k && c) for (a && (b = k.toString() === c.toString(), d = 0), a = 0; a < k.length; a += 6) {\n          l && c[a + 1] === k[a + 1] ? (c[a + 1] += d, c[a + 4] += d) : l || c[a + 2] !== k[a + 2] || (c[a + 2] += d, c[a + 5] += d), e.push(\"M\", k[a + 1], k[a + 2], \"L\", k[a + 4], k[a + 5], c[a + 4], c[a + 5], c[a + 1], c[a + 2], \"z\"), e.isFlat = b;\n        }\n        return e;\n      },\n      addPlotBand: function addPlotBand(a) {\n        return this.addPlotBandOrLine(a, \"plotBands\");\n      },\n      addPlotLine: function addPlotLine(a) {\n        return this.addPlotBandOrLine(a, \"plotLines\");\n      },\n      addPlotBandOrLine: function addPlotBandOrLine(e, f) {\n        var c = new a.PlotLineOrBand(this, e).render(),\n            k = this.userOptions;\n        c && (f && (k[f] = k[f] || [], k[f].push(e)), this.plotLinesAndBands.push(c));\n        return c;\n      },\n      removePlotBandOrLine: function removePlotBandOrLine(a) {\n        for (var f = this.plotLinesAndBands, c = this.options, k = this.userOptions, h = f.length; h--;) {\n          f[h].id === a && f[h].destroy();\n        }\n\n        e([c.plotLines || [], k.plotLines || [], c.plotBands || [], k.plotBands || []], function (c) {\n          for (h = c.length; h--;) {\n            c[h].id === a && t(c, c[h]);\n          }\n        });\n      },\n      removePlotBand: function removePlotBand(a) {\n        this.removePlotBandOrLine(a);\n      },\n      removePlotLine: function removePlotLine(a) {\n        this.removePlotBandOrLine(a);\n      }\n    });\n  })(K, V);\n\n  (function (a) {\n    var C = a.doc,\n        E = a.each,\n        F = a.extend,\n        m = a.format,\n        h = a.isNumber,\n        e = a.map,\n        t = a.merge,\n        x = a.pick,\n        p = a.splat,\n        u = a.syncTimeout,\n        f = a.timeUnits;\n\n    a.Tooltip = function () {\n      this.init.apply(this, arguments);\n    };\n\n    a.Tooltip.prototype = {\n      init: function init(a, f) {\n        this.chart = a;\n        this.options = f;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = f.split && !a.inverted;\n        this.shared = f.shared || this.split;\n        this.outside = f.outside && !this.split;\n      },\n      cleanSplit: function cleanSplit(a) {\n        E(this.chart.series, function (c) {\n          var f = c && c.tt;\n          f && (!f.isActive || a ? c.tt = f.destroy() : f.isActive = !1);\n        });\n      },\n      getLabel: function getLabel() {\n        var c = this.chart.renderer,\n            f = this.options,\n            e;\n        this.label || (this.outside && (this.container = e = a.doc.createElement(\"div\"), e.className = \"highcharts-tooltip-container\", a.css(e, {\n          position: \"absolute\",\n          top: \"1px\",\n          pointerEvents: f.style && f.style.pointerEvents\n        }), a.doc.body.appendChild(e), this.renderer = c = new a.Renderer(e, 0, 0)), this.split ? this.label = c.g(\"tooltip\") : (this.label = c.label(\"\", 0, 0, f.shape || \"callout\", null, null, f.useHTML, null, \"tooltip\").attr({\n          padding: f.padding,\n          r: f.borderRadius\n        }), this.label.attr({\n          fill: f.backgroundColor,\n          \"stroke-width\": f.borderWidth\n        }).css(f.style).shadow(f.shadow)), this.outside && (this.label.attr({\n          x: this.distance,\n          y: this.distance\n        }), this.label.xSetter = function (a) {\n          e.style.left = a + \"px\";\n        }, this.label.ySetter = function (a) {\n          e.style.top = a + \"px\";\n        }), this.label.attr({\n          zIndex: 8\n        }).add());\n        return this.label;\n      },\n      update: function update(a) {\n        this.destroy();\n        t(!0, this.chart.options.tooltip.userOptions, a);\n        this.init(this.chart, t(!0, this.options, a));\n      },\n      destroy: function destroy() {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), a.discardElement(this.container));\n        a.clearTimeout(this.hideTimer);\n        a.clearTimeout(this.tooltipTimeout);\n      },\n      move: function move(c, f, e, l) {\n        var d = this,\n            b = d.now,\n            k = !1 !== d.options.animation && !d.isHidden && (1 < Math.abs(c - b.x) || 1 < Math.abs(f - b.y)),\n            q = d.followPointer || 1 < d.len;\n        F(b, {\n          x: k ? (2 * b.x + c) / 3 : c,\n          y: k ? (b.y + f) / 2 : f,\n          anchorX: q ? void 0 : k ? (2 * b.anchorX + e) / 3 : e,\n          anchorY: q ? void 0 : k ? (b.anchorY + l) / 2 : l\n        });\n        d.getLabel().attr(b);\n        k && (a.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          d && d.move(c, f, e, l);\n        }, 32));\n      },\n      hide: function hide(c) {\n        var f = this;\n        a.clearTimeout(this.hideTimer);\n        c = x(c, this.options.hideDelay, 500);\n        this.isHidden || (this.hideTimer = u(function () {\n          f.getLabel()[c ? \"fadeOut\" : \"hide\"]();\n          f.isHidden = !0;\n        }, c));\n      },\n      getAnchor: function getAnchor(a, f) {\n        var c = this.chart,\n            l = c.pointer,\n            d = c.inverted,\n            b = c.plotTop,\n            k = c.plotLeft,\n            q = 0,\n            h = 0,\n            w,\n            m;\n        a = p(a);\n        this.followPointer && f ? (void 0 === f.chartX && (f = l.normalize(f)), a = [f.chartX - c.plotLeft, f.chartY - b]) : a[0].tooltipPos ? a = a[0].tooltipPos : (E(a, function (a) {\n          w = a.series.yAxis;\n          m = a.series.xAxis;\n          q += a.plotX + (!d && m ? m.left - k : 0);\n          h += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!d && w ? w.top - b : 0);\n        }), q /= a.length, h /= a.length, a = [d ? c.plotWidth - h : q, this.shared && !d && 1 < a.length && f ? f.chartY - b : d ? c.plotHeight - q : h]);\n        return e(a, Math.round);\n      },\n      getPosition: function getPosition(a, f, e) {\n        var c = this.chart,\n            d = this.distance,\n            b = {},\n            k = c.inverted && e.h || 0,\n            q,\n            h = this.outside,\n            w = h ? C.documentElement.clientWidth - 2 * d : c.chartWidth,\n            r = h ? Math.max(C.body.scrollHeight, C.documentElement.scrollHeight, C.body.offsetHeight, C.documentElement.offsetHeight, C.documentElement.clientHeight) : c.chartHeight,\n            B = c.pointer.chartPosition,\n            H = [\"y\", r, f, (h ? B.top - d : 0) + e.plotY + c.plotTop, h ? 0 : c.plotTop, h ? r : c.plotTop + c.plotHeight],\n            n = [\"x\", w, a, (h ? B.left - d : 0) + e.plotX + c.plotLeft, h ? 0 : c.plotLeft, h ? w : c.plotLeft + c.plotWidth],\n            D = !this.followPointer && x(e.ttBelow, !c.inverted === !!e.negative),\n            A = function A(a, c, g, n, l, f) {\n          var A = g < n - d,\n              e = n + d + g < c,\n              q = n - d - g;\n          n += d;\n          if (D && e) b[a] = n;else if (!D && A) b[a] = q;else if (A) b[a] = Math.min(f - g, 0 > q - k ? q : q - k);else if (e) b[a] = Math.max(l, n + k + g > c ? n : n + k);else return !1;\n        },\n            M = function M(a, c, g, n) {\n          var l;\n          n < d || n > c - d ? l = !1 : b[a] = n < g / 2 ? 1 : n > c - g / 2 ? c - g - 2 : n - g / 2;\n          return l;\n        },\n            G = function G(a) {\n          var b = H;\n          H = n;\n          n = b;\n          q = a;\n        },\n            g = function g() {\n          !1 !== A.apply(0, H) ? !1 !== M.apply(0, n) || q || (G(!0), g()) : q ? b.x = b.y = 0 : (G(!0), g());\n        };\n\n        (c.inverted || 1 < this.len) && G();\n        g();\n        return b;\n      },\n      defaultFormatter: function defaultFormatter(a) {\n        var c = this.points || p(this),\n            f;\n        f = [a.tooltipFooterHeaderFormatter(c[0])];\n        f = f.concat(a.bodyFormatter(c));\n        f.push(a.tooltipFooterHeaderFormatter(c[0], !0));\n        return f;\n      },\n      refresh: function refresh(c, f) {\n        var k,\n            l = this.options,\n            d,\n            b = c,\n            e,\n            q = {},\n            h = [];\n        k = l.formatter || this.defaultFormatter;\n        var q = this.shared,\n            w;\n        l.enabled && (a.clearTimeout(this.hideTimer), this.followPointer = p(b)[0].series.tooltipOptions.followPointer, e = this.getAnchor(b, f), f = e[0], d = e[1], !q || b.series && b.series.noSharedTooltip ? q = b.getLabelConfig() : (E(b, function (a) {\n          a.setState(\"hover\");\n          h.push(a.getLabelConfig());\n        }), q = {\n          x: b[0].category,\n          y: b[0].y\n        }, q.points = h, b = b[0]), this.len = h.length, q = k.call(q, this), w = b.series, this.distance = x(w.tooltipOptions.distance, 16), !1 === q ? this.hide() : (k = this.getLabel(), this.isHidden && k.attr({\n          opacity: 1\n        }).show(), this.split ? this.renderSplit(q, p(c)) : (l.style.width || k.css({\n          width: this.chart.spacingBox.width\n        }), k.attr({\n          text: q && q.join ? q.join(\"\") : q\n        }), k.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + x(b.colorIndex, w.colorIndex)), k.attr({\n          stroke: l.borderColor || b.color || w.color || \"#666666\"\n        }), this.updatePosition({\n          plotX: f,\n          plotY: d,\n          negative: b.negative,\n          ttBelow: b.ttBelow,\n          h: e[2] || 0\n        })), this.isHidden = !1));\n      },\n      renderSplit: function renderSplit(c, f) {\n        var k = this,\n            l = [],\n            d = this.chart,\n            b = d.renderer,\n            e = !0,\n            q = this.options,\n            h = 0,\n            w,\n            m = this.getLabel(),\n            B = d.plotTop;\n        a.isString(c) && (c = [!1, c]);\n        E(c.slice(0, f.length + 1), function (a, c) {\n          if (!1 !== a) {\n            c = f[c - 1] || {\n              isHeader: !0,\n              plotX: f[0].plotX\n            };\n            var n = c.series || k,\n                A = n.tt,\n                v = c.series || {},\n                r = \"highcharts-color-\" + x(c.colorIndex, v.colorIndex, \"none\");\n            A || (n.tt = A = b.label(null, null, null, \"callout\", null, null, q.useHTML).addClass(\"highcharts-tooltip-box \" + r + (c.isHeader ? \" highcharts-tooltip-header\" : \"\")).attr({\n              padding: q.padding,\n              r: q.borderRadius,\n              fill: q.backgroundColor,\n              stroke: q.borderColor || c.color || v.color || \"#333333\",\n              \"stroke-width\": q.borderWidth\n            }).add(m));\n            A.isActive = !0;\n            A.attr({\n              text: a\n            });\n            A.css(q.style).shadow(q.shadow);\n            a = A.getBBox();\n            v = a.width + A.strokeWidth();\n            c.isHeader ? (h = a.height, d.xAxis[0].opposite && (w = !0, B -= h), v = Math.max(0, Math.min(c.plotX + d.plotLeft - v / 2, d.chartWidth + (d.scrollablePixels ? d.scrollablePixels - d.marginRight : 0) - v))) : v = c.plotX + d.plotLeft - x(q.distance, 16) - v;\n            0 > v && (e = !1);\n            a = (c.series && c.series.yAxis && c.series.yAxis.pos) + (c.plotY || 0);\n            a -= B;\n            c.isHeader && (a = w ? -h : d.plotHeight + h);\n            l.push({\n              target: a,\n              rank: c.isHeader ? 1 : 0,\n              size: n.tt.getBBox().height + 1,\n              point: c,\n              x: v,\n              tt: A\n            });\n          }\n        });\n        this.cleanSplit();\n        a.distribute(l, d.plotHeight + h);\n        E(l, function (a) {\n          var b = a.point,\n              c = b.series;\n          a.tt.attr({\n            visibility: void 0 === a.pos ? \"hidden\" : \"inherit\",\n            x: e || b.isHeader ? a.x : b.plotX + d.plotLeft + x(q.distance, 16),\n            y: a.pos + B,\n            anchorX: b.isHeader ? b.plotX + d.plotLeft : b.plotX + c.xAxis.pos,\n            anchorY: b.isHeader ? d.plotTop + d.plotHeight / 2 : b.plotY + c.yAxis.pos\n          });\n        });\n      },\n      updatePosition: function updatePosition(a) {\n        var c = this.chart,\n            f = this.getLabel(),\n            l = (this.options.positioner || this.getPosition).call(this, f.width, f.height, a),\n            d = a.plotX + c.plotLeft;\n        a = a.plotY + c.plotTop;\n        var b;\n        this.outside && (b = (this.options.borderWidth || 0) + 2 * this.distance, this.renderer.setSize(f.width + b, f.height + b, !1), d += c.pointer.chartPosition.left - l.x, a += c.pointer.chartPosition.top - l.y);\n        this.move(Math.round(l.x), Math.round(l.y || 0), d, a);\n      },\n      getDateFormat: function getDateFormat(a, k, e, l) {\n        var d = this.chart.time,\n            b = d.dateFormat(\"%m-%d %H:%M:%S.%L\", k),\n            c,\n            q,\n            h = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            w = \"millisecond\";\n\n        for (q in f) {\n          if (a === f.week && +d.dateFormat(\"%w\", k) === e && \"00:00:00.000\" === b.substr(6)) {\n            q = \"week\";\n            break;\n          }\n\n          if (f[q] > a) {\n            q = w;\n            break;\n          }\n\n          if (h[q] && b.substr(h[q]) !== \"01-01 00:00:00.000\".substr(h[q])) break;\n          \"week\" !== q && (w = q);\n        }\n\n        q && (c = l[q]);\n        return c;\n      },\n      getXDateFormat: function getXDateFormat(a, f, e) {\n        f = f.dateTimeLabelFormats;\n        var c = e && e.closestPointRange;\n        return (c ? this.getDateFormat(c, a.x, e.options.startOfWeek, f) : f.day) || f.year;\n      },\n      tooltipFooterHeaderFormatter: function tooltipFooterHeaderFormatter(a, f) {\n        f = f ? \"footer\" : \"header\";\n        var c = a.series,\n            l = c.tooltipOptions,\n            d = l.xDateFormat,\n            b = c.xAxis,\n            e = b && \"datetime\" === b.options.type && h(a.key),\n            k = l[f + \"Format\"];\n        e && !d && (d = this.getXDateFormat(a, l, b));\n        e && d && E(a.point && a.point.tooltipDateKeys || [\"key\"], function (a) {\n          k = k.replace(\"{point.\" + a + \"}\", \"{point.\" + a + \":\" + d + \"}\");\n        });\n        return m(k, {\n          point: a,\n          series: c\n        }, this.chart.time);\n      },\n      bodyFormatter: function bodyFormatter(a) {\n        return e(a, function (a) {\n          var c = a.series.tooltipOptions;\n          return (c[(a.point.formatPrefix || \"point\") + \"Formatter\"] || a.point.tooltipFormatter).call(a.point, c[(a.point.formatPrefix || \"point\") + \"Format\"]);\n        });\n      }\n    };\n  })(K);\n\n  (function (a) {\n    var C = a.addEvent,\n        E = a.attr,\n        F = a.charts,\n        m = a.color,\n        h = a.css,\n        e = a.defined,\n        t = a.each,\n        x = a.extend,\n        p = a.find,\n        u = a.fireEvent,\n        f = a.isNumber,\n        c = a.isObject,\n        k = a.offset,\n        r = a.pick,\n        l = a.splat,\n        d = a.Tooltip;\n\n    a.Pointer = function (a, d) {\n      this.init(a, d);\n    };\n\n    a.Pointer.prototype = {\n      init: function init(a, c) {\n        this.options = c;\n        this.chart = a;\n        this.runChartClick = c.chart.events && !!c.chart.events.click;\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        d && (a.tooltip = new d(a, c.tooltip), this.followTouchMove = r(c.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      },\n      zoomOption: function zoomOption(a) {\n        var b = this.chart,\n            d = b.options.chart,\n            c = d.zoomType || \"\",\n            b = b.inverted;\n        /touch/.test(a.type) && (c = r(d.pinchType, c));\n        this.zoomX = a = /x/.test(c);\n        this.zoomY = c = /y/.test(c);\n        this.zoomHor = a && !b || c && b;\n        this.zoomVert = c && !b || a && b;\n        this.hasZoom = a || c;\n      },\n      normalize: function normalize(a, d) {\n        var b;\n        b = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;\n        d || (this.chartPosition = d = k(this.chart.container));\n        return x(a, {\n          chartX: Math.round(b.pageX - d.left),\n          chartY: Math.round(b.pageY - d.top)\n        });\n      },\n      getCoordinates: function getCoordinates(a) {\n        var b = {\n          xAxis: [],\n          yAxis: []\n        };\n        t(this.chart.axes, function (d) {\n          b[d.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: d,\n            value: d.toValue(a[d.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return b;\n      },\n      findNearestKDPoint: function findNearestKDPoint(a, d, f) {\n        var b;\n        t(a, function (a) {\n          var l = !(a.noSharedTooltip && d) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n          a = a.searchPoint(f, l);\n          if ((l = c(a, !0)) && !(l = !c(b, !0))) var l = b.distX - a.distX,\n              e = b.dist - a.dist,\n              k = (a.series.group && a.series.group.zIndex) - (b.series.group && b.series.group.zIndex),\n              l = 0 < (0 !== l && d ? l : 0 !== e ? e : 0 !== k ? k : b.series.index > a.series.index ? -1 : 1);\n          l && (b = a);\n        });\n        return b;\n      },\n      getPointFromEvent: function getPointFromEvent(a) {\n        a = a.target;\n\n        for (var b; a && !b;) {\n          b = a.point, a = a.parentNode;\n        }\n\n        return b;\n      },\n      getChartCoordinatesFromPoint: function getChartCoordinatesFromPoint(a, d) {\n        var b = a.series,\n            c = b.xAxis,\n            b = b.yAxis,\n            f = r(a.clientX, a.plotX),\n            l = a.shapeArgs;\n        if (c && b) return d ? {\n          chartX: c.len + c.pos - f,\n          chartY: b.len + b.pos - a.plotY\n        } : {\n          chartX: f + c.pos,\n          chartY: a.plotY + b.pos\n        };\n        if (l && l.x && l.y) return {\n          chartX: l.x,\n          chartY: l.y\n        };\n      },\n      getHoverData: function getHoverData(b, d, f, l, e, k, h) {\n        var q,\n            n = [],\n            v = h && h.isBoosting;\n        l = !(!l || !b);\n        h = d && !d.stickyTracking ? [d] : a.grep(f, function (a) {\n          return a.visible && !(!e && a.directTouch) && r(a.options.enableMouseTracking, !0) && a.stickyTracking;\n        });\n        d = (q = l ? b : this.findNearestKDPoint(h, e, k)) && q.series;\n        q && (e && !d.noSharedTooltip ? (h = a.grep(f, function (a) {\n          return a.visible && !(!e && a.directTouch) && r(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;\n        }), t(h, function (a) {\n          var b = p(a.points, function (a) {\n            return a.x === q.x && !a.isNull;\n          });\n          c(b) && (v && (b = a.getPoint(b)), n.push(b));\n        })) : n.push(q));\n        return {\n          hoverPoint: q,\n          hoverSeries: d,\n          hoverPoints: n\n        };\n      },\n      runPointActions: function runPointActions(b, d) {\n        var c = this.chart,\n            f = c.tooltip && c.tooltip.options.enabled ? c.tooltip : void 0,\n            l = f ? f.shared : !1,\n            e = d || c.hoverPoint,\n            k = e && e.series || c.hoverSeries,\n            k = this.getHoverData(e, k, c.series, \"touchmove\" !== b.type && (!!d || k && k.directTouch && this.isDirectTouch), l, b, {\n          isBoosting: c.isBoosting\n        }),\n            h,\n            e = k.hoverPoint;\n        h = k.hoverPoints;\n        d = (k = k.hoverSeries) && k.tooltipOptions.followPointer;\n        l = l && k && !k.noSharedTooltip;\n\n        if (e && (e !== c.hoverPoint || f && f.isHidden)) {\n          t(c.hoverPoints || [], function (b) {\n            -1 === a.inArray(b, h) && b.setState();\n          });\n          t(h || [], function (a) {\n            a.setState(\"hover\");\n          });\n          if (c.hoverSeries !== k) k.onMouseOver();\n          c.hoverPoint && c.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!e.series) return;\n          e.firePointEvent(\"mouseOver\");\n          c.hoverPoints = h;\n          c.hoverPoint = e;\n          f && f.refresh(l ? h : e, b);\n        } else d && f && !f.isHidden && (e = f.getAnchor([{}], b), f.updatePosition({\n          plotX: e[0],\n          plotY: e[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = C(c.container.ownerDocument, \"mousemove\", function (b) {\n          var d = F[a.hoverChartIndex];\n          if (d) d.pointer.onDocumentMouseMove(b);\n        }));\n        t(c.axes, function (d) {\n          var c = r(d.crosshair.snap, !0),\n              n = c ? a.find(h, function (a) {\n            return a.series[d.coll] === d;\n          }) : void 0;\n          n || !c ? d.drawCrosshair(b, n) : d.hideCrosshair();\n        });\n      },\n      reset: function reset(a, d) {\n        var b = this.chart,\n            c = b.hoverSeries,\n            f = b.hoverPoint,\n            e = b.hoverPoints,\n            k = b.tooltip,\n            h = k && k.shared ? e : f;\n        a && h && t(l(h), function (b) {\n          b.series.isCartesian && void 0 === b.plotX && (a = !1);\n        });\n        if (a) k && h && (k.refresh(h), k.shared && e ? t(e, function (a) {\n          a.setState(a.state, !0);\n          a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a);\n          a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a);\n        }) : f && (f.setState(f.state, !0), t(b.axes, function (a) {\n          a.crosshair && a.drawCrosshair(null, f);\n        })));else {\n          if (f) f.onMouseOut();\n          e && t(e, function (a) {\n            a.setState();\n          });\n          if (c) c.onMouseOut();\n          k && k.hide(d);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          t(b.axes, function (a) {\n            a.hideCrosshair();\n          });\n          this.hoverX = b.hoverPoints = b.hoverPoint = null;\n        }\n      },\n      scaleGroups: function scaleGroups(a, d) {\n        var b = this.chart,\n            c;\n        t(b.series, function (f) {\n          c = a || f.getPlotBox();\n          f.xAxis && f.xAxis.zoomEnabled && f.group && (f.group.attr(c), f.markerGroup && (f.markerGroup.attr(c), f.markerGroup.clip(d ? b.clipRect : null)), f.dataLabelsGroup && f.dataLabelsGroup.attr(c));\n        });\n        b.clipRect.attr(d || b.clipBox);\n      },\n      dragStart: function dragStart(a) {\n        var b = this.chart;\n        b.mouseIsDown = a.type;\n        b.cancelClick = !1;\n        b.mouseDownX = this.mouseDownX = a.chartX;\n        b.mouseDownY = this.mouseDownY = a.chartY;\n      },\n      drag: function drag(a) {\n        var b = this.chart,\n            d = b.options.chart,\n            c = a.chartX,\n            f = a.chartY,\n            l = this.zoomHor,\n            e = this.zoomVert,\n            k = b.plotLeft,\n            n = b.plotTop,\n            h = b.plotWidth,\n            A = b.plotHeight,\n            r,\n            G = this.selectionMarker,\n            g = this.mouseDownX,\n            y = this.mouseDownY,\n            p = d.panKey && a[d.panKey + \"Key\"];\n        G && G.touch || (c < k ? c = k : c > k + h && (c = k + h), f < n ? f = n : f > n + A && (f = n + A), this.hasDragged = Math.sqrt(Math.pow(g - c, 2) + Math.pow(y - f, 2)), 10 < this.hasDragged && (r = b.isInsidePlot(g - k, y - n), b.hasCartesianSeries && (this.zoomX || this.zoomY) && r && !p && !G && (this.selectionMarker = G = b.renderer.rect(k, n, l ? 1 : h, e ? 1 : A, 0).attr({\n          fill: d.selectionMarkerFill || m(\"#335cad\").setOpacity(.25).get(),\n          \"class\": \"highcharts-selection-marker\",\n          zIndex: 7\n        }).add()), G && l && (c -= g, G.attr({\n          width: Math.abs(c),\n          x: (0 < c ? 0 : c) + g\n        })), G && e && (c = f - y, G.attr({\n          height: Math.abs(c),\n          y: (0 < c ? 0 : c) + y\n        })), r && !G && d.panning && b.pan(a, d.panning)));\n      },\n      drop: function drop(a) {\n        var b = this,\n            d = this.chart,\n            c = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var l = {\n            originalEvent: a,\n            xAxis: [],\n            yAxis: []\n          },\n              k = this.selectionMarker,\n              r = k.attr ? k.attr(\"x\") : k.x,\n              m = k.attr ? k.attr(\"y\") : k.y,\n              n = k.attr ? k.attr(\"width\") : k.width,\n              D = k.attr ? k.attr(\"height\") : k.height,\n              A;\n          if (this.hasDragged || c) t(d.axes, function (d) {\n            if (d.zoomEnabled && e(d.min) && (c || b[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[d.coll]])) {\n              var f = d.horiz,\n                  g = \"touchend\" === a.type ? d.minPixelPadding : 0,\n                  k = d.toValue((f ? r : m) + g),\n                  f = d.toValue((f ? r + n : m + D) - g);\n              l[d.coll].push({\n                axis: d,\n                min: Math.min(k, f),\n                max: Math.max(k, f)\n              });\n              A = !0;\n            }\n          }), A && u(d, \"selection\", l, function (a) {\n            d.zoom(x(a, c ? {\n              animation: !1\n            } : null));\n          });\n          f(d.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          c && this.scaleGroups();\n        }\n\n        d && f(d.index) && (h(d.container, {\n          cursor: d._cursor\n        }), d.cancelClick = 10 < this.hasDragged, d.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      },\n      onContainerMouseDown: function onContainerMouseDown(a) {\n        a = this.normalize(a);\n        2 !== a.button && (this.zoomOption(a), a.preventDefault && a.preventDefault(), this.dragStart(a));\n      },\n      onDocumentMouseUp: function onDocumentMouseUp(b) {\n        F[a.hoverChartIndex] && F[a.hoverChartIndex].pointer.drop(b);\n      },\n      onDocumentMouseMove: function onDocumentMouseMove(a) {\n        var b = this.chart,\n            d = this.chartPosition;\n        a = this.normalize(a, d);\n        !d || this.inClass(a.target, \"highcharts-tracker\") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset();\n      },\n      onContainerMouseLeave: function onContainerMouseLeave(b) {\n        var d = F[a.hoverChartIndex];\n        d && (b.relatedTarget || b.toElement) && (d.pointer.reset(), d.pointer.chartPosition = null);\n      },\n      onContainerMouseMove: function onContainerMouseMove(b) {\n        var d = this.chart;\n        e(a.hoverChartIndex) && F[a.hoverChartIndex] && F[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = d.index);\n        b = this.normalize(b);\n        b.returnValue = !1;\n        \"mousedown\" === d.mouseIsDown && this.drag(b);\n        !this.inClass(b.target, \"highcharts-tracker\") && !d.isInsidePlot(b.chartX - d.plotLeft, b.chartY - d.plotTop) || d.openMenu || this.runPointActions(b);\n      },\n      inClass: function inClass(a, d) {\n        for (var b; a;) {\n          if (b = E(a, \"class\")) {\n            if (-1 !== b.indexOf(d)) return !0;\n            if (-1 !== b.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          a = a.parentNode;\n        }\n      },\n      onTrackerMouseOut: function onTrackerMouseOut(a) {\n        var b = this.chart.hoverSeries;\n        a = a.relatedTarget || a.toElement;\n        this.isDirectTouch = !1;\n        if (!(!b || !a || b.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + b.index) && this.inClass(a, \"highcharts-tracker\"))) b.onMouseOut();\n      },\n      onContainerClick: function onContainerClick(a) {\n        var b = this.chart,\n            d = b.hoverPoint,\n            c = b.plotLeft,\n            f = b.plotTop;\n        a = this.normalize(a);\n        b.cancelClick || (d && this.inClass(a.target, \"highcharts-tracker\") ? (u(d.series, \"click\", x(a, {\n          point: d\n        })), b.hoverPoint && d.firePointEvent(\"click\", a)) : (x(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - c, a.chartY - f) && u(b, \"click\", a)));\n      },\n      setDOMEvents: function setDOMEvents() {\n        var b = this,\n            d = b.chart.container,\n            c = d.ownerDocument;\n\n        d.onmousedown = function (a) {\n          b.onContainerMouseDown(a);\n        };\n\n        d.onmousemove = function (a) {\n          b.onContainerMouseMove(a);\n        };\n\n        d.onclick = function (a) {\n          b.onContainerClick(a);\n        };\n\n        this.unbindContainerMouseLeave = C(d, \"mouseleave\", b.onContainerMouseLeave);\n        a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = C(c, \"mouseup\", b.onDocumentMouseUp));\n        a.hasTouch && (d.ontouchstart = function (a) {\n          b.onContainerTouchStart(a);\n        }, d.ontouchmove = function (a) {\n          b.onContainerTouchMove(a);\n        }, a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = C(c, \"touchend\", b.onDocumentTouchEnd)));\n      },\n      destroy: function destroy() {\n        var b = this;\n        b.unDocMouseMove && b.unDocMouseMove();\n        this.unbindContainerMouseLeave();\n        a.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));\n        clearInterval(b.tooltipTimeout);\n        a.objectEach(b, function (a, d) {\n          b[d] = null;\n        });\n      }\n    };\n  })(K);\n\n  (function (a) {\n    var C = a.charts,\n        E = a.each,\n        F = a.extend,\n        m = a.map,\n        h = a.noop,\n        e = a.pick;\n    F(a.Pointer.prototype, {\n      pinchTranslate: function pinchTranslate(a, e, h, m, f, c) {\n        this.zoomHor && this.pinchTranslateDirection(!0, a, e, h, m, f, c);\n        this.zoomVert && this.pinchTranslateDirection(!1, a, e, h, m, f, c);\n      },\n      pinchTranslateDirection: function pinchTranslateDirection(a, e, h, m, f, c, k, r) {\n        var l = this.chart,\n            d = a ? \"x\" : \"y\",\n            b = a ? \"X\" : \"Y\",\n            v = \"chart\" + b,\n            q = a ? \"width\" : \"height\",\n            p = l[\"plot\" + (a ? \"Left\" : \"Top\")],\n            w,\n            t,\n            B = r || 1,\n            H = l.inverted,\n            n = l.bounds[a ? \"h\" : \"v\"],\n            D = 1 === e.length,\n            A = e[0][v],\n            M = h[0][v],\n            G = !D && e[1][v],\n            g = !D && h[1][v],\n            y;\n\n        h = function h() {\n          !D && 20 < Math.abs(A - G) && (B = r || Math.abs(M - g) / Math.abs(A - G));\n          t = (p - M) / B + A;\n          w = l[\"plot\" + (a ? \"Width\" : \"Height\")] / B;\n        };\n\n        h();\n        e = t;\n        e < n.min ? (e = n.min, y = !0) : e + w > n.max && (e = n.max - w, y = !0);\n        y ? (M -= .8 * (M - k[d][0]), D || (g -= .8 * (g - k[d][1])), h()) : k[d] = [M, g];\n        H || (c[d] = t - p, c[q] = w);\n        c = H ? 1 / B : B;\n        f[q] = w;\n        f[d] = e;\n        m[H ? a ? \"scaleY\" : \"scaleX\" : \"scale\" + b] = B;\n        m[\"translate\" + b] = c * p + (M - c * A);\n      },\n      pinch: function pinch(a) {\n        var t = this,\n            p = t.chart,\n            u = t.pinchDown,\n            f = a.touches,\n            c = f.length,\n            k = t.lastValidTouch,\n            r = t.hasZoom,\n            l = t.selectionMarker,\n            d = {},\n            b = 1 === c && (t.inClass(a.target, \"highcharts-tracker\") && p.runTrackerClick || t.runChartClick),\n            v = {};\n        1 < c && (t.initiated = !0);\n        r && t.initiated && !b && a.preventDefault();\n        m(f, function (a) {\n          return t.normalize(a);\n        });\n        \"touchstart\" === a.type ? (E(f, function (a, b) {\n          u[b] = {\n            chartX: a.chartX,\n            chartY: a.chartY\n          };\n        }), k.x = [u[0].chartX, u[1] && u[1].chartX], k.y = [u[0].chartY, u[1] && u[1].chartY], E(p.axes, function (a) {\n          if (a.zoomEnabled) {\n            var b = p.bounds[a.horiz ? \"h\" : \"v\"],\n                d = a.minPixelPadding,\n                c = a.toPixels(e(a.options.min, a.dataMin)),\n                f = a.toPixels(e(a.options.max, a.dataMax)),\n                l = Math.max(c, f);\n            b.min = Math.min(a.pos, Math.min(c, f) - d);\n            b.max = Math.max(a.pos + a.len, l + d);\n          }\n        }), t.res = !0) : t.followTouchMove && 1 === c ? this.runPointActions(t.normalize(a)) : u.length && (l || (t.selectionMarker = l = F({\n          destroy: h,\n          touch: !0\n        }, p.plotBox)), t.pinchTranslate(u, f, d, l, v, k), t.hasPinched = r, t.scaleGroups(d, v), t.res && (t.res = !1, this.reset(!1, 0)));\n      },\n      touch: function touch(h, m) {\n        var p = this.chart,\n            t,\n            f;\n        if (p.index !== a.hoverChartIndex) this.onContainerMouseLeave({\n          relatedTarget: !0\n        });\n        a.hoverChartIndex = p.index;\n        1 === h.touches.length ? (h = this.normalize(h), (f = p.isInsidePlot(h.chartX - p.plotLeft, h.chartY - p.plotTop)) && !p.openMenu ? (m && this.runPointActions(h), \"touchmove\" === h.type && (m = this.pinchDown, t = m[0] ? 4 <= Math.sqrt(Math.pow(m[0].chartX - h.chartX, 2) + Math.pow(m[0].chartY - h.chartY, 2)) : !1), e(t, !0) && this.pinch(h)) : m && this.reset()) : 2 === h.touches.length && this.pinch(h);\n      },\n      onContainerTouchStart: function onContainerTouchStart(a) {\n        this.zoomOption(a);\n        this.touch(a, !0);\n      },\n      onContainerTouchMove: function onContainerTouchMove(a) {\n        this.touch(a);\n      },\n      onDocumentTouchEnd: function onDocumentTouchEnd(e) {\n        C[a.hoverChartIndex] && C[a.hoverChartIndex].pointer.drop(e);\n      }\n    });\n  })(K);\n\n  (function (a) {\n    var C = a.addEvent,\n        E = a.charts,\n        F = a.css,\n        m = a.doc,\n        h = a.extend,\n        e = a.noop,\n        t = a.Pointer,\n        x = a.removeEvent,\n        p = a.win,\n        u = a.wrap;\n\n    if (!a.hasTouch && (p.PointerEvent || p.MSPointerEvent)) {\n      var f = {},\n          c = !!p.PointerEvent,\n          k = function k() {\n        var c = [];\n\n        c.item = function (a) {\n          return this[a];\n        };\n\n        a.objectEach(f, function (a) {\n          c.push({\n            pageX: a.pageX,\n            pageY: a.pageY,\n            target: a.target\n          });\n        });\n        return c;\n      },\n          r = function r(c, d, b, f) {\n        \"touch\" !== c.pointerType && c.pointerType !== c.MSPOINTER_TYPE_TOUCH || !E[a.hoverChartIndex] || (f(c), f = E[a.hoverChartIndex].pointer, f[d]({\n          type: b,\n          target: c.currentTarget,\n          preventDefault: e,\n          touches: k()\n        }));\n      };\n\n      h(t.prototype, {\n        onContainerPointerDown: function onContainerPointerDown(a) {\n          r(a, \"onContainerTouchStart\", \"touchstart\", function (a) {\n            f[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY,\n              target: a.currentTarget\n            };\n          });\n        },\n        onContainerPointerMove: function onContainerPointerMove(a) {\n          r(a, \"onContainerTouchMove\", \"touchmove\", function (a) {\n            f[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY\n            };\n            f[a.pointerId].target || (f[a.pointerId].target = a.currentTarget);\n          });\n        },\n        onDocumentPointerUp: function onDocumentPointerUp(a) {\n          r(a, \"onDocumentTouchEnd\", \"touchend\", function (a) {\n            delete f[a.pointerId];\n          });\n        },\n        batchMSEvents: function batchMSEvents(a) {\n          a(this.chart.container, c ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n          a(this.chart.container, c ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n          a(m, c ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n        }\n      });\n      u(t.prototype, \"init\", function (a, d, b) {\n        a.call(this, d, b);\n        this.hasZoom && F(d.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      });\n      u(t.prototype, \"setDOMEvents\", function (a) {\n        a.apply(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(C);\n      });\n      u(t.prototype, \"destroy\", function (a) {\n        this.batchMSEvents(x);\n        a.call(this);\n      });\n    }\n  })(K);\n\n  (function (a) {\n    var C = a.addEvent,\n        E = a.css,\n        F = a.discardElement,\n        m = a.defined,\n        h = a.each,\n        e = a.fireEvent,\n        t = a.isFirefox,\n        x = a.marginNames,\n        p = a.merge,\n        u = a.pick,\n        f = a.setAnimation,\n        c = a.stableSort,\n        k = a.win,\n        r = a.wrap;\n\n    a.Legend = function (a, d) {\n      this.init(a, d);\n    };\n\n    a.Legend.prototype = {\n      init: function init(a, d) {\n        this.chart = a;\n        this.setOptions(d);\n        d.enabled && (this.render(), C(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = C(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      },\n      setOptions: function setOptions(a) {\n        var d = u(a.padding, 8);\n        this.options = a;\n        this.itemStyle = a.itemStyle;\n        this.itemHiddenStyle = p(this.itemStyle, a.itemHiddenStyle);\n        this.itemMarginTop = a.itemMarginTop || 0;\n        this.padding = d;\n        this.initialItemY = d - 5;\n        this.symbolWidth = u(a.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === a.layout && !this.chart.inverted;\n      },\n      update: function update(a, d) {\n        var b = this.chart;\n        this.setOptions(p(!0, this.options, a));\n        this.destroy();\n        b.isDirtyLegend = b.isDirtyBox = !0;\n        u(d, !0) && b.redraw();\n        e(this, \"afterUpdate\");\n      },\n      colorizeItem: function colorizeItem(a, d) {\n        a.legendGroup[d ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n        var b = this.options,\n            c = a.legendItem,\n            f = a.legendLine,\n            l = a.legendSymbol,\n            k = this.itemHiddenStyle.color,\n            b = d ? b.itemStyle.color : k,\n            h = d ? a.color || k : k,\n            r = a.options && a.options.marker,\n            m = {\n          fill: h\n        };\n        c && c.css({\n          fill: b,\n          color: b\n        });\n        f && f.attr({\n          stroke: h\n        });\n        l && (r && l.isMarker && (m = a.pointAttribs(), d || (m.stroke = m.fill = k)), l.attr(m));\n        e(this, \"afterColorizeItem\", {\n          item: a,\n          visible: d\n        });\n      },\n      positionItems: function positionItems() {\n        h(this.allItems, this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      },\n      positionItem: function positionItem(a) {\n        var d = this.options,\n            b = d.symbolPadding,\n            d = !d.rtl,\n            c = a._legendItemPos,\n            f = c[0],\n            c = c[1],\n            l = a.checkbox;\n        if ((a = a.legendGroup) && a.element) a[m(a.translateY) ? \"animate\" : \"attr\"]({\n          translateX: d ? f : this.legendWidth - f - 2 * b - 4,\n          translateY: c\n        });\n        l && (l.x = f, l.y = c);\n      },\n      destroyItem: function destroyItem(a) {\n        var d = a.checkbox;\n        h([\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"], function (b) {\n          a[b] && (a[b] = a[b].destroy());\n        });\n        d && F(a.checkbox);\n      },\n      destroy: function destroy() {\n        function a(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }\n\n        h(this.getAllItems(), function (d) {\n          h([\"legendItem\", \"legendGroup\"], a, d);\n        });\n        h(\"clipRect up down pager nav box title group\".split(\" \"), a, this);\n        this.display = null;\n      },\n      positionCheckboxes: function positionCheckboxes() {\n        var a = this.group && this.group.alignAttr,\n            d,\n            b = this.clipHeight || this.legendHeight,\n            c = this.titleHeight;\n        a && (d = a.translateY, h(this.allItems, function (f) {\n          var l = f.checkbox,\n              e;\n          l && (e = d + c + l.y + (this.scrollOffset || 0) + 3, E(l, {\n            left: a.translateX + f.checkboxOffset + l.x - 20 + \"px\",\n            top: e + \"px\",\n            display: e > d - 6 && e < d + b - 6 ? \"\" : \"none\"\n          }));\n        }, this));\n      },\n      renderTitle: function renderTitle() {\n        var a = this.options,\n            d = this.padding,\n            b = a.title,\n            c = 0;\n        b.text && (this.title || (this.title = this.chart.renderer.label(b.text, d - 3, d - 4, null, null, null, a.useHTML, null, \"legend-title\").attr({\n          zIndex: 1\n        }).css(b.style).add(this.group)), a = this.title.getBBox(), c = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: c\n        }));\n        this.titleHeight = c;\n      },\n      setText: function setText(c) {\n        var d = this.options;\n        c.legendItem.attr({\n          text: d.labelFormat ? a.format(d.labelFormat, c, this.chart.time) : d.labelFormatter.call(c)\n        });\n      },\n      renderItem: function renderItem(a) {\n        var d = this.chart,\n            b = d.renderer,\n            c = this.options,\n            f = this.symbolWidth,\n            e = c.symbolPadding,\n            k = this.itemStyle,\n            l = this.itemHiddenStyle,\n            h = \"horizontal\" === c.layout ? u(c.itemDistance, 20) : 0,\n            r = !c.rtl,\n            n = a.legendItem,\n            D = !a.series,\n            A = !D && a.series.drawLegendSymbol ? a.series : a,\n            m = A.options,\n            m = this.createCheckboxForItem && m && m.showCheckbox,\n            h = f + e + h + (m ? 20 : 0),\n            G = c.useHTML,\n            g = a.options.className;\n        n || (a.legendGroup = b.g(\"legend-item\").addClass(\"highcharts-\" + A.type + \"-series highcharts-color-\" + a.colorIndex + (g ? \" \" + g : \"\") + (D ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.legendItem = n = b.text(\"\", r ? f + e : -e, this.baseline || 0, G).css(p(a.visible ? k : l)).attr({\n          align: r ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.legendGroup), this.baseline || (f = k.fontSize, this.fontMetrics = b.fontMetrics(f, n), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, n.attr(\"y\", this.baseline)), this.symbolHeight = c.symbolHeight || this.fontMetrics.f, A.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, n, G), m && this.createCheckboxForItem(a));\n        this.colorizeItem(a, a.visible);\n        k.width || n.css({\n          width: (c.itemWidth || c.width || d.spacingBox.width) - h\n        });\n        this.setText(a);\n        d = n.getBBox();\n        a.itemWidth = a.checkboxOffset = c.itemWidth || a.legendItemWidth || d.width + h;\n        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);\n        this.totalItemWidth += a.itemWidth;\n        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || d.height || this.symbolHeight);\n      },\n      layoutItem: function layoutItem(a) {\n        var c = this.options,\n            b = this.padding,\n            f = \"horizontal\" === c.layout,\n            e = a.itemHeight,\n            k = c.itemMarginBottom || 0,\n            l = this.itemMarginTop,\n            h = f ? u(c.itemDistance, 20) : 0,\n            r = c.width,\n            m = r || this.chart.spacingBox.width - 2 * b - c.x,\n            c = c.alignColumns && this.totalItemWidth > m ? this.maxItemWidth : a.itemWidth;\n        f && this.itemX - b + c > m && (this.itemX = b, this.itemY += l + this.lastLineHeight + k, this.lastLineHeight = 0);\n        this.lastItemY = l + this.itemY + k;\n        this.lastLineHeight = Math.max(e, this.lastLineHeight);\n        a._legendItemPos = [this.itemX, this.itemY];\n        f ? this.itemX += c : (this.itemY += l + e + k, this.lastLineHeight = e);\n        this.offsetWidth = r || Math.max((f ? this.itemX - b - (a.checkbox ? 0 : h) : c) + b, this.offsetWidth);\n      },\n      getAllItems: function getAllItems() {\n        var a = [];\n        h(this.chart.series, function (c) {\n          var b = c && c.options;\n          c && u(b.showInLegend, m(b.linkedTo) ? !1 : void 0, !0) && (a = a.concat(c.legendItems || (\"point\" === b.legendType ? c.data : c)));\n        });\n        e(this, \"afterGetAllItems\", {\n          allItems: a\n        });\n        return a;\n      },\n      getAlignment: function getAlignment() {\n        var a = this.options;\n        return this.proximate ? a.align.charAt(0) + \"tv\" : a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      },\n      adjustMargins: function adjustMargins(a, c) {\n        var b = this.chart,\n            d = this.options,\n            f = this.getAlignment();\n        f && h([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function (e, k) {\n          e.test(f) && !m(a[k]) && (b[x[k]] = Math.max(b[x[k]], b.legend[(k + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][k] * d[k % 2 ? \"x\" : \"y\"] + u(d.margin, 12) + c[k] + (0 === k && void 0 !== b.options.title.margin ? b.titleOffset + b.options.title.margin : 0)));\n        });\n      },\n      proximatePositions: function proximatePositions() {\n        var c = this.chart,\n            d = [],\n            b = \"left\" === this.options.align;\n        h(this.allItems, function (f) {\n          var e, k;\n          e = b;\n          f.xAxis && f.points && (f.xAxis.options.reversed && (e = !e), e = a.find(e ? f.points : f.points.slice(0).reverse(), function (b) {\n            return a.isNumber(b.plotY);\n          }), k = f.legendGroup.getBBox().height, d.push({\n            target: f.visible ? (e ? e.plotY : f.xAxis.height) - .3 * k : c.plotHeight,\n            size: k,\n            item: f\n          }));\n        }, this);\n        a.distribute(d, c.plotHeight);\n        h(d, function (a) {\n          a.item._legendItemPos[1] = c.plotTop - c.spacing[0] + a.pos;\n        });\n      },\n      render: function render() {\n        var a = this.chart,\n            d = a.renderer,\n            b = this.group,\n            f,\n            e,\n            k,\n            r = this.box,\n            m = this.options,\n            B = this.padding;\n        this.itemX = B;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        b || (this.group = b = d.g(\"legend\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = d.g().attr({\n          zIndex: 1\n        }).add(b), this.scrollGroup = d.g().add(this.contentGroup));\n        this.renderTitle();\n        f = this.getAllItems();\n        c(f, function (a, b) {\n          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);\n        });\n        m.reversed && f.reverse();\n        this.allItems = f;\n        this.display = e = !!f.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        h(f, this.renderItem, this);\n        h(f, this.layoutItem, this);\n        f = (m.width || this.offsetWidth) + B;\n        k = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        k = this.handleOverflow(k);\n        k += B;\n        r || (this.box = r = d.rect().addClass(\"highcharts-legend-box\").attr({\n          r: m.borderRadius\n        }).add(b), r.isNew = !0);\n        r.attr({\n          stroke: m.borderColor,\n          \"stroke-width\": m.borderWidth || 0,\n          fill: m.backgroundColor || \"none\"\n        }).shadow(m.shadow);\n        0 < f && 0 < k && (r[r.isNew ? \"attr\" : \"animate\"](r.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: f,\n          height: k\n        }, r.strokeWidth())), r.isNew = !1);\n        r[e ? \"show\" : \"hide\"]();\n        this.legendWidth = f;\n        this.legendHeight = k;\n        e && (d = a.spacingBox, /(lth|ct|rth)/.test(this.getAlignment()) && (d = p(d, {\n          y: d.y + a.titleOffset + a.options.title.margin\n        })), b.align(p(m, {\n          width: f,\n          height: k,\n          verticalAlign: this.proximate ? \"top\" : m.verticalAlign\n        }), !0, d));\n        this.proximate || this.positionItems();\n      },\n      handleOverflow: function handleOverflow(a) {\n        var c = this,\n            b = this.chart,\n            f = b.renderer,\n            e = this.options,\n            k = e.y,\n            l = this.padding,\n            b = b.spacingBox.height + (\"top\" === e.verticalAlign ? -k : k) - l,\n            k = e.maxHeight,\n            r,\n            m = this.clipRect,\n            p = e.navigation,\n            n = u(p.animation, !0),\n            D = p.arrowSize || 12,\n            A = this.nav,\n            t = this.pages,\n            G,\n            g = this.allItems,\n            y = function y(a) {\n          \"number\" === typeof a ? m.attr({\n            height: a\n          }) : m && (c.clipRect = m.destroy(), c.contentGroup.clip());\n          c.contentGroup.div && (c.contentGroup.div.style.clip = a ? \"rect(\" + l + \"px,9999px,\" + (l + a) + \"px,0)\" : \"auto\");\n        };\n\n        \"horizontal\" !== e.layout || \"middle\" === e.verticalAlign || e.floating || (b /= 2);\n        k && (b = Math.min(b, k));\n        t.length = 0;\n        a > b && !1 !== p.enabled ? (this.clipHeight = r = Math.max(b - 20 - this.titleHeight - l, 0), this.currentPage = u(this.currentPage, 1), this.fullHeight = a, h(g, function (a, b) {\n          var c = a._legendItemPos[1],\n              d = Math.round(a.legendItem.getBBox().height),\n              f = t.length;\n          if (!f || c - t[f - 1] > r && (G || c) !== t[f - 1]) t.push(G || c), f++;\n          a.pageIx = f - 1;\n          G && (g[b - 1].pageIx = f - 1);\n          b === g.length - 1 && c + d - t[f - 1] > r && (t.push(c), a.pageIx = f);\n          c !== G && (G = c);\n        }), m || (m = c.clipRect = f.clipRect(0, l, 9999, 0), c.contentGroup.clip(m)), y(r), A || (this.nav = A = f.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = f.symbol(\"triangle\", 0, 0, D, D).on(\"click\", function () {\n          c.scroll(-1, n);\n        }).add(A), this.pager = f.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\").css(p.style).add(A), this.down = f.symbol(\"triangle-down\", 0, 0, D, D).on(\"click\", function () {\n          c.scroll(1, n);\n        }).add(A)), c.scroll(0), a = b) : A && (y(), this.nav = A.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      },\n      scroll: function scroll(a, c) {\n        var b = this.pages,\n            d = b.length;\n        a = this.currentPage + a;\n        var e = this.clipHeight,\n            k = this.options.navigation,\n            l = this.pager,\n            h = this.padding;\n        a > d && (a = d);\n        0 < a && (void 0 !== c && f(c, this.chart), this.nav.attr({\n          translateX: h,\n          translateY: e + this.padding + 7 + this.titleHeight,\n          visibility: \"visible\"\n        }), this.up.attr({\n          \"class\": 1 === a ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n        }), l.attr({\n          text: a + \"/\" + d\n        }), this.down.attr({\n          x: 18 + this.pager.getBBox().width,\n          \"class\": a === d ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n        }), this.up.attr({\n          fill: 1 === a ? k.inactiveColor : k.activeColor\n        }).css({\n          cursor: 1 === a ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: a === d ? k.inactiveColor : k.activeColor\n        }).css({\n          cursor: a === d ? \"default\" : \"pointer\"\n        }), this.scrollOffset = -b[a - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = a, this.positionCheckboxes());\n      }\n    };\n    a.LegendSymbolMixin = {\n      drawRectangle: function drawRectangle(a, c) {\n        var b = a.symbolHeight,\n            d = a.options.squareSymbol;\n        c.legendSymbol = this.chart.renderer.rect(d ? (a.symbolWidth - b) / 2 : 0, a.baseline - b + 1, d ? b : a.symbolWidth, b, u(a.options.symbolRadius, b / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(c.legendGroup);\n      },\n      drawLineMarker: function drawLineMarker(a) {\n        var c = this.options,\n            b = c.marker,\n            f = a.symbolWidth,\n            e = a.symbolHeight,\n            k = e / 2,\n            h = this.chart.renderer,\n            l = this.legendGroup;\n        a = a.baseline - Math.round(.3 * a.fontMetrics.b);\n        var r;\n        r = {\n          \"stroke-width\": c.lineWidth || 0\n        };\n        c.dashStyle && (r.dashstyle = c.dashStyle);\n        this.legendLine = h.path([\"M\", 0, a, \"L\", f, a]).addClass(\"highcharts-graph\").attr(r).add(l);\n        b && !1 !== b.enabled && f && (c = Math.min(u(b.radius, k), k), 0 === this.symbol.indexOf(\"url\") && (b = p(b, {\n          width: e,\n          height: e\n        }), c = 0), this.legendSymbol = b = h.symbol(this.symbol, f / 2 - c, a - c, 2 * c, 2 * c, b).addClass(\"highcharts-point\").add(l), b.isMarker = !0);\n      }\n    };\n    (/Trident\\/7\\.0/.test(k.navigator.userAgent) || t) && r(a.Legend.prototype, \"positionItem\", function (a, c) {\n      var b = this,\n          d = function d() {\n        c._legendItemPos && a.call(b, c);\n      };\n\n      d();\n      setTimeout(d);\n    });\n  })(K);\n\n  (function (a) {\n    var C = a.addEvent,\n        E = a.animate,\n        F = a.animObject,\n        m = a.attr,\n        h = a.doc,\n        e = a.Axis,\n        t = a.createElement,\n        x = a.defaultOptions,\n        p = a.discardElement,\n        u = a.charts,\n        f = a.css,\n        c = a.defined,\n        k = a.each,\n        r = a.extend,\n        l = a.find,\n        d = a.fireEvent,\n        b = a.grep,\n        v = a.isNumber,\n        q = a.isObject,\n        I = a.isString,\n        w = a.Legend,\n        L = a.marginNames,\n        B = a.merge,\n        H = a.objectEach,\n        n = a.Pointer,\n        D = a.pick,\n        A = a.pInt,\n        M = a.removeEvent,\n        G = a.seriesTypes,\n        g = a.splat,\n        y = a.syncTimeout,\n        Q = a.win,\n        N = a.Chart = function () {\n      this.getArgs.apply(this, arguments);\n    };\n\n    a.chart = function (a, b, c) {\n      return new N(a, b, c);\n    };\n\n    r(N.prototype, {\n      callbacks: [],\n      getArgs: function getArgs() {\n        var a = [].slice.call(arguments);\n        if (I(a[0]) || a[0].nodeName) this.renderTo = a.shift();\n        this.init(a[0], a[1]);\n      },\n      init: function init(b, c) {\n        var g,\n            f,\n            n = b.series,\n            e = b.plotOptions || {};\n        d(this, \"init\", {\n          args: arguments\n        }, function () {\n          b.series = null;\n          g = B(x, b);\n\n          for (f in g.plotOptions) {\n            g.plotOptions[f].tooltip = e[f] && B(e[f].tooltip) || void 0;\n          }\n\n          g.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;\n          g.series = b.series = n;\n          this.userOptions = b;\n          var k = g.chart,\n              h = k.events;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = c;\n          this.isResizing = 0;\n          this.options = g;\n          this.axes = [];\n          this.series = [];\n          this.time = b.time && a.keys(b.time).length ? new a.Time(b.time) : a.time;\n          this.hasCartesianSeries = k.showAxes;\n          var l = this;\n          l.index = u.length;\n          u.push(l);\n          a.chartCount++;\n          h && H(h, function (a, b) {\n            C(l, b, a);\n          });\n          l.xAxis = [];\n          l.yAxis = [];\n          l.pointCount = l.colorCounter = l.symbolCounter = 0;\n          d(l, \"afterInit\");\n          l.firstRender();\n        });\n      },\n      initSeries: function initSeries(b) {\n        var c = this.options.chart;\n        (c = G[b.type || c.type || c.defaultSeriesType]) || a.error(17, !0);\n        c = new c();\n        c.init(this, b);\n        return c;\n      },\n      orderSeries: function orderSeries(a) {\n        var b = this.series;\n\n        for (a = a || 0; a < b.length; a++) {\n          b[a] && (b[a].index = a, b[a].name = b[a].getName());\n        }\n      },\n      isInsidePlot: function isInsidePlot(a, b, c) {\n        var d = c ? b : a;\n        a = c ? a : b;\n        return 0 <= d && d <= this.plotWidth && 0 <= a && a <= this.plotHeight;\n      },\n      redraw: function redraw(b) {\n        d(this, \"beforeRedraw\");\n        var c = this.axes,\n            g = this.series,\n            f = this.pointer,\n            n = this.legend,\n            e = this.userOptions.legend,\n            h = this.isDirtyLegend,\n            l,\n            A,\n            D = this.hasCartesianSeries,\n            y = this.isDirtyBox,\n            q,\n            w = this.renderer,\n            m = w.isHidden(),\n            G = [];\n        this.setResponsive && this.setResponsive(!1);\n        a.setAnimation(b, this);\n        m && this.temporaryDisplay();\n        this.layOutTitles();\n\n        for (b = g.length; b--;) {\n          if (q = g[b], q.options.stacking && (l = !0, q.isDirty)) {\n            A = !0;\n            break;\n          }\n        }\n\n        if (A) for (b = g.length; b--;) {\n          q = g[b], q.options.stacking && (q.isDirty = !0);\n        }\n        k(g, function (a) {\n          a.isDirty && (\"point\" === a.options.legendType ? (a.updateTotals && a.updateTotals(), h = !0) : e && (e.labelFormatter || e.labelFormat) && (h = !0));\n          a.isDirtyData && d(a, \"updatedData\");\n        });\n        h && n && n.options.enabled && (n.render(), this.isDirtyLegend = !1);\n        l && this.getStacks();\n        D && k(c, function (a) {\n          a.updateNames();\n          a.setScale();\n        });\n        this.getMargins();\n        D && (k(c, function (a) {\n          a.isDirty && (y = !0);\n        }), k(c, function (a) {\n          var b = a.min + \",\" + a.max;\n          a.extKey !== b && (a.extKey = b, G.push(function () {\n            d(a, \"afterSetExtremes\", r(a.eventArgs, a.getExtremes()));\n            delete a.eventArgs;\n          }));\n          (y || l) && a.redraw();\n        }));\n        y && this.drawChartBox();\n        d(this, \"predraw\");\n        k(g, function (a) {\n          (y || a.isDirty) && a.visible && a.redraw();\n          a.isDirtyData = !1;\n        });\n        f && f.reset(!0);\n        w.draw();\n        d(this, \"redraw\");\n        d(this, \"render\");\n        m && this.temporaryDisplay(!0);\n        k(G, function (a) {\n          a.call();\n        });\n      },\n      get: function get(a) {\n        function b(b) {\n          return b.id === a || b.options && b.options.id === a;\n        }\n\n        var c,\n            d = this.series,\n            g;\n        c = l(this.axes, b) || l(this.series, b);\n\n        for (g = 0; !c && g < d.length; g++) {\n          c = l(d[g].points || [], b);\n        }\n\n        return c;\n      },\n      getAxes: function getAxes() {\n        var a = this,\n            b = this.options,\n            c = b.xAxis = g(b.xAxis || {}),\n            b = b.yAxis = g(b.yAxis || {});\n        d(this, \"getAxes\");\n        k(c, function (a, b) {\n          a.index = b;\n          a.isX = !0;\n        });\n        k(b, function (a, b) {\n          a.index = b;\n        });\n        c = c.concat(b);\n        k(c, function (b) {\n          new e(a, b);\n        });\n        d(this, \"afterGetAxes\");\n      },\n      getSelectedPoints: function getSelectedPoints() {\n        var a = [];\n        k(this.series, function (c) {\n          a = a.concat(b(c.data || [], function (a) {\n            return a.selected;\n          }));\n        });\n        return a;\n      },\n      getSelectedSeries: function getSelectedSeries() {\n        return b(this.series, function (a) {\n          return a.selected;\n        });\n      },\n      setTitle: function setTitle(a, b, c) {\n        var d = this,\n            g = d.options,\n            f;\n        f = g.title = B({\n          style: {\n            color: \"#333333\",\n            fontSize: g.isStock ? \"16px\" : \"18px\"\n          }\n        }, g.title, a);\n        g = g.subtitle = B({\n          style: {\n            color: \"#666666\"\n          }\n        }, g.subtitle, b);\n        k([[\"title\", a, f], [\"subtitle\", b, g]], function (a, b) {\n          var c = a[0],\n              g = d[c],\n              f = a[1];\n          a = a[2];\n          g && f && (d[c] = g = g.destroy());\n          a && !g && (d[c] = d.renderer.text(a.text, 0, 0, a.useHTML).attr({\n            align: a.align,\n            \"class\": \"highcharts-\" + c,\n            zIndex: a.zIndex || 4\n          }).add(), d[c].update = function (a) {\n            d.setTitle(!b && a, b && a);\n          }, d[c].css(a.style));\n        });\n        d.layOutTitles(c);\n      },\n      layOutTitles: function layOutTitles(a) {\n        var b = 0,\n            c,\n            d = this.renderer,\n            g = this.spacingBox;\n        k([\"title\", \"subtitle\"], function (a) {\n          var c = this[a],\n              f = this.options[a];\n          a = \"title\" === a ? -3 : f.verticalAlign ? 0 : b + 2;\n          var n;\n          c && (n = f.style.fontSize, n = d.fontMetrics(n, c).b, c.css({\n            width: (f.width || g.width + f.widthAdjust) + \"px\"\n          }).align(r({\n            y: a + n\n          }, f), !1, \"spacingBox\"), f.floating || f.verticalAlign || (b = Math.ceil(b + c.getBBox(f.useHTML).height)));\n        }, this);\n        c = this.titleOffset !== b;\n        this.titleOffset = b;\n        !this.isDirtyBox && c && (this.isDirtyBox = this.isDirtyLegend = c, this.hasRendered && D(a, !0) && this.isDirtyBox && this.redraw());\n      },\n      getChartSize: function getChartSize() {\n        var b = this.options.chart,\n            d = b.width,\n            b = b.height,\n            g = this.renderTo;\n        c(d) || (this.containerWidth = a.getStyle(g, \"width\"));\n        c(b) || (this.containerHeight = a.getStyle(g, \"height\"));\n        this.chartWidth = Math.max(0, d || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, a.relativeLength(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      },\n      temporaryDisplay: function temporaryDisplay(b) {\n        var c = this.renderTo;\n        if (b) for (; c && c.style;) {\n          c.hcOrigStyle && (a.css(c, c.hcOrigStyle), delete c.hcOrigStyle), c.hcOrigDetached && (h.body.removeChild(c), c.hcOrigDetached = !1), c = c.parentNode;\n        } else for (; c && c.style;) {\n          h.body.contains(c) || c.parentNode || (c.hcOrigDetached = !0, h.body.appendChild(c));\n          if (\"none\" === a.getStyle(c, \"display\", !1) || c.hcOricDetached) c.hcOrigStyle = {\n            display: c.style.display,\n            height: c.style.height,\n            overflow: c.style.overflow\n          }, b = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, c !== this.renderTo && (b.height = 0), a.css(c, b), c.offsetWidth || c.style.setProperty(\"display\", \"block\", \"important\");\n          c = c.parentNode;\n          if (c === h.body) break;\n        }\n      },\n      setClassName: function setClassName(a) {\n        this.container.className = \"highcharts-container \" + (a || \"\");\n      },\n      getContainer: function getContainer() {\n        var b,\n            c = this.options,\n            g = c.chart,\n            f,\n            n;\n        b = this.renderTo;\n        var e = a.uniqueKey(),\n            k;\n        b || (this.renderTo = b = g.renderTo);\n        I(b) && (this.renderTo = b = h.getElementById(b));\n        b || a.error(13, !0);\n        f = A(m(b, \"data-highcharts-chart\"));\n        v(f) && u[f] && u[f].hasRendered && u[f].destroy();\n        m(b, \"data-highcharts-chart\", this.index);\n        b.innerHTML = \"\";\n        g.skipClone || b.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        f = this.chartWidth;\n        n = this.chartHeight;\n        k = r({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: f + \"px\",\n          height: n + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\"\n        }, g.style);\n        this.container = b = t(\"div\", {\n          id: e\n        }, k, b);\n        this._cursor = b.style.cursor;\n        this.renderer = new (a[g.renderer] || a.Renderer)(b, f, n, null, g.forExport, c.exporting && c.exporting.allowHTML);\n        this.setClassName(g.className);\n        this.renderer.setStyle(g.style);\n        this.renderer.chartIndex = this.index;\n        d(this, \"afterGetContainer\");\n      },\n      getMargins: function getMargins(a) {\n        var b = this.spacing,\n            g = this.margin,\n            f = this.titleOffset;\n        this.resetMargins();\n        f && !c(g[0]) && (this.plotTop = Math.max(this.plotTop, f + this.options.title.margin + b[0]));\n        this.legend && this.legend.display && this.legend.adjustMargins(g, b);\n        d(this, \"getMargins\");\n        a || this.getAxisMargins();\n      },\n      getAxisMargins: function getAxisMargins() {\n        var a = this,\n            b = a.axisOffset = [0, 0, 0, 0],\n            d = a.margin;\n        a.hasCartesianSeries && k(a.axes, function (a) {\n          a.visible && a.getOffset();\n        });\n        k(L, function (g, f) {\n          c(d[f]) || (a[g] += b[f]);\n        });\n        a.setChartSize();\n      },\n      reflow: function reflow(b) {\n        var d = this,\n            g = d.options.chart,\n            f = d.renderTo,\n            n = c(g.width) && c(g.height),\n            e = g.width || a.getStyle(f, \"width\"),\n            g = g.height || a.getStyle(f, \"height\"),\n            f = b ? b.target : Q;\n\n        if (!n && !d.isPrinting && e && g && (f === Q || f === h)) {\n          if (e !== d.containerWidth || g !== d.containerHeight) a.clearTimeout(d.reflowTimeout), d.reflowTimeout = y(function () {\n            d.container && d.setSize(void 0, void 0, !1);\n          }, b ? 100 : 0);\n          d.containerWidth = e;\n          d.containerHeight = g;\n        }\n      },\n      setReflow: function setReflow(a) {\n        var b = this;\n        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = C(Q, \"resize\", function (a) {\n          b.reflow(a);\n        }), C(this, \"destroy\", this.unbindReflow));\n      },\n      setSize: function setSize(b, c, g) {\n        var n = this,\n            e = n.renderer;\n        n.isResizing += 1;\n        a.setAnimation(g, n);\n        n.oldChartHeight = n.chartHeight;\n        n.oldChartWidth = n.chartWidth;\n        void 0 !== b && (n.options.chart.width = b);\n        void 0 !== c && (n.options.chart.height = c);\n        n.getChartSize();\n        b = e.globalAnimation;\n        (b ? E : f)(n.container, {\n          width: n.chartWidth + \"px\",\n          height: n.chartHeight + \"px\"\n        }, b);\n        n.setChartSize(!0);\n        e.setSize(n.chartWidth, n.chartHeight, g);\n        k(n.axes, function (a) {\n          a.isDirty = !0;\n          a.setScale();\n        });\n        n.isDirtyLegend = !0;\n        n.isDirtyBox = !0;\n        n.layOutTitles();\n        n.getMargins();\n        n.redraw(g);\n        n.oldChartHeight = null;\n        d(n, \"resize\");\n        y(function () {\n          n && d(n, \"endResize\", null, function () {\n            --n.isResizing;\n          });\n        }, F(b).duration);\n      },\n      setChartSize: function setChartSize(a) {\n        var b = this.inverted,\n            c = this.renderer,\n            g = this.chartWidth,\n            f = this.chartHeight,\n            n = this.options.chart,\n            e = this.spacing,\n            h = this.clipOffset,\n            l,\n            A,\n            D,\n            r;\n        this.plotLeft = l = Math.round(this.plotLeft);\n        this.plotTop = A = Math.round(this.plotTop);\n        this.plotWidth = D = Math.max(0, Math.round(g - l - this.marginRight));\n        this.plotHeight = r = Math.max(0, Math.round(f - A - this.marginBottom));\n        this.plotSizeX = b ? r : D;\n        this.plotSizeY = b ? D : r;\n        this.plotBorderWidth = n.plotBorderWidth || 0;\n        this.spacingBox = c.spacingBox = {\n          x: e[3],\n          y: e[0],\n          width: g - e[3] - e[1],\n          height: f - e[0] - e[2]\n        };\n        this.plotBox = c.plotBox = {\n          x: l,\n          y: A,\n          width: D,\n          height: r\n        };\n        g = 2 * Math.floor(this.plotBorderWidth / 2);\n        b = Math.ceil(Math.max(g, h[3]) / 2);\n        c = Math.ceil(Math.max(g, h[0]) / 2);\n        this.clipBox = {\n          x: b,\n          y: c,\n          width: Math.floor(this.plotSizeX - Math.max(g, h[1]) / 2 - b),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(g, h[2]) / 2 - c))\n        };\n        a || k(this.axes, function (a) {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        });\n        d(this, \"afterSetChartSize\", {\n          skipAxes: a\n        });\n      },\n      resetMargins: function resetMargins() {\n        var a = this,\n            b = a.options.chart;\n        k([\"margin\", \"spacing\"], function (c) {\n          var d = b[c],\n              g = q(d) ? d : [d, d, d, d];\n          k([\"Top\", \"Right\", \"Bottom\", \"Left\"], function (d, f) {\n            a[c][f] = D(b[c + d], g[f]);\n          });\n        });\n        k(L, function (b, c) {\n          a[b] = D(a.margin[c], a.spacing[c]);\n        });\n        a.axisOffset = [0, 0, 0, 0];\n        a.clipOffset = [0, 0, 0, 0];\n      },\n      drawChartBox: function drawChartBox() {\n        var a = this.options.chart,\n            b = this.renderer,\n            c = this.chartWidth,\n            g = this.chartHeight,\n            f = this.chartBackground,\n            n = this.plotBackground,\n            e = this.plotBorder,\n            k,\n            h = this.plotBGImage,\n            l = a.backgroundColor,\n            A = a.plotBackgroundColor,\n            D = a.plotBackgroundImage,\n            r,\n            y = this.plotLeft,\n            q = this.plotTop,\n            w = this.plotWidth,\n            m = this.plotHeight,\n            G = this.plotBox,\n            B = this.clipRect,\n            v = this.clipBox,\n            p = \"animate\";\n        f || (this.chartBackground = f = b.rect().addClass(\"highcharts-background\").add(), p = \"attr\");\n        k = a.borderWidth || 0;\n        r = k + (a.shadow ? 8 : 0);\n        l = {\n          fill: l || \"none\"\n        };\n        if (k || f[\"stroke-width\"]) l.stroke = a.borderColor, l[\"stroke-width\"] = k;\n        f.attr(l).shadow(a.shadow);\n        f[p]({\n          x: r / 2,\n          y: r / 2,\n          width: c - r - k % 2,\n          height: g - r - k % 2,\n          r: a.borderRadius\n        });\n        p = \"animate\";\n        n || (p = \"attr\", this.plotBackground = n = b.rect().addClass(\"highcharts-plot-background\").add());\n        n[p](G);\n        n.attr({\n          fill: A || \"none\"\n        }).shadow(a.plotShadow);\n        D && (h ? h.animate(G) : this.plotBGImage = b.image(D, y, q, w, m).add());\n        B ? B.animate({\n          width: v.width,\n          height: v.height\n        }) : this.clipRect = b.clipRect(v);\n        p = \"animate\";\n        e || (p = \"attr\", this.plotBorder = e = b.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        e.attr({\n          stroke: a.plotBorderColor,\n          \"stroke-width\": a.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        e[p](e.crisp({\n          x: y,\n          y: q,\n          width: w,\n          height: m\n        }, -e.strokeWidth()));\n        this.isDirtyBox = !1;\n        d(this, \"afterDrawChartBox\");\n      },\n      propFromSeries: function propFromSeries() {\n        var a = this,\n            b = a.options.chart,\n            c,\n            d = a.options.series,\n            g,\n            f;\n        k([\"inverted\", \"angular\", \"polar\"], function (n) {\n          c = G[b.type || b.defaultSeriesType];\n          f = b[n] || c && c.prototype[n];\n\n          for (g = d && d.length; !f && g--;) {\n            (c = G[d[g].type]) && c.prototype[n] && (f = !0);\n          }\n\n          a[n] = f;\n        });\n      },\n      linkSeries: function linkSeries() {\n        var a = this,\n            b = a.series;\n        k(b, function (a) {\n          a.linkedSeries.length = 0;\n        });\n        k(b, function (b) {\n          var c = b.options.linkedTo;\n          I(c) && (c = \":previous\" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), b.linkedParent = c, b.visible = D(b.options.visible, c.options.visible, b.visible));\n        });\n        d(this, \"afterLinkSeries\");\n      },\n      renderSeries: function renderSeries() {\n        k(this.series, function (a) {\n          a.translate();\n          a.render();\n        });\n      },\n      renderLabels: function renderLabels() {\n        var a = this,\n            b = a.options.labels;\n        b.items && k(b.items, function (c) {\n          var d = r(b.style, c.style),\n              g = A(d.left) + a.plotLeft,\n              f = A(d.top) + a.plotTop + 12;\n          delete d.left;\n          delete d.top;\n          a.renderer.text(c.html, g, f).attr({\n            zIndex: 2\n          }).css(d).add();\n        });\n      },\n      render: function render() {\n        var a = this.axes,\n            b = this.renderer,\n            c = this.options,\n            d,\n            g,\n            f;\n        this.setTitle();\n        this.legend = new w(this, c.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        c = this.plotWidth;\n        d = this.plotHeight = Math.max(this.plotHeight - 21, 0);\n        k(a, function (a) {\n          a.setScale();\n        });\n        this.getAxisMargins();\n        g = 1.1 < c / this.plotWidth;\n        f = 1.05 < d / this.plotHeight;\n        if (g || f) k(a, function (a) {\n          (a.horiz && g || !a.horiz && f) && a.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries && k(a, function (a) {\n          a.visible && a.render();\n        });\n        this.seriesGroup || (this.seriesGroup = b.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.hasRendered = !0;\n      },\n      addCredits: function addCredits(a) {\n        var b = this;\n        a = B(!0, this.options.credits, a);\n        a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          a.href && (Q.location.href = a.href);\n        }).attr({\n          align: a.position.align,\n          zIndex: 8\n        }).css(a.style).add().align(a.position), this.credits.update = function (a) {\n          b.credits = b.credits.destroy();\n          b.addCredits(a);\n        });\n      },\n      destroy: function destroy() {\n        var b = this,\n            c = b.axes,\n            g = b.series,\n            f = b.container,\n            n,\n            e = f && f.parentNode;\n        d(b, \"destroy\");\n        b.renderer.forExport ? a.erase(u, b) : u[b.index] = void 0;\n        a.chartCount--;\n        b.renderTo.removeAttribute(\"data-highcharts-chart\");\n        M(b);\n\n        for (n = c.length; n--;) {\n          c[n] = c[n].destroy();\n        }\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (n = g.length; n--;) {\n          g[n] = g[n].destroy();\n        }\n\n        k(\"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \"), function (a) {\n          var c = b[a];\n          c && c.destroy && (b[a] = c.destroy());\n        });\n        f && (f.innerHTML = \"\", M(f), e && p(f));\n        H(b, function (a, c) {\n          delete b[c];\n        });\n      },\n      firstRender: function firstRender() {\n        var a = this,\n            b = a.options;\n\n        if (!a.isReadyToRender || a.isReadyToRender()) {\n          a.getContainer();\n          a.resetMargins();\n          a.setChartSize();\n          a.propFromSeries();\n          a.getAxes();\n          k(b.series || [], function (b) {\n            a.initSeries(b);\n          });\n          a.linkSeries();\n          d(a, \"beforeRender\");\n          n && (a.pointer = new n(a, b));\n          a.render();\n          if (!a.renderer.imgCount && a.onload) a.onload();\n          a.temporaryDisplay(!0);\n        }\n      },\n      onload: function onload() {\n        k([this.callback].concat(this.callbacks), function (a) {\n          a && void 0 !== this.index && a.apply(this, [this]);\n        }, this);\n        d(this, \"load\");\n        d(this, \"render\");\n        c(this.index) && this.setReflow(this.options.chart.reflow);\n        this.onload = null;\n      }\n    });\n  })(K);\n\n  (function (a) {\n    var C = a.addEvent,\n        E = a.Chart,\n        F = a.each;\n    C(E, \"afterSetChartSize\", function (m) {\n      var h = this.options.chart.scrollablePlotArea;\n      (h = h && h.minWidth) && !this.renderer.forExport && (this.scrollablePixels = h = Math.max(0, h - this.chartWidth)) && (this.plotWidth += h, this.clipBox.width += h, m.skipAxes || F(this.axes, function (e) {\n        1 === e.side ? e.getPlotLinePath = function () {\n          var h = this.right,\n              m;\n          this.right = h - e.chart.scrollablePixels;\n          m = a.Axis.prototype.getPlotLinePath.apply(this, arguments);\n          this.right = h;\n          return m;\n        } : (e.setAxisSize(), e.setAxisTranslation());\n      }));\n    });\n    C(E, \"render\", function () {\n      this.scrollablePixels ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n\n    E.prototype.setUpScrolling = function () {\n      this.scrollingContainer = a.createElement(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, {\n        overflowX: \"auto\",\n        WebkitOverflowScrolling: \"touch\"\n      }, this.renderTo);\n      this.innerContainer = a.createElement(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n\n    E.prototype.applyFixed = function () {\n      var m = this.container,\n          h,\n          e,\n          t = !this.fixedDiv;\n      t && (this.fixedDiv = a.createElement(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: 2\n      }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.fixedRenderer = h = new a.Renderer(this.fixedDiv, 0, 0), this.scrollableMask = h.path().attr({\n        fill: a.color(this.options.chart.backgroundColor || \"#fff\").setOpacity(.85).get(),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), a.each([this.inverted ? \".highcharts-xaxis\" : \".highcharts-yaxis\", this.inverted ? \".highcharts-xaxis-labels\" : \".highcharts-yaxis-labels\", \".highcharts-contextbutton\", \".highcharts-credits\", \".highcharts-legend\", \".highcharts-subtitle\", \".highcharts-title\", \".highcharts-legend-checkbox\"], function (e) {\n        a.each(m.querySelectorAll(e), function (a) {\n          (a.namespaceURI === h.SVG_NS ? h.box : h.box.parentNode).appendChild(a);\n          a.style.pointerEvents = \"auto\";\n        });\n      }));\n      this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      e = this.chartWidth + this.scrollablePixels;\n      a.stop(this.container);\n      this.container.style.width = e + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: e,\n        height: this.chartHeight,\n        viewBox: [0, 0, e, this.chartHeight].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: e\n      });\n      t && (e = this.options.chart.scrollablePlotArea, e.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixels * e.scrollPositionX));\n      t = this.axisOffset;\n      e = this.plotTop - t[0] - 1;\n      var t = this.plotTop + this.plotHeight + t[2],\n          x = this.plotLeft + this.plotWidth - this.scrollablePixels;\n      this.scrollableMask.attr({\n        d: this.scrollablePixels ? [\"M\", 0, e, \"L\", this.plotLeft - 1, e, \"L\", this.plotLeft - 1, t, \"L\", 0, t, \"Z\", \"M\", x, e, \"L\", this.chartWidth, e, \"L\", this.chartWidth, t, \"L\", x, t, \"Z\"] : [\"M\", 0, 0]\n      });\n    };\n  })(K);\n\n  (function (a) {\n    var C,\n        E = a.each,\n        F = a.extend,\n        m = a.erase,\n        h = a.fireEvent,\n        e = a.format,\n        t = a.isArray,\n        x = a.isNumber,\n        p = a.pick,\n        u = a.removeEvent;\n\n    a.Point = C = function C() {};\n\n    a.Point.prototype = {\n      init: function init(a, c, e) {\n        this.series = a;\n        this.color = a.color;\n        this.applyOptions(c, e);\n        a.options.colorByPoint ? (c = a.options.colors || a.chart.options.colors, this.color = this.color || c[a.colorCounter], c = c.length, e = a.colorCounter, a.colorCounter++, a.colorCounter === c && (a.colorCounter = 0)) : e = a.colorIndex;\n        this.colorIndex = p(this.colorIndex, e);\n        a.chart.pointCount++;\n        h(this, \"afterInit\");\n        return this;\n      },\n      applyOptions: function applyOptions(a, c) {\n        var f = this.series,\n            e = f.options.pointValKey || f.pointValKey;\n        a = C.prototype.optionsToObject.call(this, a);\n        F(this, a);\n        this.options = this.options ? F(this.options, a) : a;\n        a.group && delete this.group;\n        e && (this.y = this[e]);\n        this.isNull = p(this.isValid && !this.isValid(), null === this.x || !x(this.y, !0));\n        this.selected && (this.state = \"select\");\n        \"name\" in this && void 0 === c && f.xAxis && f.xAxis.hasNames && (this.x = f.xAxis.nameToX(this));\n        void 0 === this.x && f && (this.x = void 0 === c ? f.autoIncrement(this) : c);\n        return this;\n      },\n      setNestedProperty: function setNestedProperty(f, c, e) {\n        e = e.split(\".\");\n        a.reduce(e, function (f, e, d, b) {\n          f[e] = b.length - 1 === d ? c : a.isObject(f[e], !0) ? f[e] : {};\n          return f[e];\n        }, f);\n        return f;\n      },\n      optionsToObject: function optionsToObject(f) {\n        var c = {},\n            e = this.series,\n            h = e.options.keys,\n            l = h || e.pointArrayMap || [\"y\"],\n            d = l.length,\n            b = 0,\n            m = 0;\n        if (x(f) || null === f) c[l[0]] = f;else if (t(f)) for (!h && f.length > d && (e = typeof f[0], \"string\" === e ? c.name = f[0] : \"number\" === e && (c.x = f[0]), b++); m < d;) {\n          h && void 0 === f[b] || (0 < l[m].indexOf(\".\") ? a.Point.prototype.setNestedProperty(c, f[b], l[m]) : c[l[m]] = f[b]), b++, m++;\n        } else \"object\" === typeof f && (c = f, f.dataLabels && (e._hasPointLabels = !0), f.marker && (e._hasPointMarkers = !0));\n        return c;\n      },\n      getClassName: function getClassName() {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      },\n      getZone: function getZone() {\n        var a = this.series,\n            c = a.zones,\n            a = a.zoneAxis || \"y\",\n            e = 0,\n            h;\n\n        for (h = c[e]; this[a] >= h.value;) {\n          h = c[++e];\n        }\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = h && h.color && !this.options.color ? h.color : this.nonZonedColor;\n        return h;\n      },\n      destroy: function destroy() {\n        var a = this.series.chart,\n            c = a.hoverPoints,\n            e;\n        a.pointCount--;\n        c && (this.setState(), m(c, this), c.length || (a.hoverPoints = null));\n        if (this === a.hoverPoint) this.onMouseOut();\n        if (this.graphic || this.dataLabel) u(this), this.destroyElements();\n        this.legendItem && a.legend.destroyItem(this);\n\n        for (e in this) {\n          this[e] = null;\n        }\n      },\n      destroyElements: function destroyElements() {\n        for (var a = [\"graphic\", \"dataLabel\", \"dataLabelUpper\", \"connector\", \"shadowGroup\"], c, e = 6; e--;) {\n          c = a[e], this[c] && (this[c] = this[c].destroy());\n        }\n      },\n      getLabelConfig: function getLabelConfig() {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      },\n      tooltipFormatter: function tooltipFormatter(a) {\n        var c = this.series,\n            f = c.tooltipOptions,\n            h = p(f.valueDecimals, \"\"),\n            l = f.valuePrefix || \"\",\n            d = f.valueSuffix || \"\";\n        E(c.pointArrayMap || [\"y\"], function (b) {\n          b = \"{point.\" + b;\n          if (l || d) a = a.replace(RegExp(b + \"}\", \"g\"), l + b + \"}\" + d);\n          a = a.replace(RegExp(b + \"}\", \"g\"), b + \":,.\" + h + \"f}\");\n        });\n        return e(a, {\n          point: this,\n          series: this.series\n        }, c.chart.time);\n      },\n      firePointEvent: function firePointEvent(a, c, e) {\n        var f = this,\n            k = this.series.options;\n        (k.point.events[a] || f.options && f.options.events && f.options.events[a]) && this.importEvents();\n        \"click\" === a && k.allowPointSelect && (e = function e(a) {\n          f.select && f.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });\n        h(this, a, c, e);\n      },\n      visible: !0\n    };\n  })(K);\n\n  (function (a) {\n    var C = a.addEvent,\n        E = a.animObject,\n        F = a.arrayMax,\n        m = a.arrayMin,\n        h = a.correctFloat,\n        e = a.defaultOptions,\n        t = a.defaultPlotOptions,\n        x = a.defined,\n        p = a.each,\n        u = a.erase,\n        f = a.extend,\n        c = a.fireEvent,\n        k = a.grep,\n        r = a.isArray,\n        l = a.isNumber,\n        d = a.isString,\n        b = a.merge,\n        v = a.objectEach,\n        q = a.pick,\n        I = a.removeEvent,\n        w = a.splat,\n        L = a.SVGElement,\n        B = a.syncTimeout,\n        H = a.win;\n    a.Series = a.seriesType(\"line\", null, {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        lineWidth: 0,\n        lineColor: \"#ffffff\",\n        enabledThreshold: 2,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        align: \"center\",\n        formatter: function formatter() {\n          return null === this.y ? \"\" : a.numberFormat(this.y, -1);\n        },\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        padding: 5\n      },\n      cropThreshold: 300,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {}\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    }, {\n      isCartesian: !0,\n      pointClass: a.Point,\n      sorted: !0,\n      requireSorting: !0,\n      directTouch: !1,\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      colorCounter: 0,\n      parallelArrays: [\"x\", \"y\"],\n      coll: \"series\",\n      init: function init(a, b) {\n        var d = this,\n            n,\n            e = a.series,\n            g;\n        d.chart = a;\n        d.options = b = d.setOptions(b);\n        d.linkedSeries = [];\n        d.bindAxes();\n        f(d, {\n          name: b.name,\n          state: \"\",\n          visible: !1 !== b.visible,\n          selected: !0 === b.selected\n        });\n        n = b.events;\n        v(n, function (a, b) {\n          C(d, b, a);\n        });\n        if (n && n.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;\n        d.getColor();\n        d.getSymbol();\n        p(d.parallelArrays, function (a) {\n          d[a + \"Data\"] = [];\n        });\n        d.setData(b.data, !1);\n        d.isCartesian && (a.hasCartesianSeries = !0);\n        e.length && (g = e[e.length - 1]);\n        d._i = q(g && g._i, -1) + 1;\n        a.orderSeries(this.insert(e));\n        c(this, \"afterInit\");\n      },\n      insert: function insert(a) {\n        var b = this.options.index,\n            c;\n\n        if (l(b)) {\n          for (c = a.length; c--;) {\n            if (b >= q(a[c].options.index, a[c]._i)) {\n              a.splice(c + 1, 0, this);\n              break;\n            }\n          }\n\n          -1 === c && a.unshift(this);\n          c += 1;\n        } else a.push(this);\n\n        return q(c, a.length - 1);\n      },\n      bindAxes: function bindAxes() {\n        var b = this,\n            c = b.options,\n            d = b.chart,\n            f;\n        p(b.axisTypes || [], function (n) {\n          p(d[n], function (a) {\n            f = a.options;\n            if (c[n] === f.index || void 0 !== c[n] && c[n] === f.id || void 0 === c[n] && 0 === f.index) b.insert(a.series), b[n] = a, a.isDirty = !0;\n          });\n          b[n] || b.optionalAxis === n || a.error(18, !0);\n        });\n      },\n      updateParallelArrays: function updateParallelArrays(a, b) {\n        var c = a.series,\n            d = arguments,\n            f = l(b) ? function (d) {\n          var g = \"y\" === d && c.toYData ? c.toYData(a) : a[d];\n          c[d + \"Data\"][b] = g;\n        } : function (a) {\n          Array.prototype[b].apply(c[a + \"Data\"], Array.prototype.slice.call(d, 2));\n        };\n        p(c.parallelArrays, f);\n      },\n      autoIncrement: function autoIncrement() {\n        var a = this.options,\n            b = this.xIncrement,\n            c,\n            d = a.pointIntervalUnit,\n            f = this.chart.time,\n            b = q(b, a.pointStart, 0);\n        this.pointInterval = c = q(this.pointInterval, a.pointInterval, 1);\n        d && (a = new f.Date(b), \"day\" === d ? f.set(\"Date\", a, f.get(\"Date\", a) + c) : \"month\" === d ? f.set(\"Month\", a, f.get(\"Month\", a) + c) : \"year\" === d && f.set(\"FullYear\", a, f.get(\"FullYear\", a) + c), c = a.getTime() - b);\n        this.xIncrement = b + c;\n        return b;\n      },\n      setOptions: function setOptions(a) {\n        var d = this.chart,\n            f = d.options,\n            n = f.plotOptions,\n            k = (d.userOptions || {}).plotOptions || {},\n            g = n[this.type];\n        this.userOptions = a;\n        d = b(g, n.series, a);\n        this.tooltipOptions = b(e.tooltip, e.plotOptions.series && e.plotOptions.series.tooltip, e.plotOptions[this.type].tooltip, f.tooltip.userOptions, n.series && n.series.tooltip, n[this.type].tooltip, a.tooltip);\n        this.stickyTracking = q(a.stickyTracking, k[this.type] && k[this.type].stickyTracking, k.series && k.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : d.stickyTracking);\n        null === g.marker && delete d.marker;\n        this.zoneAxis = d.zoneAxis;\n        a = this.zones = (d.zones || []).slice();\n        !d.negativeColor && !d.negativeFillColor || d.zones || a.push({\n          value: d[this.zoneAxis + \"Threshold\"] || d.threshold || 0,\n          className: \"highcharts-negative\",\n          color: d.negativeColor,\n          fillColor: d.negativeFillColor\n        });\n        a.length && x(a[a.length - 1].value) && a.push({\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        c(this, \"afterSetOptions\", {\n          options: d\n        });\n        return d;\n      },\n      getName: function getName() {\n        return this.name || \"Series \" + (this.index + 1);\n      },\n      getCyclic: function getCyclic(a, b, c) {\n        var d,\n            f = this.chart,\n            g = this.userOptions,\n            n = a + \"Index\",\n            e = a + \"Counter\",\n            k = c ? c.length : q(f.options.chart[a + \"Count\"], f[a + \"Count\"]);\n        b || (d = q(g[n], g[\"_\" + n]), x(d) || (f.series.length || (f[e] = 0), g[\"_\" + n] = d = f[e] % k, f[e] += 1), c && (b = c[d]));\n        void 0 !== d && (this[n] = d);\n        this[a] = b;\n      },\n      getColor: function getColor() {\n        this.options.colorByPoint ? this.options.color = null : this.getCyclic(\"color\", this.options.color || t[this.type].color, this.chart.options.colors);\n      },\n      getSymbol: function getSymbol() {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker,\n      updateData: function updateData(b) {\n        var c = this.options,\n            d = this.points,\n            f = [],\n            n,\n            g,\n            e,\n            k = this.requireSorting;\n        p(b, function (b) {\n          var g;\n          g = a.defined(b) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, b).x;\n          l(g) && (g = a.inArray(g, this.xData, e), -1 === g || d[g].touched ? f.push(b) : b !== c.data[g] ? (d[g].update(b, !1, null, !1), d[g].touched = !0, k && (e = g + 1)) : d[g] && (d[g].touched = !0), n = !0);\n        }, this);\n        if (n) for (b = d.length; b--;) {\n          g = d[b], g.touched || g.remove(!1), g.touched = !1;\n        } else if (b.length === d.length) p(b, function (a, b) {\n          d[b].update && a !== c.data[b] && d[b].update(a, !1, null, !1);\n        });else return !1;\n        p(f, function (a) {\n          this.addPoint(a, !1);\n        }, this);\n        return !0;\n      },\n      setData: function setData(b, c, f, e) {\n        var n = this,\n            g = n.points,\n            k = g && g.length || 0,\n            h,\n            A = n.options,\n            D = n.chart,\n            m = null,\n            w = n.xAxis,\n            B = A.turboThreshold,\n            v = this.xData,\n            t = this.yData,\n            u = (h = n.pointArrayMap) && h.length,\n            H;\n        b = b || [];\n        h = b.length;\n        c = q(c, !0);\n        !1 !== e && h && k && !n.cropped && !n.hasGroupedData && n.visible && !n.isSeriesBoosting && (H = this.updateData(b));\n\n        if (!H) {\n          n.xIncrement = null;\n          n.colorCounter = 0;\n          p(this.parallelArrays, function (a) {\n            n[a + \"Data\"].length = 0;\n          });\n\n          if (B && h > B) {\n            for (f = 0; null === m && f < h;) {\n              m = b[f], f++;\n            }\n\n            if (l(m)) for (f = 0; f < h; f++) {\n              v[f] = this.autoIncrement(), t[f] = b[f];\n            } else if (r(m)) {\n              if (u) for (f = 0; f < h; f++) {\n                m = b[f], v[f] = m[0], t[f] = m.slice(1, u + 1);\n              } else for (f = 0; f < h; f++) {\n                m = b[f], v[f] = m[0], t[f] = m[1];\n              }\n            } else a.error(12);\n          } else for (f = 0; f < h; f++) {\n            void 0 !== b[f] && (m = {\n              series: n\n            }, n.pointClass.prototype.applyOptions.apply(m, [b[f]]), n.updateParallelArrays(m, f));\n          }\n\n          t && d(t[0]) && a.error(14, !0);\n          n.data = [];\n          n.options.data = n.userOptions.data = b;\n\n          for (f = k; f--;) {\n            g[f] && g[f].destroy && g[f].destroy();\n          }\n\n          w && (w.minRange = w.userMinRange);\n          n.isDirty = D.isDirtyBox = !0;\n          n.isDirtyData = !!g;\n          f = !1;\n        }\n\n        \"point\" === A.legendType && (this.processData(), this.generatePoints());\n        c && D.redraw(f);\n      },\n      processData: function processData(b) {\n        var c = this.xData,\n            d = this.yData,\n            f = c.length,\n            n;\n        n = 0;\n        var g,\n            e,\n            k = this.xAxis,\n            h,\n            l = this.options;\n        h = l.cropThreshold;\n        var r = this.getExtremesFromAll || l.getExtremesFromAll,\n            m = this.isCartesian,\n            l = k && k.val2lin,\n            q = k && k.isLog,\n            w = this.requireSorting,\n            B,\n            p;\n        if (m && !this.isDirty && !k.isDirty && !this.yAxis.isDirty && !b) return !1;\n        k && (b = k.getExtremes(), B = b.min, p = b.max);\n        m && this.sorted && !r && (!h || f > h || this.forceCrop) && (c[f - 1] < B || c[0] > p ? (c = [], d = []) : this.yData && (c[0] < B || c[f - 1] > p) && (n = this.cropData(this.xData, this.yData, B, p), c = n.xData, d = n.yData, n = n.start, g = !0));\n\n        for (h = c.length || 1; --h;) {\n          f = q ? l(c[h]) - l(c[h - 1]) : c[h] - c[h - 1], 0 < f && (void 0 === e || f < e) ? e = f : 0 > f && w && (a.error(15), w = !1);\n        }\n\n        this.cropped = g;\n        this.cropStart = n;\n        this.processedXData = c;\n        this.processedYData = d;\n        this.closestPointRange = e;\n      },\n      cropData: function cropData(a, b, c, d, f) {\n        var g = a.length,\n            n = 0,\n            e = g,\n            k;\n        f = q(f, this.cropShoulder, 1);\n\n        for (k = 0; k < g; k++) {\n          if (a[k] >= c) {\n            n = Math.max(0, k - f);\n            break;\n          }\n        }\n\n        for (c = k; c < g; c++) {\n          if (a[c] > d) {\n            e = c + f;\n            break;\n          }\n        }\n\n        return {\n          xData: a.slice(n, e),\n          yData: b.slice(n, e),\n          start: n,\n          end: e\n        };\n      },\n      generatePoints: function generatePoints() {\n        var a = this.options,\n            b = a.data,\n            c = this.data,\n            d,\n            e = this.processedXData,\n            g = this.processedYData,\n            k = this.pointClass,\n            h = e.length,\n            l = this.cropStart || 0,\n            r,\n            m = this.hasGroupedData,\n            a = a.keys,\n            q,\n            B = [],\n            p;\n        c || m || (c = [], c.length = b.length, c = this.data = c);\n        a && m && (this.options.keys = !1);\n\n        for (p = 0; p < h; p++) {\n          r = l + p, m ? (q = new k().init(this, [e[p]].concat(w(g[p]))), q.dataGroup = this.groupMap[p], q.dataGroup.options && (q.options = q.dataGroup.options, f(q, q.dataGroup.options))) : (q = c[r]) || void 0 === b[r] || (c[r] = q = new k().init(this, b[r], e[p])), q && (q.index = r, B[p] = q);\n        }\n\n        this.options.keys = a;\n        if (c && (h !== (d = c.length) || m)) for (p = 0; p < d; p++) {\n          p !== l || m || (p += h), c[p] && (c[p].destroyElements(), c[p].plotX = void 0);\n        }\n        this.data = c;\n        this.points = B;\n      },\n      getExtremes: function getExtremes(a) {\n        var b = this.yAxis,\n            c = this.processedXData,\n            d,\n            f = [],\n            g = 0;\n        d = this.xAxis.getExtremes();\n        var n = d.min,\n            e = d.max,\n            k,\n            h,\n            q = this.requireSorting ? 1 : 0,\n            w,\n            B;\n        a = a || this.stackedYData || this.processedYData || [];\n        d = a.length;\n\n        for (B = 0; B < d; B++) {\n          if (h = c[B], w = a[B], k = (l(w, !0) || r(w)) && (!b.positiveValuesOnly || w.length || 0 < w), h = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (c[B + q] || h) >= n && (c[B - q] || h) <= e, k && h) if (k = w.length) for (; k--;) {\n            \"number\" === typeof w[k] && (f[g++] = w[k]);\n          } else f[g++] = w;\n        }\n\n        this.dataMin = m(f);\n        this.dataMax = F(f);\n      },\n      translate: function translate() {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var a = this.options,\n            b = a.stacking,\n            d = this.xAxis,\n            f = d.categories,\n            e = this.yAxis,\n            g = this.points,\n            k = g.length,\n            r = !!this.modifyValue,\n            m = a.pointPlacement,\n            w = \"between\" === m || l(m),\n            B = a.threshold,\n            p = a.startFromThreshold ? B : 0,\n            v,\n            t,\n            u,\n            H,\n            I = Number.MAX_VALUE;\n        \"between\" === m && (m = .5);\n        l(m) && (m *= q(a.pointRange || d.pointRange));\n\n        for (a = 0; a < k; a++) {\n          var L = g[a],\n              C = L.x,\n              E = L.y;\n          t = L.low;\n          var F = b && e.stacks[(this.negStacks && E < (p ? 0 : B) ? \"-\" : \"\") + this.stackKey],\n              K;\n          e.positiveValuesOnly && null !== E && 0 >= E && (L.isNull = !0);\n          L.plotX = v = h(Math.min(Math.max(-1E5, d.translate(C, 0, 0, 0, 1, m, \"flags\" === this.type)), 1E5));\n          b && this.visible && !L.isNull && F && F[C] && (H = this.getStackIndicator(H, C, this.index), K = F[C], E = K.points[H.key], t = E[0], E = E[1], t === p && H.key === F[C].base && (t = q(l(B) && B, e.min)), e.positiveValuesOnly && 0 >= t && (t = null), L.total = L.stackTotal = K.total, L.percentage = K.total && L.y / K.total * 100, L.stackY = E, K.setOffset(this.pointXOffset || 0, this.barW || 0));\n          L.yBottom = x(t) ? Math.min(Math.max(-1E5, e.translate(t, 0, 1, 0, 1)), 1E5) : null;\n          r && (E = this.modifyValue(E, L));\n          L.plotY = t = \"number\" === typeof E && Infinity !== E ? Math.min(Math.max(-1E5, e.translate(E, 0, 1, 0, 1)), 1E5) : void 0;\n          L.isInside = void 0 !== t && 0 <= t && t <= e.len && 0 <= v && v <= d.len;\n          L.clientX = w ? h(d.translate(C, 0, 0, 0, 1, m)) : v;\n          L.negative = L.y < (B || 0);\n          L.category = f && void 0 !== f[L.x] ? f[L.x] : L.x;\n          L.isNull || (void 0 !== u && (I = Math.min(I, Math.abs(v - u))), u = v);\n          L.zone = this.zones.length && L.getZone();\n        }\n\n        this.closestPointRangePx = I;\n        c(this, \"afterTranslate\");\n      },\n      getValidPoints: function getValidPoints(a, b) {\n        var c = this.chart;\n        return k(a || this.points || [], function (a) {\n          return b && !c.isInsidePlot(a.plotX, a.plotY, c.inverted) ? !1 : !a.isNull;\n        });\n      },\n      setClip: function setClip(a) {\n        var b = this.chart,\n            c = this.options,\n            d = b.renderer,\n            f = b.inverted,\n            g = this.clipBox,\n            e = g || b.clipBox,\n            n = this.sharedClipKey || [\"_sharedClip\", a && a.duration, a && a.easing, e.height, c.xAxis, c.yAxis].join(),\n            k = b[n],\n            h = b[n + \"m\"];\n        k || (a && (e.width = 0, f && (e.x = b.plotSizeX), b[n + \"m\"] = h = d.clipRect(f ? b.plotSizeX + 99 : -99, f ? -b.plotLeft : -b.plotTop, 99, f ? b.chartWidth : b.chartHeight)), b[n] = k = d.clipRect(e), k.count = {\n          length: 0\n        });\n        a && !k.count[this.index] && (k.count[this.index] = !0, k.count.length += 1);\n        !1 !== c.clip && (this.group.clip(a || g ? k : b.clipRect), this.markerGroup.clip(h), this.sharedClipKey = n);\n        a || (k.count[this.index] && (delete k.count[this.index], --k.count.length), 0 === k.count.length && n && b[n] && (g || (b[n] = b[n].destroy()), b[n + \"m\"] && (b[n + \"m\"] = b[n + \"m\"].destroy())));\n      },\n      animate: function animate(a) {\n        var b = this.chart,\n            c = E(this.options.animation),\n            d;\n        a ? this.setClip(c) : (d = this.sharedClipKey, (a = b[d]) && a.animate({\n          width: b.plotSizeX,\n          x: 0\n        }, c), b[d + \"m\"] && b[d + \"m\"].animate({\n          width: b.plotSizeX + 99,\n          x: 0\n        }, c), this.animate = null);\n      },\n      afterAnimate: function afterAnimate() {\n        this.setClip();\n        c(this, \"afterAnimate\");\n        this.finishedAnimating = !0;\n      },\n      drawPoints: function drawPoints() {\n        var a = this.points,\n            b = this.chart,\n            c,\n            d,\n            f,\n            g,\n            e = this.options.marker,\n            k,\n            h,\n            l,\n            r = this[this.specialGroup] || this.markerGroup,\n            m,\n            w = q(e.enabled, this.xAxis.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius);\n        if (!1 !== e.enabled || this._hasPointMarkers) for (c = 0; c < a.length; c++) {\n          d = a[c], g = d.graphic, k = d.marker || {}, h = !!d.marker, f = w && void 0 === k.enabled || k.enabled, l = d.isInside, f && !d.isNull ? (f = q(k.symbol, this.symbol), m = this.markerAttribs(d, d.selected && \"select\"), g ? g[l ? \"show\" : \"hide\"](!0).animate(m) : l && (0 < m.width || d.hasImage) && (d.graphic = g = b.renderer.symbol(f, m.x, m.y, m.width, m.height, h ? k : e).add(r)), g && g.attr(this.pointAttribs(d, d.selected && \"select\")), g && g.addClass(d.getClassName(), !0)) : g && (d.graphic = g.destroy());\n        }\n      },\n      markerAttribs: function markerAttribs(a, b) {\n        var c = this.options.marker,\n            d = a.marker || {},\n            f = d.symbol || c.symbol,\n            g = q(d.radius, c.radius);\n        b && (c = c.states[b], b = d.states && d.states[b], g = q(b && b.radius, c && c.radius, g + (c && c.radiusPlus || 0)));\n        a.hasImage = f && 0 === f.indexOf(\"url\");\n        a.hasImage && (g = 0);\n        a = {\n          x: Math.floor(a.plotX) - g,\n          y: a.plotY - g\n        };\n        g && (a.width = a.height = 2 * g);\n        return a;\n      },\n      pointAttribs: function pointAttribs(a, b) {\n        var c = this.options.marker,\n            d = a && a.options,\n            f = d && d.marker || {},\n            g = this.color,\n            e = d && d.color,\n            n = a && a.color,\n            d = q(f.lineWidth, c.lineWidth);\n        a = a && a.zone && a.zone.color;\n        g = e || a || n || g;\n        a = f.fillColor || c.fillColor || g;\n        g = f.lineColor || c.lineColor || g;\n        b && (c = c.states[b], b = f.states && f.states[b] || {}, d = q(b.lineWidth, c.lineWidth, d + q(b.lineWidthPlus, c.lineWidthPlus, 0)), a = b.fillColor || c.fillColor || a, g = b.lineColor || c.lineColor || g);\n        return {\n          stroke: g,\n          \"stroke-width\": d,\n          fill: a\n        };\n      },\n      destroy: function destroy() {\n        var b = this,\n            d = b.chart,\n            f = /AppleWebKit\\/533/.test(H.navigator.userAgent),\n            e,\n            k,\n            g = b.data || [],\n            h,\n            l;\n        c(b, \"destroy\");\n        I(b);\n        p(b.axisTypes || [], function (a) {\n          (l = b[a]) && l.series && (u(l.series, b), l.isDirty = l.forceRedraw = !0);\n        });\n        b.legendItem && b.chart.legend.destroyItem(b);\n\n        for (k = g.length; k--;) {\n          (h = g[k]) && h.destroy && h.destroy();\n        }\n\n        b.points = null;\n        a.clearTimeout(b.animationTimeout);\n        v(b, function (a, b) {\n          a instanceof L && !a.survive && (e = f && \"group\" === b ? \"hide\" : \"destroy\", a[e]());\n        });\n        d.hoverSeries === b && (d.hoverSeries = null);\n        u(d.series, b);\n        d.orderSeries();\n        v(b, function (a, c) {\n          delete b[c];\n        });\n      },\n      getGraphPath: function getGraphPath(a, b, c) {\n        var d = this,\n            f = d.options,\n            g = f.step,\n            e,\n            n = [],\n            k = [],\n            h;\n        a = a || d.points;\n        (e = a.reversed) && a.reverse();\n        (g = {\n          right: 1,\n          center: 2\n        }[g] || g && 3) && e && (g = 4 - g);\n        !f.connectNulls || b || c || (a = this.getValidPoints(a));\n        p(a, function (e, l) {\n          var m = e.plotX,\n              r = e.plotY,\n              q = a[l - 1];\n          (e.leftCliff || q && q.rightCliff) && !c && (h = !0);\n          e.isNull && !x(b) && 0 < l ? h = !f.connectNulls : e.isNull && !b ? h = !0 : (0 === l || h ? l = [\"M\", e.plotX, e.plotY] : d.getPointSpline ? l = d.getPointSpline(a, e, l) : g ? (l = 1 === g ? [\"L\", q.plotX, r] : 2 === g ? [\"L\", (q.plotX + m) / 2, q.plotY, \"L\", (q.plotX + m) / 2, r] : [\"L\", m, q.plotY], l.push(\"L\", m, r)) : l = [\"L\", m, r], k.push(e.x), g && (k.push(e.x), 2 === g && k.push(e.x)), n.push.apply(n, l), h = !1);\n        });\n        n.xMap = k;\n        return d.graphPath = n;\n      },\n      drawGraph: function drawGraph() {\n        var a = this,\n            b = this.options,\n            c = (this.gappedPath || this.getGraphPath).call(this),\n            d = [[\"graph\", \"highcharts-graph\", b.lineColor || this.color, b.dashStyle]],\n            d = a.getZonesGraphs(d);\n        p(d, function (d, f) {\n          var g = d[0],\n              e = a[g];\n          e ? (e.endX = a.preventGraphAnimation ? null : c.xMap, e.animate({\n            d: c\n          })) : c.length && (a[g] = a.chart.renderer.path(c).addClass(d[1]).attr({\n            zIndex: 1\n          }).add(a.group), e = {\n            stroke: d[2],\n            \"stroke-width\": b.lineWidth,\n            fill: a.fillGraph && a.color || \"none\"\n          }, d[3] ? e.dashstyle = d[3] : \"square\" !== b.linecap && (e[\"stroke-linecap\"] = e[\"stroke-linejoin\"] = \"round\"), e = a[g].attr(e).shadow(2 > f && b.shadow));\n          e && (e.startX = c.xMap, e.isArea = c.isArea);\n        });\n      },\n      getZonesGraphs: function getZonesGraphs(a) {\n        p(this.zones, function (b, c) {\n          a.push([\"zone-graph-\" + c, \"highcharts-graph highcharts-zone-graph-\" + c + \" \" + (b.className || \"\"), b.color || this.color, b.dashStyle || this.options.dashStyle]);\n        }, this);\n        return a;\n      },\n      applyZones: function applyZones() {\n        var a = this,\n            b = this.chart,\n            c = b.renderer,\n            d = this.zones,\n            f,\n            g,\n            e = this.clips || [],\n            k,\n            h = this.graph,\n            l = this.area,\n            m = Math.max(b.chartWidth, b.chartHeight),\n            r = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            w,\n            B,\n            v = b.inverted,\n            t,\n            H,\n            u,\n            x,\n            I = !1;\n        d.length && (h || l) && r && void 0 !== r.min && (B = r.reversed, t = r.horiz, h && !this.showLine && h.hide(), l && l.hide(), w = r.getExtremes(), p(d, function (d, n) {\n          f = B ? t ? b.plotWidth : 0 : t ? 0 : r.toPixels(w.min);\n          f = Math.min(Math.max(q(g, f), 0), m);\n          g = Math.min(Math.max(Math.round(r.toPixels(q(d.value, w.max), !0)), 0), m);\n          I && (f = g = r.toPixels(w.max));\n          H = Math.abs(f - g);\n          u = Math.min(f, g);\n          x = Math.max(f, g);\n          r.isXAxis ? (k = {\n            x: v ? x : u,\n            y: 0,\n            width: H,\n            height: m\n          }, t || (k.x = b.plotHeight - k.x)) : (k = {\n            x: 0,\n            y: v ? x : u,\n            width: m,\n            height: H\n          }, t && (k.y = b.plotWidth - k.y));\n          v && c.isVML && (k = r.isXAxis ? {\n            x: 0,\n            y: B ? u : x,\n            height: k.width,\n            width: b.chartWidth\n          } : {\n            x: k.y - b.plotLeft - b.spacingBox.x,\n            y: 0,\n            width: k.height,\n            height: b.chartHeight\n          });\n          e[n] ? e[n].animate(k) : (e[n] = c.clipRect(k), h && a[\"zone-graph-\" + n].clip(e[n]), l && a[\"zone-area-\" + n].clip(e[n]));\n          I = d.value > w.max;\n          a.resetZones && 0 === g && (g = void 0);\n        }), this.clips = e);\n      },\n      invertGroups: function invertGroups(a) {\n        function b() {\n          p([\"group\", \"markerGroup\"], function (b) {\n            c[b] && (d.renderer.isVML && c[b].attr({\n              width: c.yAxis.len,\n              height: c.xAxis.len\n            }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(a));\n          });\n        }\n\n        var c = this,\n            d = c.chart,\n            f;\n        c.xAxis && (f = C(d, \"resize\", b), C(c, \"destroy\", f), b(a), c.invertGroups = b);\n      },\n      plotGroup: function plotGroup(a, b, c, d, f) {\n        var g = this[a],\n            e = !g;\n        e && (this[a] = g = this.chart.renderer.g().attr({\n          zIndex: d || .1\n        }).add(f));\n        g.addClass(\"highcharts-\" + b + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (x(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (g.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        g.attr({\n          visibility: c\n        })[e ? \"attr\" : \"animate\"](this.getPlotBox());\n        return g;\n      },\n      getPlotBox: function getPlotBox() {\n        var a = this.chart,\n            b = this.xAxis,\n            c = this.yAxis;\n        a.inverted && (b = c, c = this.xAxis);\n        return {\n          translateX: b ? b.left : a.plotLeft,\n          translateY: c ? c.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      },\n      render: function render() {\n        var a = this,\n            b = a.chart,\n            d,\n            f = a.options,\n            e = !!a.animate && b.renderer.isSVG && E(f.animation).duration,\n            g = a.visible ? \"inherit\" : \"hidden\",\n            k = f.zIndex,\n            h = a.hasRendered,\n            l = b.seriesGroup,\n            r = b.inverted;\n        d = a.plotGroup(\"group\", \"series\", g, k, l);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", g, k, l);\n        e && a.animate(!0);\n        d.inverted = a.isCartesian ? r : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.drawDataLabels && a.drawDataLabels();\n        a.visible && a.drawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(r);\n        !1 === f.clip || a.sharedClipKey || h || d.clip(b.clipRect);\n        e && a.animate();\n        h || (a.animationTimeout = B(function () {\n          a.afterAnimate();\n        }, e));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n        c(a, \"afterRender\");\n      },\n      redraw: function redraw() {\n        var a = this.chart,\n            b = this.isDirty || this.isDirtyData,\n            c = this.group,\n            d = this.xAxis,\n            f = this.yAxis;\n        c && (a.inverted && c.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), c.animate({\n          translateX: q(d && d.left, a.plotLeft),\n          translateY: q(f && f.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        b && delete this.kdTree;\n      },\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      searchPoint: function searchPoint(a, b) {\n        var c = this.xAxis,\n            d = this.yAxis,\n            f = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: f ? c.len - a.chartY + c.pos : a.chartX - c.pos,\n          plotY: f ? d.len - a.chartX + d.pos : a.chartY - d.pos\n        }, b);\n      },\n      buildKDTree: function buildKDTree() {\n        function a(c, d, f) {\n          var g, e;\n          if (e = c && c.length) return g = b.kdAxisArray[d % f], c.sort(function (a, b) {\n            return a[g] - b[g];\n          }), e = Math.floor(e / 2), {\n            point: c[e],\n            left: a(c.slice(0, e), d + 1, f),\n            right: a(c.slice(e + 1), d + 1, f)\n          };\n        }\n\n        this.buildingKdTree = !0;\n        var b = this,\n            c = -1 < b.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete b.kdTree;\n        B(function () {\n          b.kdTree = a(b.getValidPoints(null, !b.directTouch), c, c);\n          b.buildingKdTree = !1;\n        }, b.options.kdNow ? 0 : 1);\n      },\n      searchKDTree: function searchKDTree(a, b) {\n        function c(a, b, k, h) {\n          var n = b.point,\n              l = d.kdAxisArray[k % h],\n              r,\n              m,\n              q = n;\n          m = x(a[f]) && x(n[f]) ? Math.pow(a[f] - n[f], 2) : null;\n          r = x(a[g]) && x(n[g]) ? Math.pow(a[g] - n[g], 2) : null;\n          r = (m || 0) + (r || 0);\n          n.dist = x(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n          n.distX = x(m) ? Math.sqrt(m) : Number.MAX_VALUE;\n          l = a[l] - n[l];\n          r = 0 > l ? \"left\" : \"right\";\n          m = 0 > l ? \"right\" : \"left\";\n          b[r] && (r = c(a, b[r], k + 1, h), q = r[e] < q[e] ? r : n);\n          b[m] && Math.sqrt(l * l) < q[e] && (a = c(a, b[m], k + 1, h), q = a[e] < q[e] ? a : q);\n          return q;\n        }\n\n        var d = this,\n            f = this.kdAxisArray[0],\n            g = this.kdAxisArray[1],\n            e = b ? \"distX\" : \"dist\";\n        b = -1 < d.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree();\n        if (this.kdTree) return c(a, this.kdTree, b, b);\n      }\n    });\n  })(K);\n\n  (function (a) {\n    var C = a.Axis,\n        E = a.Chart,\n        F = a.correctFloat,\n        m = a.defined,\n        h = a.destroyObjectProperties,\n        e = a.each,\n        t = a.format,\n        x = a.objectEach,\n        p = a.pick,\n        u = a.Series;\n\n    a.StackItem = function (a, c, e, h, l) {\n      var d = a.chart.inverted;\n      this.axis = a;\n      this.isNegative = e;\n      this.options = c;\n      this.x = h;\n      this.total = null;\n      this.points = {};\n      this.stack = l;\n      this.rightCliff = this.leftCliff = 0;\n      this.alignOptions = {\n        align: c.align || (d ? e ? \"left\" : \"right\" : \"center\"),\n        verticalAlign: c.verticalAlign || (d ? \"middle\" : e ? \"bottom\" : \"top\"),\n        y: p(c.y, d ? 4 : e ? 14 : -6),\n        x: p(c.x, d ? e ? -6 : 6 : 0)\n      };\n      this.textAlign = c.textAlign || (d ? e ? \"right\" : \"left\" : \"center\");\n    };\n\n    a.StackItem.prototype = {\n      destroy: function destroy() {\n        h(this, this.axis);\n      },\n      render: function render(a) {\n        var c = this.axis.chart,\n            f = this.options,\n            e = f.format,\n            e = e ? t(e, this, c.time) : f.formatter.call(this);\n        this.label ? this.label.attr({\n          text: e,\n          visibility: \"hidden\"\n        }) : this.label = c.renderer.text(e, null, null, f.useHTML).css(f.style).attr({\n          align: this.textAlign,\n          rotation: f.rotation,\n          visibility: \"hidden\"\n        }).add(a);\n        this.label.labelrank = c.plotHeight;\n      },\n      setOffset: function setOffset(a, c) {\n        var f = this.axis,\n            e = f.chart,\n            h = f.translate(f.usePercentage ? 100 : this.total, 0, 0, 0, 1),\n            d = f.translate(0),\n            d = m(h) && Math.abs(h - d);\n        a = e.xAxis[0].translate(this.x) + a;\n        f = m(h) && this.getStackBox(e, this, a, h, c, d, f);\n        (c = this.label) && f && (c.align(this.alignOptions, null, f), f = c.alignAttr, c[!1 === this.options.crop || e.isInsidePlot(f.x, f.y) ? \"show\" : \"hide\"](!0));\n      },\n      getStackBox: function getStackBox(a, c, e, h, l, d, b) {\n        var f = c.axis.reversed,\n            k = a.inverted;\n        a = b.height + b.pos - (k ? a.plotLeft : a.plotTop);\n        c = c.isNegative && !f || !c.isNegative && f;\n        return {\n          x: k ? c ? h : h - d : e,\n          y: k ? a - e - l : c ? a - h - d : a - h,\n          width: k ? d : l,\n          height: k ? l : d\n        };\n      }\n    };\n\n    E.prototype.getStacks = function () {\n      var a = this;\n      e(a.yAxis, function (a) {\n        a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks);\n      });\n      e(a.series, function (c) {\n        !c.options.stacking || !0 !== c.visible && !1 !== a.options.chart.ignoreHiddenSeries || (c.stackKey = c.type + p(c.options.stack, \"\"));\n      });\n    };\n\n    C.prototype.buildStacks = function () {\n      var a = this.series,\n          c = p(this.options.reversedStacks, !0),\n          e = a.length,\n          h;\n\n      if (!this.isXAxis) {\n        this.usePercentage = !1;\n\n        for (h = e; h--;) {\n          a[c ? h : e - h - 1].setStackedPoints();\n        }\n\n        for (h = 0; h < e; h++) {\n          a[h].modifyStacks();\n        }\n      }\n    };\n\n    C.prototype.renderStackTotals = function () {\n      var a = this.chart,\n          c = a.renderer,\n          e = this.stacks,\n          h = this.stackTotalGroup;\n      h || (this.stackTotalGroup = h = c.g(\"stack-labels\").attr({\n        visibility: \"visible\",\n        zIndex: 6\n      }).add());\n      h.translate(a.plotLeft, a.plotTop);\n      x(e, function (a) {\n        x(a, function (a) {\n          a.render(h);\n        });\n      });\n    };\n\n    C.prototype.resetStacks = function () {\n      var a = this,\n          c = a.stacks;\n      a.isXAxis || x(c, function (c) {\n        x(c, function (f, e) {\n          f.touched < a.stacksTouched ? (f.destroy(), delete c[e]) : (f.total = null, f.cumulative = null);\n        });\n      });\n    };\n\n    C.prototype.cleanStacks = function () {\n      var a;\n      this.isXAxis || (this.oldStacks && (a = this.stacks = this.oldStacks), x(a, function (a) {\n        x(a, function (a) {\n          a.cumulative = a.total;\n        });\n      }));\n    };\n\n    u.prototype.setStackedPoints = function () {\n      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var f = this.processedXData,\n            c = this.processedYData,\n            e = [],\n            h = c.length,\n            l = this.options,\n            d = l.threshold,\n            b = p(l.startFromThreshold && d, 0),\n            v = l.stack,\n            l = l.stacking,\n            q = this.stackKey,\n            t = \"-\" + q,\n            w = this.negStacks,\n            u = this.yAxis,\n            B = u.stacks,\n            H = u.oldStacks,\n            n,\n            D,\n            A,\n            x,\n            G,\n            g,\n            y;\n        u.stacksTouched += 1;\n\n        for (G = 0; G < h; G++) {\n          g = f[G], y = c[G], n = this.getStackIndicator(n, g, this.index), x = n.key, A = (D = w && y < (b ? 0 : d)) ? t : q, B[A] || (B[A] = {}), B[A][g] || (H[A] && H[A][g] ? (B[A][g] = H[A][g], B[A][g].total = null) : B[A][g] = new a.StackItem(u, u.options.stackLabels, D, g, v)), A = B[A][g], null !== y ? (A.points[x] = A.points[this.index] = [p(A.cumulative, b)], m(A.cumulative) || (A.base = x), A.touched = u.stacksTouched, 0 < n.index && !1 === this.singleStacks && (A.points[x][0] = A.points[this.index + \",\" + g + \",0\"][0])) : A.points[x] = A.points[this.index] = null, \"percent\" === l ? (D = D ? q : t, w && B[D] && B[D][g] ? (D = B[D][g], A.total = D.total = Math.max(D.total, A.total) + Math.abs(y) || 0) : A.total = F(A.total + (Math.abs(y) || 0))) : A.total = F(A.total + (y || 0)), A.cumulative = p(A.cumulative, b) + (y || 0), null !== y && (A.points[x].push(A.cumulative), e[G] = A.cumulative);\n        }\n\n        \"percent\" === l && (u.usePercentage = !0);\n        this.stackedYData = e;\n        u.oldStacks = {};\n      }\n    };\n\n    u.prototype.modifyStacks = function () {\n      var a = this,\n          c = a.stackKey,\n          h = a.yAxis.stacks,\n          m = a.processedXData,\n          l,\n          d = a.options.stacking;\n      a[d + \"Stacker\"] && e([c, \"-\" + c], function (b) {\n        for (var c = m.length, f, e; c--;) {\n          if (f = m[c], l = a.getStackIndicator(l, f, a.index, b), e = (f = h[b] && h[b][f]) && f.points[l.key]) a[d + \"Stacker\"](e, f, c);\n        }\n      });\n    };\n\n    u.prototype.percentStacker = function (a, c, e) {\n      c = c.total ? 100 / c.total : 0;\n      a[0] = F(a[0] * c);\n      a[1] = F(a[1] * c);\n      this.stackedYData[e] = a[1];\n    };\n\n    u.prototype.getStackIndicator = function (a, c, e, h) {\n      !m(a) || a.x !== c || h && a.key !== h ? a = {\n        x: c,\n        index: 0,\n        key: h\n      } : a.index++;\n      a.key = [e, c, a.index].join();\n      return a;\n    };\n  })(K);\n\n  (function (a) {\n    var C = a.addEvent,\n        E = a.animate,\n        F = a.Axis,\n        m = a.createElement,\n        h = a.css,\n        e = a.defined,\n        t = a.each,\n        x = a.erase,\n        p = a.extend,\n        u = a.fireEvent,\n        f = a.inArray,\n        c = a.isNumber,\n        k = a.isObject,\n        r = a.isArray,\n        l = a.merge,\n        d = a.objectEach,\n        b = a.pick,\n        v = a.Point,\n        q = a.Series,\n        I = a.seriesTypes,\n        w = a.setAnimation,\n        L = a.splat;\n    p(a.Chart.prototype, {\n      addSeries: function addSeries(a, c, d) {\n        var f,\n            e = this;\n        a && (c = b(c, !0), u(e, \"addSeries\", {\n          options: a\n        }, function () {\n          f = e.initSeries(a);\n          e.isDirtyLegend = !0;\n          e.linkSeries();\n          u(e, \"afterAddSeries\");\n          c && e.redraw(d);\n        }));\n        return f;\n      },\n      addAxis: function addAxis(a, c, d, f) {\n        var e = c ? \"xAxis\" : \"yAxis\",\n            h = this.options;\n        a = l(a, {\n          index: this[e].length,\n          isX: c\n        });\n        c = new F(this, a);\n        h[e] = L(h[e] || {});\n        h[e].push(a);\n        b(d, !0) && this.redraw(f);\n        return c;\n      },\n      showLoading: function showLoading(a) {\n        var b = this,\n            c = b.options,\n            d = b.loadingDiv,\n            f = c.loading,\n            e = function e() {\n          d && h(d, {\n            left: b.plotLeft + \"px\",\n            top: b.plotTop + \"px\",\n            width: b.plotWidth + \"px\",\n            height: b.plotHeight + \"px\"\n          });\n        };\n\n        d || (b.loadingDiv = d = m(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, b.container), b.loadingSpan = m(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, d), C(b, \"redraw\", e));\n        d.className = \"highcharts-loading\";\n        b.loadingSpan.innerHTML = a || c.lang.loading;\n        h(d, p(f.style, {\n          zIndex: 10\n        }));\n        h(b.loadingSpan, f.labelStyle);\n        b.loadingShown || (h(d, {\n          opacity: 0,\n          display: \"\"\n        }), E(d, {\n          opacity: f.style.opacity || .5\n        }, {\n          duration: f.showDuration || 0\n        }));\n        b.loadingShown = !0;\n        e();\n      },\n      hideLoading: function hideLoading() {\n        var a = this.options,\n            b = this.loadingDiv;\n        b && (b.className = \"highcharts-loading highcharts-loading-hidden\", E(b, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function complete() {\n            h(b, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      },\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \"),\n      update: function update(a, h, k, m) {\n        var n = this,\n            q = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\"\n        },\n            w = a.chart,\n            g,\n            r,\n            p = [];\n        u(n, \"update\", {\n          options: a\n        });\n\n        if (w) {\n          l(!0, n.options.chart, w);\n          \"className\" in w && n.setClassName(w.className);\n          \"reflow\" in w && n.setReflow(w.reflow);\n          if (\"inverted\" in w || \"polar\" in w || \"type\" in w) n.propFromSeries(), g = !0;\n          \"alignTicks\" in w && (g = !0);\n          d(w, function (a, b) {\n            -1 !== f(\"chart.\" + b, n.propsRequireUpdateSeries) && (r = !0);\n            -1 !== f(b, n.propsRequireDirtyBox) && (n.isDirtyBox = !0);\n          });\n          \"style\" in w && n.renderer.setStyle(w.style);\n        }\n\n        a.colors && (this.options.colors = a.colors);\n        a.plotOptions && l(!0, this.options.plotOptions, a.plotOptions);\n        d(a, function (a, b) {\n          if (n[b] && \"function\" === typeof n[b].update) n[b].update(a, !1);else if (\"function\" === typeof n[q[b]]) n[q[b]](a);\n          \"chart\" !== b && -1 !== f(b, n.propsRequireUpdateSeries) && (r = !0);\n        });\n        t(\"xAxis yAxis zAxis series colorAxis pane\".split(\" \"), function (b) {\n          var c;\n          a[b] && (\"series\" === b && (c = [], t(n[b], function (a, b) {\n            a.options.isInternal || c.push(b);\n          })), t(L(a[b]), function (a, d) {\n            (d = e(a.id) && n.get(a.id) || n[b][c ? c[d] : d]) && d.coll === b && (d.update(a, !1), k && (d.touched = !0));\n            if (!d && k) if (\"series\" === b) n.addSeries(a, !1).touched = !0;else if (\"xAxis\" === b || \"yAxis\" === b) n.addAxis(a, \"xAxis\" === b, !1).touched = !0;\n          }), k && t(n[b], function (a) {\n            a.touched || a.options.isInternal ? delete a.touched : p.push(a);\n          }));\n        });\n        t(p, function (a) {\n          a.remove(!1);\n        });\n        g && t(n.axes, function (a) {\n          a.update({}, !1);\n        });\n        r && t(n.series, function (a) {\n          a.update({}, !1);\n        });\n        a.loading && l(!0, n.options.loading, a.loading);\n        g = w && w.width;\n        w = w && w.height;\n        c(g) && g !== n.chartWidth || c(w) && w !== n.chartHeight ? n.setSize(g, w, m) : b(h, !0) && n.redraw(m);\n        u(n, \"afterUpdate\", {\n          options: a\n        });\n      },\n      setSubtitle: function setSubtitle(a) {\n        this.setTitle(void 0, a);\n      }\n    });\n    p(v.prototype, {\n      update: function update(a, c, d, f) {\n        function e() {\n          h.applyOptions(a);\n          null === h.y && g && (h.graphic = g.destroy());\n          k(a, !0) && (g && g.element && a && a.marker && void 0 !== a.marker.symbol && (h.graphic = g.destroy()), a && a.dataLabels && h.dataLabel && (h.dataLabel = h.dataLabel.destroy()), h.connector && (h.connector = h.connector.destroy()));\n          l = h.index;\n          n.updateParallelArrays(h, l);\n          w.data[l] = k(w.data[l], !0) || k(a, !0) ? h.options : b(a, w.data[l]);\n          n.isDirty = n.isDirtyData = !0;\n          !n.fixedBox && n.hasCartesianSeries && (m.isDirtyBox = !0);\n          \"point\" === w.legendType && (m.isDirtyLegend = !0);\n          c && m.redraw(d);\n        }\n\n        var h = this,\n            n = h.series,\n            g = h.graphic,\n            l,\n            m = n.chart,\n            w = n.options;\n        c = b(c, !0);\n        !1 === f ? e() : h.firePointEvent(\"update\", {\n          options: a\n        }, e);\n      },\n      remove: function remove(a, b) {\n        this.series.removePoint(f(this, this.series.data), a, b);\n      }\n    });\n    p(q.prototype, {\n      addPoint: function addPoint(a, c, d, f) {\n        var e = this.options,\n            h = this.data,\n            k = this.chart,\n            g = this.xAxis,\n            g = g && g.hasNames && g.names,\n            n = e.data,\n            l,\n            m,\n            w = this.xData,\n            q,\n            r;\n        c = b(c, !0);\n        l = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(l, [a]);\n        r = l.x;\n        q = w.length;\n        if (this.requireSorting && r < w[q - 1]) for (m = !0; q && w[q - 1] > r;) {\n          q--;\n        }\n        this.updateParallelArrays(l, \"splice\", q, 0, 0);\n        this.updateParallelArrays(l, q);\n        g && l.name && (g[r] = l.name);\n        n.splice(q, 0, a);\n        m && (this.data.splice(q, 0, null), this.processData());\n        \"point\" === e.legendType && this.generatePoints();\n        d && (h[0] && h[0].remove ? h[0].remove(!1) : (h.shift(), this.updateParallelArrays(l, \"shift\"), n.shift()));\n        this.isDirtyData = this.isDirty = !0;\n        c && k.redraw(f);\n      },\n      removePoint: function removePoint(a, c, d) {\n        var f = this,\n            e = f.data,\n            h = e[a],\n            k = f.points,\n            g = f.chart,\n            n = function n() {\n          k && k.length === e.length && k.splice(a, 1);\n          e.splice(a, 1);\n          f.options.data.splice(a, 1);\n          f.updateParallelArrays(h || {\n            series: f\n          }, \"splice\", a, 1);\n          h && h.destroy();\n          f.isDirty = !0;\n          f.isDirtyData = !0;\n          c && g.redraw();\n        };\n\n        w(d, g);\n        c = b(c, !0);\n        h ? h.firePointEvent(\"remove\", null, n) : n();\n      },\n      remove: function remove(a, c, d) {\n        function f() {\n          e.destroy();\n          h.isDirtyLegend = h.isDirtyBox = !0;\n          h.linkSeries();\n          b(a, !0) && h.redraw(c);\n        }\n\n        var e = this,\n            h = e.chart;\n        !1 !== d ? u(e, \"remove\", null, f) : f();\n      },\n      update: function update(c, d) {\n        var e = this,\n            h = e.chart,\n            k = e.userOptions,\n            m = e.oldType || e.type,\n            w = c.type || k.type || h.options.chart.type,\n            g = I[m].prototype,\n            q,\n            r = [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n            v = [\"navigatorSeries\", \"baseSeries\"],\n            B = e.finishedAnimating && {\n          animation: !1\n        },\n            x = [\"data\", \"name\", \"turboThreshold\"],\n            H = a.keys(c),\n            z = 0 < H.length;\n        t(H, function (a) {\n          -1 === f(a, x) && (z = !1);\n        });\n        if (z) c.data && this.setData(c.data, !1), c.name && this.setName(c.name, !1);else {\n          v = r.concat(v);\n          t(v, function (a) {\n            v[a] = e[a];\n            delete e[a];\n          });\n          c = l(k, B, {\n            index: e.index,\n            pointStart: b(k.pointStart, e.xData[0])\n          }, {\n            data: e.options.data\n          }, c);\n          e.remove(!1, null, !1);\n\n          for (q in g) {\n            e[q] = void 0;\n          }\n\n          I[w || m] ? p(e, I[w || m].prototype) : a.error(17, !0);\n          t(v, function (a) {\n            e[a] = v[a];\n          });\n          e.init(h, c);\n          c.zIndex !== k.zIndex && t(r, function (a) {\n            e[a] && e[a].attr({\n              zIndex: c.zIndex\n            });\n          });\n          e.oldType = m;\n          h.linkSeries();\n        }\n        u(this, \"afterUpdate\");\n        b(d, !0) && h.redraw(z ? void 0 : !1);\n      },\n      setName: function setName(a) {\n        this.name = this.options.name = this.userOptions.name = a;\n        this.chart.isDirtyLegend = !0;\n      }\n    });\n    p(F.prototype, {\n      update: function update(a, c) {\n        var f = this.chart,\n            e = a && a.events || {};\n        a = l(this.userOptions, a);\n        f.options[this.coll].indexOf && (f.options[this.coll][f.options[this.coll].indexOf(this.userOptions)] = a);\n        d(f.options[this.coll].events, function (a, b) {\n          \"undefined\" === typeof e[b] && (e[b] = void 0);\n        });\n        this.destroy(!0);\n        this.init(f, p(a, {\n          events: e\n        }));\n        f.isDirtyBox = !0;\n        b(c, !0) && f.redraw();\n      },\n      remove: function remove(a) {\n        for (var c = this.chart, d = this.coll, f = this.series, e = f.length; e--;) {\n          f[e] && f[e].remove(!1);\n        }\n\n        x(c.axes, this);\n        x(c[d], this);\n        r(c.options[d]) ? c.options[d].splice(this.options.index, 1) : delete c.options[d];\n        t(c[d], function (a, b) {\n          a.options.index = a.userOptions.index = b;\n        });\n        this.destroy();\n        c.isDirtyBox = !0;\n        b(a, !0) && c.redraw();\n      },\n      setTitle: function setTitle(a, b) {\n        this.update({\n          title: a\n        }, b);\n      },\n      setCategories: function setCategories(a, b) {\n        this.update({\n          categories: a\n        }, b);\n      }\n    });\n  })(K);\n\n  (function (a) {\n    var C = a.color,\n        E = a.each,\n        F = a.map,\n        m = a.pick,\n        h = a.Series,\n        e = a.seriesType;\n    e(\"area\", \"line\", {\n      softThreshold: !1,\n      threshold: 0\n    }, {\n      singleStacks: !1,\n      getStackPoints: function getStackPoints(e) {\n        var h = [],\n            p = [],\n            t = this.xAxis,\n            f = this.yAxis,\n            c = f.stacks[this.stackKey],\n            k = {},\n            r = this.index,\n            l = f.series,\n            d = l.length,\n            b,\n            v = m(f.options.reversedStacks, !0) ? 1 : -1,\n            q;\n        e = e || this.points;\n\n        if (this.options.stacking) {\n          for (q = 0; q < e.length; q++) {\n            e[q].leftNull = e[q].rightNull = null, k[e[q].x] = e[q];\n          }\n\n          a.objectEach(c, function (a, b) {\n            null !== a.total && p.push(b);\n          });\n          p.sort(function (a, b) {\n            return a - b;\n          });\n          b = F(l, function () {\n            return this.visible;\n          });\n          E(p, function (a, e) {\n            var l = 0,\n                m,\n                w;\n            if (k[a] && !k[a].isNull) h.push(k[a]), E([-1, 1], function (f) {\n              var h = 1 === f ? \"rightNull\" : \"leftNull\",\n                  n = 0,\n                  l = c[p[e + f]];\n              if (l) for (q = r; 0 <= q && q < d;) {\n                m = l.points[q], m || (q === r ? k[a][h] = !0 : b[q] && (w = c[a].points[q]) && (n -= w[1] - w[0])), q += v;\n              }\n              k[a][1 === f ? \"rightCliff\" : \"leftCliff\"] = n;\n            });else {\n              for (q = r; 0 <= q && q < d;) {\n                if (m = c[a].points[q]) {\n                  l = m[1];\n                  break;\n                }\n\n                q += v;\n              }\n\n              l = f.translate(l, 0, 1, 0, 1);\n              h.push({\n                isNull: !0,\n                plotX: t.translate(a, 0, 0, 0, 1),\n                x: a,\n                plotY: l,\n                yBottom: l\n              });\n            }\n          });\n        }\n\n        return h;\n      },\n      getGraphPath: function getGraphPath(a) {\n        var e = h.prototype.getGraphPath,\n            p = this.options,\n            t = p.stacking,\n            f = this.yAxis,\n            c,\n            k,\n            r = [],\n            l = [],\n            d = this.index,\n            b,\n            v = f.stacks[this.stackKey],\n            q = p.threshold,\n            I = f.getThreshold(p.threshold),\n            w,\n            p = p.connectNulls || \"percent\" === t,\n            L = function L(c, e, h) {\n          var k = a[c];\n          c = t && v[k.x].points[d];\n          var n = k[h + \"Null\"] || 0;\n          h = k[h + \"Cliff\"] || 0;\n          var m,\n              w,\n              k = !0;\n          h || n ? (m = (n ? c[0] : c[1]) + h, w = c[0] + h, k = !!n) : !t && a[e] && a[e].isNull && (m = w = q);\n          void 0 !== m && (l.push({\n            plotX: b,\n            plotY: null === m ? I : f.getThreshold(m),\n            isNull: k,\n            isCliff: !0\n          }), r.push({\n            plotX: b,\n            plotY: null === w ? I : f.getThreshold(w),\n            doCurve: !1\n          }));\n        };\n\n        a = a || this.points;\n        t && (a = this.getStackPoints(a));\n\n        for (c = 0; c < a.length; c++) {\n          if (k = a[c].isNull, b = m(a[c].rectPlotX, a[c].plotX), w = m(a[c].yBottom, I), !k || p) p || L(c, c - 1, \"left\"), k && !t && p || (l.push(a[c]), r.push({\n            x: c,\n            plotX: b,\n            plotY: w\n          })), p || L(c, c + 1, \"right\");\n        }\n\n        c = e.call(this, l, !0, !0);\n        r.reversed = !0;\n        k = e.call(this, r, !0, !0);\n        k.length && (k[0] = \"L\");\n        k = c.concat(k);\n        e = e.call(this, l, !1, p);\n        k.xMap = c.xMap;\n        this.areaPath = k;\n        return e;\n      },\n      drawGraph: function drawGraph() {\n        this.areaPath = [];\n        h.prototype.drawGraph.apply(this);\n        var a = this,\n            e = this.areaPath,\n            p = this.options,\n            u = [[\"area\", \"highcharts-area\", this.color, p.fillColor]];\n        E(this.zones, function (f, c) {\n          u.push([\"zone-area-\" + c, \"highcharts-area highcharts-zone-area-\" + c + \" \" + f.className, f.color || a.color, f.fillColor || p.fillColor]);\n        });\n        E(u, function (f) {\n          var c = f[0],\n              h = a[c];\n          h ? (h.endX = a.preventGraphAnimation ? null : e.xMap, h.animate({\n            d: e\n          })) : (h = a[c] = a.chart.renderer.path(e).addClass(f[1]).attr({\n            fill: m(f[3], C(f[2]).setOpacity(m(p.fillOpacity, .75)).get()),\n            zIndex: 0\n          }).add(a.group), h.isArea = !0);\n          h.startX = e.xMap;\n          h.shiftUnit = p.step ? 2 : 1;\n        });\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle\n    });\n  })(K);\n\n  (function (a) {\n    var C = a.pick;\n    a = a.seriesType;\n    a(\"spline\", \"line\", {}, {\n      getPointSpline: function getPointSpline(a, F, m) {\n        var h = F.plotX,\n            e = F.plotY,\n            t = a[m - 1];\n        m = a[m + 1];\n        var x, p, u, f;\n\n        if (t && !t.isNull && !1 !== t.doCurve && !F.isCliff && m && !m.isNull && !1 !== m.doCurve && !F.isCliff) {\n          a = t.plotY;\n          u = m.plotX;\n          m = m.plotY;\n          var c = 0;\n          x = (1.5 * h + t.plotX) / 2.5;\n          p = (1.5 * e + a) / 2.5;\n          u = (1.5 * h + u) / 2.5;\n          f = (1.5 * e + m) / 2.5;\n          u !== x && (c = (f - p) * (u - h) / (u - x) + e - f);\n          p += c;\n          f += c;\n          p > a && p > e ? (p = Math.max(a, e), f = 2 * e - p) : p < a && p < e && (p = Math.min(a, e), f = 2 * e - p);\n          f > m && f > e ? (f = Math.max(m, e), p = 2 * e - f) : f < m && f < e && (f = Math.min(m, e), p = 2 * e - f);\n          F.rightContX = u;\n          F.rightContY = f;\n        }\n\n        F = [\"C\", C(t.rightContX, t.plotX), C(t.rightContY, t.plotY), C(x, h), C(p, e), h, e];\n        t.rightContX = t.rightContY = null;\n        return F;\n      }\n    });\n  })(K);\n\n  (function (a) {\n    var C = a.seriesTypes.area.prototype,\n        E = a.seriesType;\n    E(\"areaspline\", \"spline\", a.defaultPlotOptions.area, {\n      getStackPoints: C.getStackPoints,\n      getGraphPath: C.getGraphPath,\n      drawGraph: C.drawGraph,\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle\n    });\n  })(K);\n\n  (function (a) {\n    var C = a.animObject,\n        E = a.color,\n        F = a.each,\n        m = a.extend,\n        h = a.isNumber,\n        e = a.merge,\n        t = a.pick,\n        x = a.Series,\n        p = a.seriesType,\n        u = a.svg;\n    p(\"column\", \"line\", {\n      borderRadius: 0,\n      crisp: !0,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: null,\n        verticalAlign: null,\n        y: null\n      },\n      softThreshold: !1,\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    }, {\n      cropShoulder: 0,\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      negStacks: !0,\n      init: function init() {\n        x.prototype.init.apply(this, arguments);\n        var a = this,\n            c = a.chart;\n        c.hasRendered && F(c.series, function (c) {\n          c.type === a.type && (c.isDirty = !0);\n        });\n      },\n      getColumnMetrics: function getColumnMetrics() {\n        var a = this,\n            c = a.options,\n            e = a.xAxis,\n            h = a.yAxis,\n            l = e.options.reversedStacks,\n            l = e.reversed && !l || !e.reversed && l,\n            d,\n            b = {},\n            m = 0;\n        !1 === c.grouping ? m = 1 : F(a.chart.series, function (c) {\n          var f = c.options,\n              e = c.yAxis,\n              k;\n          c.type !== a.type || !c.visible && a.chart.options.chart.ignoreHiddenSeries || h.len !== e.len || h.pos !== e.pos || (f.stacking ? (d = c.stackKey, void 0 === b[d] && (b[d] = m++), k = b[d]) : !1 !== f.grouping && (k = m++), c.columnIndex = k);\n        });\n        var q = Math.min(Math.abs(e.transA) * (e.ordinalSlope || c.pointRange || e.closestPointRange || e.tickInterval || 1), e.len),\n            p = q * c.groupPadding,\n            w = (q - 2 * p) / (m || 1),\n            c = Math.min(c.maxPointWidth || e.len, t(c.pointWidth, w * (1 - 2 * c.pointPadding)));\n        a.columnMetrics = {\n          width: c,\n          offset: (w - c) / 2 + (p + ((a.columnIndex || 0) + (l ? 1 : 0)) * w - q / 2) * (l ? -1 : 1)\n        };\n        return a.columnMetrics;\n      },\n      crispCol: function crispCol(a, c, e, h) {\n        var f = this.chart,\n            d = this.borderWidth,\n            b = -(d % 2 ? .5 : 0),\n            d = d % 2 ? .5 : 1;\n        f.inverted && f.renderer.isVML && (d += 1);\n        this.options.crisp && (e = Math.round(a + e) + b, a = Math.round(a) + b, e -= a);\n        h = Math.round(c + h) + d;\n        b = .5 >= Math.abs(c) && .5 < h;\n        c = Math.round(c) + d;\n        h -= c;\n        b && h && (--c, h += 1);\n        return {\n          x: a,\n          y: c,\n          width: e,\n          height: h\n        };\n      },\n      translate: function translate() {\n        var a = this,\n            c = a.chart,\n            e = a.options,\n            h = a.dense = 2 > a.closestPointRange * a.xAxis.transA,\n            h = a.borderWidth = t(e.borderWidth, h ? 0 : 1),\n            l = a.yAxis,\n            d = e.threshold,\n            b = a.translatedThreshold = l.getThreshold(d),\n            m = t(e.minPointLength, 5),\n            q = a.getColumnMetrics(),\n            p = q.width,\n            w = a.barW = Math.max(p, 1 + 2 * h),\n            u = a.pointXOffset = q.offset;\n        c.inverted && (b -= .5);\n        e.pointPadding && (w = Math.ceil(w));\n        x.prototype.translate.apply(a);\n        F(a.points, function (f) {\n          var e = t(f.yBottom, b),\n              h = 999 + Math.abs(e),\n              h = Math.min(Math.max(-h, f.plotY), l.len + h),\n              k = f.plotX + u,\n              q = w,\n              r = Math.min(h, e),\n              v,\n              g = Math.max(h, e) - r;\n          m && Math.abs(g) < m && (g = m, v = !l.reversed && !f.negative || l.reversed && f.negative, f.y === d && a.dataMax <= d && l.min < d && (v = !v), r = Math.abs(r - b) > m ? e - m : b - (v ? m : 0));\n          f.barX = k;\n          f.pointWidth = p;\n          f.tooltipPos = c.inverted ? [l.len + l.pos - c.plotLeft - h, a.xAxis.len - k - q / 2, g] : [k + q / 2, h + l.pos - c.plotTop, g];\n          f.shapeType = \"rect\";\n          f.shapeArgs = a.crispCol.apply(a, f.isNull ? [k, b, q, 0] : [k, r, q, g]);\n        });\n      },\n      getSymbol: a.noop,\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      drawGraph: function drawGraph() {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      },\n      pointAttribs: function pointAttribs(a, c) {\n        var f = this.options,\n            h,\n            l = this.pointAttrToOptions || {};\n        h = l.stroke || \"borderColor\";\n        var d = l[\"stroke-width\"] || \"borderWidth\",\n            b = a && a.color || this.color,\n            m = a && a[h] || f[h] || this.color || b,\n            q = a && a[d] || f[d] || this[d] || 0,\n            l = f.dashStyle;\n        a && this.zones.length && (b = a.getZone(), b = a.options.color || b && b.color || this.color);\n        c && (a = e(f.states[c], a.options.states && a.options.states[c] || {}), c = a.brightness, b = a.color || void 0 !== c && E(b).brighten(a.brightness).get() || b, m = a[h] || m, q = a[d] || q, l = a.dashStyle || l);\n        h = {\n          fill: b,\n          stroke: m,\n          \"stroke-width\": q\n        };\n        l && (h.dashstyle = l);\n        return h;\n      },\n      drawPoints: function drawPoints() {\n        var a = this,\n            c = this.chart,\n            k = a.options,\n            m = c.renderer,\n            l = k.animationLimit || 250,\n            d;\n        F(a.points, function (b) {\n          var f = b.graphic,\n              q = f && c.pointCount < l ? \"animate\" : \"attr\";\n\n          if (h(b.plotY) && null !== b.y) {\n            d = b.shapeArgs;\n            if (f) f[q](e(d));else b.graphic = f = m[b.shapeType](d).add(b.group || a.group);\n            k.borderRadius && f.attr({\n              r: k.borderRadius\n            });\n            f[q](a.pointAttribs(b, b.selected && \"select\")).shadow(k.shadow, null, k.stacking && !k.borderRadius);\n            f.addClass(b.getClassName(), !0);\n          } else f && (b.graphic = f.destroy());\n        });\n      },\n      animate: function animate(a) {\n        var c = this,\n            f = this.yAxis,\n            e = c.options,\n            h = this.chart.inverted,\n            d = {},\n            b = h ? \"translateX\" : \"translateY\",\n            p;\n        u && (a ? (d.scaleY = .001, a = Math.min(f.pos + f.len, Math.max(f.pos, f.toPixels(e.threshold))), h ? d.translateX = a - f.len : d.translateY = a, c.group.attr(d)) : (p = c.group.attr(b), c.group.animate({\n          scaleY: 1\n        }, m(C(c.options.animation), {\n          step: function step(a, e) {\n            d[b] = p + e.pos * (f.pos - p);\n            c.group.attr(d);\n          }\n        })), c.animate = null));\n      },\n      remove: function remove() {\n        var a = this,\n            c = a.chart;\n        c.hasRendered && F(c.series, function (c) {\n          c.type === a.type && (c.isDirty = !0);\n        });\n        x.prototype.remove.apply(a, arguments);\n      }\n    });\n  })(K);\n\n  (function (a) {\n    a = a.seriesType;\n    a(\"bar\", \"column\", null, {\n      inverted: !0\n    });\n  })(K);\n\n  (function (a) {\n    var C = a.Series;\n    a = a.seriesType;\n    a(\"scatter\", \"line\", {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> <span style=\\\"font-size: 0.85em\\\"> {series.name}</span><br/>\",\n        pointFormat: \"x: \\x3cb\\x3e{point.x}\\x3c/b\\x3e\\x3cbr/\\x3ey: \\x3cb\\x3e{point.y}\\x3c/b\\x3e\\x3cbr/\\x3e\"\n      }\n    }, {\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1,\n      drawGraph: function drawGraph() {\n        this.options.lineWidth && C.prototype.drawGraph.call(this);\n      }\n    });\n  })(K);\n\n  (function (a) {\n    var C = a.deg2rad,\n        E = a.isNumber,\n        F = a.pick,\n        m = a.relativeLength;\n    a.CenteredSeriesMixin = {\n      getCenter: function getCenter() {\n        var a = this.options,\n            e = this.chart,\n            t = 2 * (a.slicedOffset || 0),\n            x = e.plotWidth - 2 * t,\n            e = e.plotHeight - 2 * t,\n            p = a.center,\n            p = [F(p[0], \"50%\"), F(p[1], \"50%\"), a.size || \"100%\", a.innerSize || 0],\n            u = Math.min(x, e),\n            f,\n            c;\n\n        for (f = 0; 4 > f; ++f) {\n          c = p[f], a = 2 > f || 2 === f && /%$/.test(c), p[f] = m(c, [x, e, u, p[2]][f]) + (a ? t : 0);\n        }\n\n        p[3] > p[2] && (p[3] = p[2]);\n        return p;\n      },\n      getStartAndEndRadians: function getStartAndEndRadians(a, e) {\n        a = E(a) ? a : 0;\n        e = E(e) && e > a && 360 > e - a ? e : a + 360;\n        return {\n          start: C * (a + -90),\n          end: C * (e + -90)\n        };\n      }\n    };\n  })(K);\n\n  (function (a) {\n    var C = a.addEvent,\n        E = a.CenteredSeriesMixin,\n        F = a.defined,\n        m = a.each,\n        h = a.extend,\n        e = E.getStartAndEndRadians,\n        t = a.inArray,\n        x = a.noop,\n        p = a.pick,\n        u = a.Point,\n        f = a.Series,\n        c = a.seriesType,\n        k = a.setAnimation;\n    c(\"pie\", \"line\", {\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        distance: 30,\n        enabled: !0,\n        formatter: function formatter() {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        x: 0\n      },\n      ignoreHiddenPoint: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    }, {\n      isCartesian: !1,\n      requireSorting: !1,\n      directTouch: !0,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      axisTypes: [],\n      pointAttribs: a.seriesTypes.column.prototype.pointAttribs,\n      animate: function animate(a) {\n        var c = this,\n            d = c.points,\n            b = c.startAngleRad;\n        a || (m(d, function (a) {\n          var d = a.graphic,\n              f = a.shapeArgs;\n          d && (d.attr({\n            r: a.startR || c.center[3] / 2,\n            start: b,\n            end: b\n          }), d.animate({\n            r: f.r,\n            start: f.start,\n            end: f.end\n          }, c.options.animation));\n        }), c.animate = null);\n      },\n      updateTotals: function updateTotals() {\n        var a,\n            c = 0,\n            d = this.points,\n            b = d.length,\n            f,\n            e = this.options.ignoreHiddenPoint;\n\n        for (a = 0; a < b; a++) {\n          f = d[a], c += e && !f.visible ? 0 : f.isNull ? 0 : f.y;\n        }\n\n        this.total = c;\n\n        for (a = 0; a < b; a++) {\n          f = d[a], f.percentage = 0 < c && (f.visible || !e) ? f.y / c * 100 : 0, f.total = c;\n        }\n      },\n      generatePoints: function generatePoints() {\n        f.prototype.generatePoints.call(this);\n        this.updateTotals();\n      },\n      translate: function translate(a) {\n        this.generatePoints();\n        var c = 0,\n            d = this.options,\n            b = d.slicedOffset,\n            f = b + (d.borderWidth || 0),\n            h,\n            k,\n            m,\n            r = e(d.startAngle, d.endAngle),\n            t = this.startAngleRad = r.start,\n            r = (this.endAngleRad = r.end) - t,\n            u = this.points,\n            n,\n            x = d.dataLabels.distance,\n            d = d.ignoreHiddenPoint,\n            A,\n            C = u.length,\n            G;\n        a || (this.center = a = this.getCenter());\n\n        this.getX = function (b, c, d) {\n          m = Math.asin(Math.min((b - a[1]) / (a[2] / 2 + d.labelDistance), 1));\n          return a[0] + (c ? -1 : 1) * Math.cos(m) * (a[2] / 2 + d.labelDistance);\n        };\n\n        for (A = 0; A < C; A++) {\n          G = u[A];\n          G.labelDistance = p(G.options.dataLabels && G.options.dataLabels.distance, x);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, G.labelDistance);\n          h = t + c * r;\n          if (!d || G.visible) c += G.percentage / 100;\n          k = t + c * r;\n          G.shapeType = \"arc\";\n          G.shapeArgs = {\n            x: a[0],\n            y: a[1],\n            r: a[2] / 2,\n            innerR: a[3] / 2,\n            start: Math.round(1E3 * h) / 1E3,\n            end: Math.round(1E3 * k) / 1E3\n          };\n          m = (k + h) / 2;\n          m > 1.5 * Math.PI ? m -= 2 * Math.PI : m < -Math.PI / 2 && (m += 2 * Math.PI);\n          G.slicedTranslation = {\n            translateX: Math.round(Math.cos(m) * b),\n            translateY: Math.round(Math.sin(m) * b)\n          };\n          k = Math.cos(m) * a[2] / 2;\n          n = Math.sin(m) * a[2] / 2;\n          G.tooltipPos = [a[0] + .7 * k, a[1] + .7 * n];\n          G.half = m < -Math.PI / 2 || m > Math.PI / 2 ? 1 : 0;\n          G.angle = m;\n          h = Math.min(f, G.labelDistance / 5);\n          G.labelPos = [a[0] + k + Math.cos(m) * G.labelDistance, a[1] + n + Math.sin(m) * G.labelDistance, a[0] + k + Math.cos(m) * h, a[1] + n + Math.sin(m) * h, a[0] + k, a[1] + n, 0 > G.labelDistance ? \"center\" : G.half ? \"right\" : \"left\", m];\n        }\n      },\n      drawGraph: null,\n      drawPoints: function drawPoints() {\n        var a = this,\n            c = a.chart.renderer,\n            d,\n            b,\n            f,\n            e,\n            k = a.options.shadow;\n        k && !a.shadowGroup && (a.shadowGroup = c.g(\"shadow\").add(a.group));\n        m(a.points, function (l) {\n          b = l.graphic;\n          if (l.isNull) b && (l.graphic = b.destroy());else {\n            e = l.shapeArgs;\n            d = l.getTranslate();\n            var m = l.shadowGroup;\n            k && !m && (m = l.shadowGroup = c.g(\"shadow\").add(a.shadowGroup));\n            m && m.attr(d);\n            f = a.pointAttribs(l, l.selected && \"select\");\n            b ? b.setRadialReference(a.center).attr(f).animate(h(e, d)) : (l.graphic = b = c[l.shapeType](e).setRadialReference(a.center).attr(d).add(a.group), b.attr(f).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(k, m));\n            b.attr({\n              visibility: l.visible ? \"inherit\" : \"hidden\"\n            });\n            b.addClass(l.getClassName());\n          }\n        });\n      },\n      searchPoint: x,\n      sortByAngle: function sortByAngle(a, c) {\n        a.sort(function (a, b) {\n          return void 0 !== a.angle && (b.angle - a.angle) * c;\n        });\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      getCenter: E.getCenter,\n      getSymbol: x\n    }, {\n      init: function init() {\n        u.prototype.init.apply(this, arguments);\n        var a = this,\n            c;\n        a.name = p(a.name, \"Slice\");\n\n        c = function c(_c) {\n          a.slice(\"select\" === _c.type);\n        };\n\n        C(a, \"select\", c);\n        C(a, \"unselect\", c);\n        return a;\n      },\n      isValid: function isValid() {\n        return a.isNumber(this.y, !0) && 0 <= this.y;\n      },\n      setVisible: function setVisible(a, c) {\n        var d = this,\n            b = d.series,\n            f = b.chart,\n            e = b.options.ignoreHiddenPoint;\n        c = p(c, e);\n        a !== d.visible && (d.visible = d.options.visible = a = void 0 === a ? !d.visible : a, b.options.data[t(d, b.data)] = d.options, m([\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"], function (b) {\n          if (d[b]) d[b][a ? \"show\" : \"hide\"](!0);\n        }), d.legendItem && f.legend.colorizeItem(d, a), a || \"hover\" !== d.state || d.setState(\"\"), e && (b.isDirty = !0), c && f.redraw());\n      },\n      slice: function slice(a, c, d) {\n        var b = this.series;\n        k(d, b.chart);\n        p(c, !0);\n        this.sliced = this.options.sliced = F(a) ? a : !this.sliced;\n        b.options.data[t(this, b.data)] = this.options;\n        this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      },\n      getTranslate: function getTranslate() {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      },\n      haloPath: function haloPath(a) {\n        var c = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + a, c.r + a, {\n          innerR: this.shapeArgs.r - 1,\n          start: c.start,\n          end: c.end\n        });\n      }\n    });\n  })(K);\n\n  (function (a) {\n    var C = a.addEvent,\n        E = a.arrayMax,\n        F = a.defined,\n        m = a.each,\n        h = a.extend,\n        e = a.format,\n        t = a.map,\n        x = a.merge,\n        p = a.noop,\n        u = a.pick,\n        f = a.relativeLength,\n        c = a.Series,\n        k = a.seriesTypes,\n        r = a.some,\n        l = a.stableSort;\n\n    a.distribute = function (c, b, f) {\n      function d(a, b) {\n        return a.target - b.target;\n      }\n\n      var e,\n          h = !0,\n          k = c,\n          p = [],\n          v;\n      v = 0;\n      var n = k.reducedLen || b;\n\n      for (e = c.length; e--;) {\n        v += c[e].size;\n      }\n\n      if (v > n) {\n        l(c, function (a, b) {\n          return (b.rank || 0) - (a.rank || 0);\n        });\n\n        for (v = e = 0; v <= n;) {\n          v += c[e].size, e++;\n        }\n\n        p = c.splice(e - 1, c.length);\n      }\n\n      l(c, d);\n\n      for (c = t(c, function (a) {\n        return {\n          size: a.size,\n          targets: [a.target],\n          align: u(a.align, .5)\n        };\n      }); h;) {\n        for (e = c.length; e--;) {\n          h = c[e], v = (Math.min.apply(0, h.targets) + Math.max.apply(0, h.targets)) / 2, h.pos = Math.min(Math.max(0, v - h.size * h.align), b - h.size);\n        }\n\n        e = c.length;\n\n        for (h = !1; e--;) {\n          0 < e && c[e - 1].pos + c[e - 1].size > c[e].pos && (c[e - 1].size += c[e].size, c[e - 1].targets = c[e - 1].targets.concat(c[e].targets), c[e - 1].align = .5, c[e - 1].pos + c[e - 1].size > b && (c[e - 1].pos = b - c[e - 1].size), c.splice(e, 1), h = !0);\n        }\n      }\n\n      k.push.apply(k, p);\n      e = 0;\n      r(c, function (c) {\n        var d = 0;\n        if (r(c.targets, function () {\n          k[e].pos = c.pos + d;\n          if (Math.abs(k[e].pos - k[e].target) > f) return m(k.slice(0, e + 1), function (a) {\n            delete a.pos;\n          }), k.reducedLen = (k.reducedLen || b) - .1 * b, k.reducedLen > .1 * b && a.distribute(k, b, f), !0;\n          d += k[e].size;\n          e++;\n        })) return !0;\n      });\n      l(k, d);\n    };\n\n    c.prototype.drawDataLabels = function () {\n      function c(a, b) {\n        var c = b.filter;\n        return c ? (b = c.operator, a = a[c.property], c = c.value, \"\\x3e\" === b && a > c || \"\\x3c\" === b && a < c || \"\\x3e\\x3d\" === b && a >= c || \"\\x3c\\x3d\" === b && a <= c || \"\\x3d\\x3d\" === b && a == c || \"\\x3d\\x3d\\x3d\" === b && a === c ? !0 : !1) : !0;\n      }\n\n      var b = this,\n          f = b.chart,\n          h = b.options,\n          k = h.dataLabels,\n          l = b.points,\n          p,\n          r,\n          t = b.hasRendered || 0,\n          n,\n          D,\n          A = u(k.defer, !!h.animation),\n          E = f.renderer;\n      if (k.enabled || b._hasPointLabels) b.dlProcessOptions && b.dlProcessOptions(k), D = b.plotGroup(\"dataLabelsGroup\", \"data-labels\", A && !t ? \"hidden\" : \"visible\", k.zIndex || 6), A && (D.attr({\n        opacity: +t\n      }), t || C(b, \"afterAnimate\", function () {\n        b.visible && D.show(!0);\n        D[h.animation ? \"animate\" : \"attr\"]({\n          opacity: 1\n        }, {\n          duration: 200\n        });\n      })), r = k, m(l, function (d) {\n        var g,\n            l = d.dataLabel,\n            m,\n            q,\n            w = d.connector,\n            t = !l,\n            v;\n        p = d.dlOptions || d.options && d.options.dataLabels;\n        (g = u(p && p.enabled, r.enabled) && !d.isNull) && (g = !0 === c(d, p || k));\n        g && (k = x(r, p), m = d.getLabelConfig(), v = k[d.formatPrefix + \"Format\"] || k.format, n = F(v) ? e(v, m, f.time) : (k[d.formatPrefix + \"Formatter\"] || k.formatter).call(m, k), v = k.style, m = k.rotation, v.color = u(k.color, v.color, b.color, \"#000000\"), \"contrast\" === v.color && (d.contrastColor = E.getContrast(d.color || b.color), v.color = k.inside || 0 > u(d.labelDistance, k.distance) || h.stacking ? d.contrastColor : \"#000000\"), h.cursor && (v.cursor = h.cursor), q = {\n          fill: k.backgroundColor,\n          stroke: k.borderColor,\n          \"stroke-width\": k.borderWidth,\n          r: k.borderRadius || 0,\n          rotation: m,\n          padding: k.padding,\n          zIndex: 1\n        }, a.objectEach(q, function (a, b) {\n          void 0 === a && delete q[b];\n        }));\n        !l || g && F(n) ? g && F(n) && (l ? q.text = n : (l = d.dataLabel = m ? E.text(n, 0, -9999, k.useHTML).addClass(\"highcharts-data-label\") : E.label(n, 0, -9999, k.shape, null, null, k.useHTML, null, \"data-label\"), l.addClass(\" highcharts-data-label-color-\" + d.colorIndex + \" \" + (k.className || \"\") + (k.useHTML ? \" highcharts-tracker\" : \"\"))), l.attr(q), l.css(v).shadow(k.shadow), l.added || l.add(D), b.alignDataLabel(d, l, k, null, t)) : (d.dataLabel = l = l.destroy(), w && (d.connector = w.destroy()));\n      });\n      a.fireEvent(this, \"afterDrawDataLabels\");\n    };\n\n    c.prototype.alignDataLabel = function (a, b, c, e, f) {\n      var d = this.chart,\n          k = d.inverted,\n          l = u(a.dlBox && a.dlBox.centerX, a.plotX, -9999),\n          m = u(a.plotY, -9999),\n          n = b.getBBox(),\n          q,\n          p = c.rotation,\n          r = c.align,\n          t = this.visible && (a.series.forceDL || d.isInsidePlot(l, Math.round(m), k) || e && d.isInsidePlot(l, k ? e.x + 1 : e.y + e.height - 1, k)),\n          g = \"justify\" === u(c.overflow, \"justify\");\n      if (t && (q = c.style.fontSize, q = d.renderer.fontMetrics(q, b).b, e = h({\n        x: k ? this.yAxis.len - m : l,\n        y: Math.round(k ? this.xAxis.len - l : m),\n        width: 0,\n        height: 0\n      }, e), h(c, {\n        width: n.width,\n        height: n.height\n      }), p ? (g = !1, l = d.renderer.rotCorr(q, p), l = {\n        x: e.x + c.x + e.width / 2 + l.x,\n        y: e.y + c.y + {\n          top: 0,\n          middle: .5,\n          bottom: 1\n        }[c.verticalAlign] * e.height\n      }, b[f ? \"attr\" : \"animate\"](l).attr({\n        align: r\n      }), m = (p + 720) % 360, m = 180 < m && 360 > m, \"left\" === r ? l.y -= m ? n.height : 0 : \"center\" === r ? (l.x -= n.width / 2, l.y -= n.height / 2) : \"right\" === r && (l.x -= n.width, l.y -= m ? 0 : n.height), b.placed = !0, b.alignAttr = l) : (b.align(c, null, e), l = b.alignAttr), g && 0 <= e.height ? a.isLabelJustified = this.justifyDataLabel(b, c, l, n, e, f) : u(c.crop, !0) && (t = d.isInsidePlot(l.x, l.y) && d.isInsidePlot(l.x + n.width, l.y + n.height)), c.shape && !p)) b[f ? \"attr\" : \"animate\"]({\n        anchorX: k ? d.plotWidth - a.plotY : a.plotX,\n        anchorY: k ? d.plotHeight - a.plotX : a.plotY\n      });\n      t || (b.attr({\n        y: -9999\n      }), b.placed = !1);\n    };\n\n    c.prototype.justifyDataLabel = function (a, b, c, e, f, h) {\n      var d = this.chart,\n          k = b.align,\n          l = b.verticalAlign,\n          n,\n          m,\n          q = a.box ? 0 : a.padding || 0;\n      n = c.x + q;\n      0 > n && (\"right\" === k ? b.align = \"left\" : b.x = -n, m = !0);\n      n = c.x + e.width - q;\n      n > d.plotWidth && (\"left\" === k ? b.align = \"right\" : b.x = d.plotWidth - n, m = !0);\n      n = c.y + q;\n      0 > n && (\"bottom\" === l ? b.verticalAlign = \"top\" : b.y = -n, m = !0);\n      n = c.y + e.height - q;\n      n > d.plotHeight && (\"top\" === l ? b.verticalAlign = \"bottom\" : b.y = d.plotHeight - n, m = !0);\n      m && (a.placed = !h, a.align(b, null, f));\n      return m;\n    };\n\n    k.pie && (k.pie.prototype.drawDataLabels = function () {\n      var d = this,\n          b = d.data,\n          e,\n          f = d.chart,\n          h = d.options.dataLabels,\n          k = u(h.connectorPadding, 10),\n          l = u(h.connectorWidth, 1),\n          p = f.plotWidth,\n          r = f.plotHeight,\n          n = Math.round(f.chartWidth / 3),\n          t,\n          x = d.center,\n          C = x[2] / 2,\n          G = x[1],\n          g,\n          y,\n          K,\n          N,\n          J = [[], []],\n          P,\n          O,\n          z,\n          R,\n          S = [0, 0, 0, 0];\n      d.visible && (h.enabled || d._hasPointLabels) && (m(b, function (a) {\n        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n          width: \"auto\"\n        }).css({\n          width: \"auto\",\n          textOverflow: \"clip\"\n        }), a.dataLabel.shortened = !1);\n      }), c.prototype.drawDataLabels.apply(d), m(b, function (a) {\n        a.dataLabel && (a.visible ? (J[a.half].push(a), a.dataLabel._pos = null, !F(h.style.width) && !F(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > n && (a.dataLabel.css({\n          width: .7 * n\n        }), a.dataLabel.shortened = !0)) : a.dataLabel = a.dataLabel.destroy());\n      }), m(J, function (b, c) {\n        var l,\n            n,\n            q = b.length,\n            w = [],\n            t;\n        if (q) for (d.sortByAngle(b, c - .5), 0 < d.maxLabelDistance && (l = Math.max(0, G - C - d.maxLabelDistance), n = Math.min(G + C + d.maxLabelDistance, f.plotHeight), m(b, function (a) {\n          0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, G - C - a.labelDistance), a.bottom = Math.min(G + C + a.labelDistance, f.plotHeight), t = a.dataLabel.getBBox().height || 21, a.distributeBox = {\n            target: a.labelPos[1] - a.top + t / 2,\n            size: t,\n            rank: a.y\n          }, w.push(a.distributeBox));\n        }), l = n + t - l, a.distribute(w, l, l / 5)), R = 0; R < q; R++) {\n          e = b[R], K = e.labelPos, g = e.dataLabel, z = !1 === e.visible ? \"hidden\" : \"inherit\", O = l = K[1], w && F(e.distributeBox) && (void 0 === e.distributeBox.pos ? z = \"hidden\" : (N = e.distributeBox.size, O = e.top + e.distributeBox.pos)), delete e.positionIndex, P = h.justify ? x[0] + (c ? -1 : 1) * (C + e.labelDistance) : d.getX(O < e.top + 2 || O > e.bottom - 2 ? l : O, c, e), g._attr = {\n            visibility: z,\n            align: K[6]\n          }, g._pos = {\n            x: P + h.x + ({\n              left: k,\n              right: -k\n            }[K[6]] || 0),\n            y: O + h.y - 10\n          }, K.x = P, K.y = O, u(h.crop, !0) && (y = g.getBBox().width, l = null, P - y < k && 1 === c ? (l = Math.round(y - P + k), S[3] = Math.max(l, S[3])) : P + y > p - k && 0 === c && (l = Math.round(P + y - p + k), S[1] = Math.max(l, S[1])), 0 > O - N / 2 ? S[0] = Math.max(Math.round(-O + N / 2), S[0]) : O + N / 2 > r && (S[2] = Math.max(Math.round(O + N / 2 - r), S[2])), g.sideOverflow = l);\n        }\n      }), 0 === E(S) || this.verifyDataLabelOverflow(S)) && (this.placeDataLabels(), l && m(this.points, function (a) {\n        var b;\n        t = a.connector;\n\n        if ((g = a.dataLabel) && g._pos && a.visible && 0 < a.labelDistance) {\n          z = g._attr.visibility;\n          if (b = !t) a.connector = t = f.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + a.colorIndex + (a.className ? \" \" + a.className : \"\")).add(d.dataLabelsGroup), t.attr({\n            \"stroke-width\": l,\n            stroke: h.connectorColor || a.color || \"#666666\"\n          });\n          t[b ? \"attr\" : \"animate\"]({\n            d: d.connectorPath(a.labelPos)\n          });\n          t.attr(\"visibility\", z);\n        } else t && (a.connector = t.destroy());\n      }));\n    }, k.pie.prototype.connectorPath = function (a) {\n      var b = a.x,\n          c = a.y;\n      return u(this.options.dataLabels.softConnector, !0) ? [\"M\", b + (\"left\" === a[6] ? 5 : -5), c, \"C\", b, c, 2 * a[2] - a[4], 2 * a[3] - a[5], a[2], a[3], \"L\", a[4], a[5]] : [\"M\", b + (\"left\" === a[6] ? 5 : -5), c, \"L\", a[2], a[3], \"L\", a[4], a[5]];\n    }, k.pie.prototype.placeDataLabels = function () {\n      m(this.points, function (a) {\n        var b = a.dataLabel;\n        b && a.visible && ((a = b._pos) ? (b.sideOverflow && (b._attr.width = b.getBBox().width - b.sideOverflow, b.css({\n          width: b._attr.width + \"px\",\n          textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n        }), b.shortened = !0), b.attr(b._attr), b[b.moved ? \"animate\" : \"attr\"](a), b.moved = !0) : b && b.attr({\n          y: -9999\n        }));\n      }, this);\n    }, k.pie.prototype.alignDataLabel = p, k.pie.prototype.verifyDataLabelOverflow = function (a) {\n      var b = this.center,\n          c = this.options,\n          d = c.center,\n          e = c.minSize || 80,\n          h,\n          k = null !== c.size;\n      k || (null !== d[0] ? h = Math.max(b[2] - Math.max(a[1], a[3]), e) : (h = Math.max(b[2] - a[1] - a[3], e), b[0] += (a[3] - a[1]) / 2), null !== d[1] ? h = Math.max(Math.min(h, b[2] - Math.max(a[0], a[2])), e) : (h = Math.max(Math.min(h, b[2] - a[0] - a[2]), e), b[1] += (a[0] - a[2]) / 2), h < b[2] ? (b[2] = h, b[3] = Math.min(f(c.innerSize || 0, h), h), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : k = !0);\n      return k;\n    });\n    k.column && (k.column.prototype.alignDataLabel = function (a, b, e, f, h) {\n      var d = this.chart.inverted,\n          k = a.series,\n          l = a.dlBox || a.shapeArgs,\n          m = u(a.below, a.plotY > u(this.translatedThreshold, k.yAxis.len)),\n          n = u(e.inside, !!this.options.stacking);\n      l && (f = x(l), 0 > f.y && (f.height += f.y, f.y = 0), l = f.y + f.height - k.yAxis.len, 0 < l && (f.height -= l), d && (f = {\n        x: k.yAxis.len - f.y - f.height,\n        y: k.xAxis.len - f.x - f.width,\n        width: f.height,\n        height: f.width\n      }), n || (d ? (f.x += m ? 0 : f.width, f.width = 0) : (f.y += m ? f.height : 0, f.height = 0)));\n      e.align = u(e.align, !d || n ? \"center\" : m ? \"right\" : \"left\");\n      e.verticalAlign = u(e.verticalAlign, d || n ? \"middle\" : m ? \"top\" : \"bottom\");\n      c.prototype.alignDataLabel.call(this, a, b, e, f, h);\n      a.isLabelJustified && a.contrastColor && a.dataLabel.css({\n        color: a.contrastColor\n      });\n    });\n  })(K);\n\n  (function (a) {\n    var C = a.Chart,\n        E = a.each,\n        F = a.objectEach,\n        m = a.pick;\n    a = a.addEvent;\n    a(C, \"render\", function () {\n      var a = [];\n      E(this.labelCollectors || [], function (e) {\n        a = a.concat(e());\n      });\n      E(this.yAxis || [], function (e) {\n        e.options.stackLabels && !e.options.stackLabels.allowOverlap && F(e.stacks, function (e) {\n          F(e, function (e) {\n            a.push(e.label);\n          });\n        });\n      });\n      E(this.series || [], function (e) {\n        var h = e.options.dataLabels,\n            x = e.dataLabelCollections || [\"dataLabel\"];\n        (h.enabled || e._hasPointLabels) && !h.allowOverlap && e.visible && E(x, function (h) {\n          E(e.points, function (e) {\n            e[h] && e.visible && (e[h].labelrank = m(e.labelrank, e.shapeArgs && e.shapeArgs.height), a.push(e[h]));\n          });\n        });\n      });\n      this.hideOverlappingLabels(a);\n    });\n\n    C.prototype.hideOverlappingLabels = function (a) {\n      var e = a.length,\n          h = this.renderer,\n          m,\n          p,\n          u,\n          f,\n          c,\n          k,\n          r = function r(a, c, b, e, f, h, k, m) {\n        return !(f > a + b || f + k < a || h > c + e || h + m < c);\n      };\n\n      u = function u(a) {\n        var c,\n            b,\n            e,\n            f = 2 * (a.box ? 0 : a.padding || 0);\n        e = 0;\n        if (a && (!a.alignAttr || a.placed)) return c = a.alignAttr || {\n          x: a.attr(\"x\"),\n          y: a.attr(\"y\")\n        }, b = a.parentGroup, a.width || (e = a.getBBox(), a.width = e.width, a.height = e.height, e = h.fontMetrics(null, a.element).h), {\n          x: c.x + (b.translateX || 0),\n          y: c.y + (b.translateY || 0) - e,\n          width: a.width - f,\n          height: a.height - f\n        };\n      };\n\n      for (p = 0; p < e; p++) {\n        if (m = a[p]) m.oldOpacity = m.opacity, m.newOpacity = 1, m.absoluteBox = u(m);\n      }\n\n      a.sort(function (a, c) {\n        return (c.labelrank || 0) - (a.labelrank || 0);\n      });\n\n      for (p = 0; p < e; p++) {\n        for (k = (u = a[p]) && u.absoluteBox, m = p + 1; m < e; ++m) {\n          if (c = (f = a[m]) && f.absoluteBox, k && c && u !== f && 0 !== u.newOpacity && 0 !== f.newOpacity && (c = r(k.x, k.y, k.width, k.height, c.x, c.y, c.width, c.height))) (u.labelrank < f.labelrank ? u : f).newOpacity = 0;\n        }\n      }\n\n      E(a, function (a) {\n        var c, b;\n        a && (b = a.newOpacity, a.oldOpacity !== b && (a.alignAttr && a.placed ? (b ? a.show(!0) : c = function c() {\n          a.hide();\n        }, a.alignAttr.opacity = b, a[a.isOld ? \"animate\" : \"attr\"](a.alignAttr, null, c)) : a.attr({\n          opacity: b\n        })), a.isOld = !0);\n      });\n    };\n  })(K);\n\n  (function (a) {\n    var C = a.addEvent,\n        E = a.Chart,\n        F = a.createElement,\n        m = a.css,\n        h = a.defaultOptions,\n        e = a.defaultPlotOptions,\n        t = a.each,\n        x = a.extend,\n        p = a.fireEvent,\n        u = a.hasTouch,\n        f = a.inArray,\n        c = a.isObject,\n        k = a.Legend,\n        r = a.merge,\n        l = a.pick,\n        d = a.Point,\n        b = a.Series,\n        v = a.seriesTypes,\n        q = a.svg,\n        I;\n    I = a.TrackerMixin = {\n      drawTrackerPoint: function drawTrackerPoint() {\n        var a = this,\n            b = a.chart.pointer,\n            c = function c(a) {\n          var c = b.getPointFromEvent(a);\n          void 0 !== c && (b.isDirectTouch = !0, c.onMouseOver(a));\n        };\n\n        t(a.points, function (a) {\n          a.graphic && (a.graphic.element.point = a);\n          a.dataLabel && (a.dataLabel.div ? a.dataLabel.div.point = a : a.dataLabel.element.point = a);\n        });\n        a._hasTracking || (t(a.trackerGroups, function (d) {\n          if (a[d]) {\n            a[d].addClass(\"highcharts-tracker\").on(\"mouseover\", c).on(\"mouseout\", function (a) {\n              b.onTrackerMouseOut(a);\n            });\n            if (u) a[d].on(\"touchstart\", c);\n            a.options.cursor && a[d].css(m).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n        p(this, \"afterDrawTracker\");\n      },\n      drawTrackerGraph: function drawTrackerGraph() {\n        var a = this,\n            b = a.options,\n            c = b.trackByArea,\n            d = [].concat(c ? a.areaPath : a.graphPath),\n            e = d.length,\n            f = a.chart,\n            h = f.pointer,\n            k = f.renderer,\n            l = f.options.tooltip.snap,\n            g = a.tracker,\n            m,\n            r = function r() {\n          if (f.hoverSeries !== a) a.onMouseOver();\n        },\n            x = \"rgba(192,192,192,\" + (q ? .0001 : .002) + \")\";\n\n        if (e && !c) for (m = e + 1; m--;) {\n          \"M\" === d[m] && d.splice(m + 1, 0, d[m + 1] - l, d[m + 2], \"L\"), (m && \"M\" === d[m] || m === e) && d.splice(m, 0, \"L\", d[m - 2] + l, d[m - 1]);\n        }\n        g ? g.attr({\n          d: d\n        }) : a.graph && (a.tracker = k.path(d).attr({\n          \"stroke-linejoin\": \"round\",\n          stroke: x,\n          fill: c ? x : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (c ? 0 : 2 * l),\n          visibility: a.visible ? \"visible\" : \"hidden\",\n          zIndex: 2\n        }).addClass(c ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(a.group), t([a.tracker, a.markerGroup], function (a) {\n          a.addClass(\"highcharts-tracker\").on(\"mouseover\", r).on(\"mouseout\", function (a) {\n            h.onTrackerMouseOut(a);\n          });\n          b.cursor && a.css({\n            cursor: b.cursor\n          });\n          if (u) a.on(\"touchstart\", r);\n        }));\n        p(this, \"afterDrawTracker\");\n      }\n    };\n    v.column && (v.column.prototype.drawTracker = I.drawTrackerPoint);\n    v.pie && (v.pie.prototype.drawTracker = I.drawTrackerPoint);\n    v.scatter && (v.scatter.prototype.drawTracker = I.drawTrackerPoint);\n    x(k.prototype, {\n      setItemEvents: function setItemEvents(a, b, c) {\n        var e = this,\n            f = e.chart.renderer.boxWrapper,\n            h = \"highcharts-legend-\" + (a instanceof d ? \"point\" : \"series\") + \"-active\";\n        (c ? b : a.legendGroup).on(\"mouseover\", function () {\n          a.setState(\"hover\");\n          f.addClass(h);\n          b.css(e.options.itemHoverStyle);\n        }).on(\"mouseout\", function () {\n          b.css(r(a.visible ? e.itemStyle : e.itemHiddenStyle));\n          f.removeClass(h);\n          a.setState();\n        }).on(\"click\", function (b) {\n          var c = function c() {\n            a.setVisible && a.setVisible();\n          };\n\n          f.removeClass(h);\n          b = {\n            browserEvent: b\n          };\n          a.firePointEvent ? a.firePointEvent(\"legendItemClick\", b, c) : p(a, \"legendItemClick\", b, c);\n        });\n      },\n      createCheckboxForItem: function createCheckboxForItem(a) {\n        a.checkbox = F(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        C(a.checkbox, \"click\", function (b) {\n          p(a.series || a, \"checkboxClick\", {\n            checked: b.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      }\n    });\n    h.legend.itemStyle.cursor = \"pointer\";\n    x(E.prototype, {\n      showResetZoom: function showResetZoom() {\n        function a() {\n          b.zoomOut();\n        }\n\n        var b = this,\n            c = h.lang,\n            d = b.options.chart.resetZoomButton,\n            e = d.theme,\n            f = e.states,\n            k = \"chart\" === d.relativeTo ? null : \"plotBox\";\n        p(this, \"beforeShowResetZoom\", null, function () {\n          b.resetZoomButton = b.renderer.button(c.resetZoom, null, null, a, e, f && f.hover).attr({\n            align: d.position.align,\n            title: c.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(d.position, !1, k);\n        });\n      },\n      zoomOut: function zoomOut() {\n        p(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      },\n      zoom: function zoom(a) {\n        var b,\n            d = this.pointer,\n            e = !1,\n            f;\n        !a || a.resetSelection ? (t(this.axes, function (a) {\n          b = a.zoom();\n        }), d.initiated = !1) : t(a.xAxis.concat(a.yAxis), function (a) {\n          var c = a.axis;\n          d[c.isXAxis ? \"zoomX\" : \"zoomY\"] && (b = c.zoom(a.min, a.max), c.displayBtn && (e = !0));\n        });\n        f = this.resetZoomButton;\n        e && !f ? this.showResetZoom() : !e && c(f) && (this.resetZoomButton = f.destroy());\n        b && this.redraw(l(this.options.chart.animation, a && a.animation, 100 > this.pointCount));\n      },\n      pan: function pan(a, b) {\n        var c = this,\n            d = c.hoverPoints,\n            e;\n        d && t(d, function (a) {\n          a.setState();\n        });\n        t(\"xy\" === b ? [1, 0] : [1], function (b) {\n          b = c[b ? \"xAxis\" : \"yAxis\"][0];\n          var d = b.horiz,\n              f = a[d ? \"chartX\" : \"chartY\"],\n              d = d ? \"mouseDownX\" : \"mouseDownY\",\n              h = c[d],\n              g = (b.pointRange || 0) / 2,\n              k = b.reversed && !c.inverted || !b.reversed && c.inverted ? -1 : 1,\n              l = b.getExtremes(),\n              n = b.toValue(h - f, !0) + g * k,\n              k = b.toValue(h + b.len - f, !0) - g * k,\n              m = k < n,\n              h = m ? k : n,\n              n = m ? n : k,\n              k = Math.min(l.dataMin, g ? l.min : b.toValue(b.toPixels(l.min) - b.minPixelPadding)),\n              g = Math.max(l.dataMax, g ? l.max : b.toValue(b.toPixels(l.max) + b.minPixelPadding)),\n              m = k - h;\n          0 < m && (n += m, h = k);\n          m = n - g;\n          0 < m && (n = g, h -= m);\n          b.series.length && h !== l.min && n !== l.max && (b.setExtremes(h, n, !1, !1, {\n            trigger: \"pan\"\n          }), e = !0);\n          c[d] = f;\n        });\n        e && c.redraw(!1);\n        m(c.container, {\n          cursor: \"move\"\n        });\n      }\n    });\n    x(d.prototype, {\n      select: function select(a, b) {\n        var c = this,\n            d = c.series,\n            e = d.chart;\n        a = l(a, !c.selected);\n        c.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: b\n        }, function () {\n          c.selected = c.options.selected = a;\n          d.options.data[f(c, d.data)] = c.options;\n          c.setState(a && \"select\");\n          b || t(e.getSelectedPoints(), function (a) {\n            a.selected && a !== c && (a.selected = a.options.selected = !1, d.options.data[f(a, d.data)] = a.options, a.setState(\"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n      },\n      onMouseOver: function onMouseOver(a) {\n        var b = this.series.chart,\n            c = b.pointer;\n        a = a ? c.normalize(a) : c.getChartCoordinatesFromPoint(this, b.inverted);\n        c.runPointActions(a, this);\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        t(a.hoverPoints || [], function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      },\n      importEvents: function importEvents() {\n        if (!this.hasImportedEvents) {\n          var b = this,\n              c = r(b.series.options.point, b.options).events;\n          b.events = c;\n          a.objectEach(c, function (a, c) {\n            C(b, c, a);\n          });\n          this.hasImportedEvents = !0;\n        }\n      },\n      setState: function setState(a, b) {\n        var c = Math.floor(this.plotX),\n            d = this.plotY,\n            f = this.series,\n            h = f.options.states[a || \"normal\"] || {},\n            k = e[f.type].marker && f.options.marker,\n            m = k && !1 === k.enabled,\n            q = k && k.states && k.states[a || \"normal\"] || {},\n            g = !1 === q.enabled,\n            r = f.stateMarkerGraphic,\n            t = this.marker || {},\n            u = f.chart,\n            w = f.halo,\n            v,\n            C = k && f.markerAttribs;\n        a = a || \"\";\n\n        if (!(a === this.state && !b || this.selected && \"select\" !== a || !1 === h.enabled || a && (g || m && !1 === q.enabled) || a && t.states && t.states[a] && !1 === t.states[a].enabled)) {\n          C && (v = f.markerAttribs(this, a));\n          if (this.graphic) this.state && this.graphic.removeClass(\"highcharts-point-\" + this.state), a && this.graphic.addClass(\"highcharts-point-\" + a), this.graphic.animate(f.pointAttribs(this, a), l(u.options.chart.animation, h.animation)), v && this.graphic.animate(v, l(u.options.chart.animation, q.animation, k.animation)), r && r.hide();else {\n            if (a && q) {\n              k = t.symbol || f.symbol;\n              r && r.currentSymbol !== k && (r = r.destroy());\n              if (r) r[b ? \"animate\" : \"attr\"]({\n                x: v.x,\n                y: v.y\n              });else k && (f.stateMarkerGraphic = r = u.renderer.symbol(k, v.x, v.y, v.width, v.height).add(f.markerGroup), r.currentSymbol = k);\n              r && r.attr(f.pointAttribs(this, a));\n            }\n\n            r && (r[a && u.isInsidePlot(c, d, u.inverted) ? \"show\" : \"hide\"](), r.element.point = this);\n          }\n          (c = h.halo) && c.size ? (w || (f.halo = w = u.renderer.path().add((this.graphic || r).parentGroup)), w.show()[b ? \"animate\" : \"attr\"]({\n            d: this.haloPath(c.size)\n          }), w.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + l(this.colorIndex, f.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            zIndex: -1\n          }), w.point = this, w.attr(x({\n            fill: this.color || f.color,\n            \"fill-opacity\": c.opacity\n          }, c.attributes))) : w && w.point && w.point.haloPath && w.animate({\n            d: w.point.haloPath(0)\n          }, null, w.hide);\n          this.state = a;\n          p(this, \"afterSetState\");\n        }\n      },\n      haloPath: function haloPath(a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      }\n    });\n    x(b.prototype, {\n      onMouseOver: function onMouseOver() {\n        var a = this.chart,\n            b = a.hoverSeries;\n        if (b && b !== this) b.onMouseOut();\n        this.options.events.mouseOver && p(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.options,\n            b = this.chart,\n            c = b.tooltip,\n            d = b.hoverPoint;\n        b.hoverSeries = null;\n        if (d) d.onMouseOut();\n        this && a.events.mouseOut && p(this, \"mouseOut\");\n        !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();\n        this.setState();\n      },\n      setState: function setState(a) {\n        var b = this,\n            c = b.options,\n            d = b.graph,\n            e = c.states,\n            f = c.lineWidth,\n            c = 0;\n        a = a || \"\";\n        if (b.state !== a && (t([b.group, b.markerGroup, b.dataLabelsGroup], function (c) {\n          c && (b.state && c.removeClass(\"highcharts-series-\" + b.state), a && c.addClass(\"highcharts-series-\" + a));\n        }), b.state = a, !e[a] || !1 !== e[a].enabled) && (a && (f = e[a].lineWidth || f + (e[a].lineWidthPlus || 0)), d && !d.dashstyle)) for (f = {\n          \"stroke-width\": f\n        }, d.animate(f, l(e[a || \"normal\"] && e[a || \"normal\"].animation, b.chart.options.chart.animation)); b[\"zone-graph-\" + c];) {\n          b[\"zone-graph-\" + c].attr(f), c += 1;\n        }\n      },\n      setVisible: function setVisible(a, b) {\n        var c = this,\n            d = c.chart,\n            e = c.legendItem,\n            f,\n            h = d.options.chart.ignoreHiddenSeries,\n            k = c.visible;\n        f = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !k : a) ? \"show\" : \"hide\";\n        t([\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"], function (a) {\n          if (c[a]) c[a][f]();\n        });\n        if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();\n        e && d.legend.colorizeItem(c, a);\n        c.isDirty = !0;\n        c.options.stacking && t(d.series, function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        t(c.linkedSeries, function (b) {\n          b.setVisible(a, !1);\n        });\n        h && (d.isDirtyBox = !0);\n        p(c, f);\n        !1 !== b && d.redraw();\n      },\n      show: function show() {\n        this.setVisible(!0);\n      },\n      hide: function hide() {\n        this.setVisible(!1);\n      },\n      select: function select(a) {\n        this.selected = a = void 0 === a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        p(this, a ? \"select\" : \"unselect\");\n      },\n      drawTracker: I.drawTrackerGraph\n    });\n  })(K);\n\n  (function (a) {\n    var C = a.Chart,\n        E = a.each,\n        F = a.inArray,\n        m = a.isArray,\n        h = a.isObject,\n        e = a.pick,\n        t = a.splat;\n\n    C.prototype.setResponsive = function (e) {\n      var h = this.options.responsive,\n          m = [],\n          f = this.currentResponsive;\n      h && h.rules && E(h.rules, function (c) {\n        void 0 === c._id && (c._id = a.uniqueKey());\n        this.matchResponsiveRule(c, m, e);\n      }, this);\n      var c = a.merge.apply(0, a.map(m, function (c) {\n        return a.find(h.rules, function (a) {\n          return a._id === c;\n        }).chartOptions;\n      })),\n          m = m.toString() || void 0;\n      m !== (f && f.ruleIds) && (f && this.update(f.undoOptions, e), m ? (this.currentResponsive = {\n        ruleIds: m,\n        mergedOptions: c,\n        undoOptions: this.currentOptions(c)\n      }, this.update(c, e)) : this.currentResponsive = void 0);\n    };\n\n    C.prototype.matchResponsiveRule = function (a, h) {\n      var m = a.condition;\n      (m.callback || function () {\n        return this.chartWidth <= e(m.maxWidth, Number.MAX_VALUE) && this.chartHeight <= e(m.maxHeight, Number.MAX_VALUE) && this.chartWidth >= e(m.minWidth, 0) && this.chartHeight >= e(m.minHeight, 0);\n      }).call(this) && h.push(a._id);\n    };\n\n    C.prototype.currentOptions = function (e) {\n      function p(e, c, k, r) {\n        var f;\n        a.objectEach(e, function (a, b) {\n          if (!r && -1 < F(b, [\"series\", \"xAxis\", \"yAxis\"])) for (a = t(a), k[b] = [], f = 0; f < a.length; f++) {\n            c[b][f] && (k[b][f] = {}, p(a[f], c[b][f], k[b][f], r + 1));\n          } else h(a) ? (k[b] = m(a) ? [] : {}, p(a, c[b] || {}, k[b], r + 1)) : k[b] = c[b] || null;\n        });\n      }\n\n      var u = {};\n      p(e, this.options, u, 0);\n      return u;\n    };\n  })(K);\n\n  return K;\n});","map":null,"metadata":{},"sourceType":"script"}